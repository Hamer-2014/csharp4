Chapter 1. Introducing C# and the .NET Framewrok
================================================

C#是一种通用，类型安全，面向对象的编程语言。C#语言的目的是程序员的生产力。为了达到这一目的，C#语言是在简单性，表现性与性能之间进行平衡。由第一版开始，C#语言的主架构师是Anders
Hejlsberg。

面向对象
--------

C#是一种面向对象范例的富实现，其包含封装，继承与多态。封装意味着在对象周围创建一个边界来将其外部（公开的）行为与其内部（私有的）实现细节相分离。由面向对象的角度来看，C#独具的特性是：

统一类型系统

C#语言中基础构建块是数据与函数的封装单元，被称之为类型。C#具有统一的类型系统，其中所有的类型最终都会共享一个通用的基类型。这就意味着所有的类型，无论他们表示业务对象或是基本类型，例如数字，都共享相同的基本功能集合。例如，所有的类型都可以通过调用其ToString方法转换为一个字符串。

类与接口

在纯面向对象的范例中，唯一的类型种类就是类。在C#中，还有其他的类型种类，interface就是其中之一（类似于Java的接口）。接口类似于一个类，所不同的是他只是类型的定义，而不是实现。在需要多继承时，接口就显得十分用（与C++或Eiffel不同，C#不支持类的多继承）。

属性，方法与事件

在纯面向对象范例中，所有的函数都是方法（在Smalltalk中是这种情况）。在C#语言中，方法只是一种类型的函数成员，函数成员还包括属性与事件（也还有其他的）。属性是封装了一个对象状态的片段的函数成员，例如按钮的颜色或是标签的文本。事件是简化对象状态改变上的响应的函数成员。

类型安全
--------

C#根本上是一种类型安全的语言，意味着类型只能通过他们所定义的协议进行交互，从而保证每种类型的内部一致性。例如，C#不允许我们与一个字符串类型交互，尽管他是一个整数类型。

更为特殊的，C#支持静态类型，意味着语言强制编译时类型安全。这是对.NET
CLR所强制的运行时类型安全的补充。

静态类型减少了大量程序运行之前的错误种类。他将负担由运行时单元测试转移到编译来验证程序中的所有类型正确的组合。这使得大程序更容易管理，更可预测，以及更健壮。而且，静态类型使得类似Visual
Studio中的IntelliSense这样的工作可以帮助我们编写程序，因为他知道一个指定的变量是什么类型，从而了解在这个变量上我们可以调用哪些方法。

注意：C#
4.0允许我们通过新的dynamic关键使得我们的部分代码成为动态的。然而，C#保留了静态类型语言的优势。

C#被称之为强类型语言，因为其类型规则非常严格。例如，我们不能使用一个浮点数来调用被设计用来接受整数的函数，除非我们有首先显式的将浮点数转换为整数。这有助于避免失误。

强类型同时在使得C#代码运行在沙盒中扮演重要角色－所谓的沙盒是一种环境，其中所有的安全方面都由主机控制。在沙盒中，很重要的一点就是我们不能通过略过类型规则来任意的破坏对象的状态。

内存管理
--------

C#依赖运行时来执行自动内存管理。CLR具有一个作为我们程序的一部分来执行的垃圾收集器，回收不再被引用的对象所占用的内存。这将程序由显式的释放对象所占用的内存中解放出来，减少了在类似C++的语言中所遇到的不正确的指针的问题。

C#并没有清除指针：仅是使得指针对于大多数程序任务来说并不是必需的。对于性能要求较高的任务，也可以使用指针，但是他们只可以在显式标识非安全的块中。

平台支持
--------

C#通常用于编写运行在Windows平台上的代码。尽管微软通过ECMA标准化了C#语言与CLR，但是在非Windows平台上致力于支持C#的资源问题要相对少得多。这意味着当跨平台是主要关注点时，Java语言将是明智的选择。尽管如此，C#可以在下列情况下用于编写跨平台代码：

-  C#代码也许可以运行在服务器上并且装载可以在任意平台上的DTHML。更确切的说是ASP.NET。
-  C#代码也许运行在除微软公共语言运行时以外的运行时上。最值得注意的例子就是Mono项目，其具有自己的C#编译器与运行时，运行在Linux，Solaris，Mac
   OS X以及Windows上。
-  C#代码可以运行在支持微软Silverlight的主机上。这是一种类似于Adobe的Flash
   Player的新技术。

C#与CLR的关系
-------------

C#依赖装备了例如自动内存管理与异常处理等特性的主机的运行时。C#的设计近似的映射到CLR的设计，他提供了这些运行时特性（尽管在技术上C#是独立于CLR的）。而且，C#类型系统近似映射到CLR类型系统（例如，两者都共享基本类型的相同定义）。

CLR与.NET框架
-------------

.NET框架由被称之为公共语言运行时（CLR）的运行时以及大量的库集合构成。库由核心库（本书所关注的）以及依赖核心库的应用库所构成。图1-1是这些库的一个可视化概览。

CLR是用于执行托管代码的运行时。C#是可以被编译为托管代码的托管语言之一。托管代码会以可执行文件或库的形式，同时带有类型信息或是元数，被打包为一个集合。

托管代码以中间语言或IL表示。当CLR装载一个集合后，他会将IL转换为机器的本地代码，例如x86。这个转换是通过CLR的JIT（Just-In-Time）编译器完成的。集合保存有几乎所有的原始的源语言结构，从而使其更容易检测，甚至动态生成代码。

CLR作为大量运行时服务的主机。这些服务的例子包括内存管理，库装载以及安全服务。

CLR是语言无关，允许开发人员使用多种语言构建程序。

.NET框架由用于编写Windows或基于Web的程序的库组成。第5章会提供.NET框架库的概述。

C# 4.0中的新特性
----------------

C# 4.0中的新特性有：

-  动态绑定
-  具有通用接口与委托的类型变化
-  可选参数
-  命名参数
-  COM交互性的改进

动态绑定是C#
4.0最大的变化。这一特性来自动态语言的启发，例如，Python，Ruby，JavaScript，以及Smalltalk。动态绑定将绑定－解析类型与成员的过程－由编译时推迟到运行时。尽管C#保留了静态类型语言的优点，但dynamic类型的变量以后绑定的方式解析。例如：

.. code:: csharp

    dynamic d = "hello";
    Console.WriteLine (d.ToUpper());  // HELLO
    Console.WriteLine (d.Foo());      // Compiles OK but gives runtime error

动态调用对象在复杂的反射代码的情况下十分有用。当与动态语言与COM组件交互时，动态绑定也十分有用。

可选参数允许函数指定默认参数值，从而调用者可以忽略参数。可选参数声明如下：

.. code:: csharp

    void Foo (int x = 23) { Console.WriteLine (x); }

而调用方式如下：

.. code:: csharp

    Foo(); // 23

命名参数允许函数调用者通过名字而不是位置来标识参数。例如，前面的方法可以以下面的方式调用：

.. code:: csharp

    Foo (x:5);

类型变化可以使得通用接口与通用委托将他们的类型参数作为变量。例如下面的代码：

.. code:: csharp

    IEnumerable<string> x = ...;
    IEnumerable<object> y = x;

COM交互性在C#
4.0中以三种方式得到了加强。首先，参数通过引用传递，而无需ref关键字。这个特性在与可选参数结合使用时特别有用。这意味着下面的打开一个Word文档的C#
3.0代码：

.. code:: csharp

    object o1 = "foo.doc";
    object o2 = Missing.Value;
    object o3 = Missing.Value;
    ...
    word.Open (ref o1, ref o2, ref o3...);

可以简化为

.. code:: csharp

    word.Open ("Foo.doc");

第二，包含COM交互操作类型的集合现在可以链接（linked）而不是引用(referenced）。链接的交互操作类型支持类型等价，避免了基本的类型操作集合的需要以及结束了版本与部署的麻烦。

第三，返回链接操作类型中的variant类型的函数被映射到dynamic而不是object，避免了转换的需要。

Chapter 2. C# Language Basics
=============================

在本章中，我们介绍C#语言的基础。

第一个C#程序
------------

下面的程序将12与30相乘并且将结果360输出到屏幕。双斜线表示本行的其余部分是注释：

.. code:: csharp

    using System;                     // Importing namespace
    class Test                        // Class declaration
    {
      static void Main()              //   Method declaration
      {
        int x = 12 * 30;              //     Statement 1
        Console.WriteLine (x);        //     Statement 2
      }                               //   End of method
    }                                 // End of class

这个程序的核心是两条语句。C#中的语句顺序执行。每一条语句以分号结束：

.. code:: csharp

      int x = 12 * 30;
      Console.WriteLine (x);

每一条语句计算表达式12\*30并将结果存储在一个名为x的局部变量中，他是一个整数类型。第二条语句调用Console类的WriteLine方法将变量x输出到屏幕上的一个文本窗口中。

方法以一系列的语句执行一个动作，称之为语句块－包含0或是多条语句的一对花括号。我们只定义了一个名为Main的方法：

.. code:: csharp

      static void Main()
      {
        ...
      }

编写调用低层函数的高层函数可以简化程序。我们可以使用乘以整数12的可重用方法来重构我们的程序：

.. code:: csharp

    using System;
    class Test
    {
      static void Main()
      {
        Console.WriteLine (FeetToInches (30));      // 360
        Console.WriteLine (FeetToInches (100));     // 1200
      }
      static int FeetToInches (int feet)
      {
        int inches = feet * 12;
        return inches;
      }
    }

方法可以通过指定参数由调用者接收输入数据，并通过指定返回类型将输出数据返回给调用者。我们定义了一个名为FeetToInches的方法，这个方法有一个用于输入的参数，以及一个用于输出的返回类型：

.. code:: csharp

    static int FeetToInches (int feet) {...}

字面量30与100是传递给FeetToInches方法的参数。我们例子中的Main方法具有空括号，因为他没有参数，并且是void的，因为他并没有向调用者返回任何值：

.. code:: csharp

    static void Main()

C#将名为Main的方法看作唯一的默认执行入口点。为了向执行环境返回一个值，Main方法可以返回一个整数（而不是void）。Main方法也可以选择接收一个字符串数组作为参数。例如：

.. code:: csharp

    static int Main (string[] args) {...}

方法是C#中多种函数类型中的一种。我们所用的另一种函数类型就是\*操作符，来执行相乘运算。同时还有构造函数，属性，事件，indexer与finalizer。

在我们的例子中，两个方法被组合在一个类中。类组合函数成员与数据成员来形成面向对象的构建块。Console类组合处理命令行输入/输出功能的成员，例如WriteLine。我们的Test类组合了两个方法－Main方法以及FeetToInches方法。类是一个类型（type）种类，我们将会在“类型基础”中探讨。

在程序的最外层，类型被组织为名字空间。using指令用来使得System名字对于我们的程序可用，从而使用Console类。我们可以在TestPrograms名字空间中定义我们所有的类，如下所示：

.. code:: csharp

    using System;
    namespace TestPrograms
    {
      class Test  {...}
      class Test2 {...}
    }

.NET框架被组织为嵌套的名字空间。例如，下面是包含用于处理文本类型的名字空间：

using System.Text;

这里的using指令是为了方便；我们也可以通过命名来引用类型，这就是以名字空间作为前缀的类型名，例如System.Text.StringBuilder。

编译
~~~~

C#编译器将所指定的.cs扩展名的文件集合的源码编译为一个集合。集合是打包与部署在.NET中的单位。集合可以是一个程序或是一个库。一个通常的控制器或是Windows程序具有一个Main方法，并且是一个.exe文件。库是一个.dll并且与没有入口点的.exe相等同。其目的就是为其他的程序或是其他库所调用。.NET框架是一个库的集合。

C#编译器的名字是csc.exe。我们可以使用IDE，例如Visual
Studio，来编译，或是由命令行手动调用csc。要手动编译，首先要将程序保存为一个文件，例如MyFirstProgram.cs，然后进入命令行并且执行csc命令：

csc MyFirstProgram.cs

这会生成一个名为MyFirstPrograme.exe的程序。

要生成一个库，执行下面的代码：

csc /target:library MyFirstProgram.cs

语法
----

C#语法基于C与C++语法。这本节中，我们将会使用下面的程序来描述C#的语法元素：

.. code:: csharp

    using System;
    class Test
    {
      static void Main()
      {
        int x = 12 * 30;
        Console.WriteLine (x);
      }
    }

标识符与关键字
~~~~~~~~~~~~~~

标识符是程序为他们的类，方法，变量等所选择的名字。下面是我们示例程序中的标识符，以出现顺序排列：

System Test Main x Console WriteLine

标记符必须是一个完整的单词，特别是以字母或是下划线开头的Unicode字符组成。C#标识符是大小写敏感的。一般的约定情况下，参数，局部变量，以及私有域应以驼峰方式书写（例如，myVariable），而所有其他的标识符应以Pascal方式书写（例如，MyMethod）。

关键字是编译器保留而我们不能用作标记符的名字。在我们这个示例程序中所使用的关键字如下：

.. code:: csharp

    using   class   static   void   int

下面是完整的C#关键字列表：

.. code:: csharp

    abstract    as       base        bool      break
    byte        case     catch       char      checked
    class       const    continue    decimal   default
    delegate    do       double      else      enum
    event       explicit extern      false     finally
    fixed       float    for         foreach   goto
    if          implicit in          int       interface
    internal    is       lock        long      namespace
    new         null     object      operator  out
    override    params   private     protected public
    readonly    ref      return      sbyte     sealed
    short       sizeof   stackalloc  static    string
    struct      switch   this        throw     true
    try         typeof   uint        ulong     unchecked
    unsafe      ushort   using       virtual   volatile
    void        while

**避免冲突**

如果我们确实希望使用与关键字相冲突的标记符，我们可以通过使用@前缀作为修改来实现。例如：

.. code:: csharp

    class class  {...}      // Illegal
    class @class {...}      // Legal

@符号并不是标签本身的一部分。所以@myVariable与myVariable相同。

**上下文相关关键字**

一些关键字是上下文相关的，这就意味着在不使用@符号的情况下，他们也可以用作标识符。他们是：

.. code:: csharp

    add    ascending   by       descending   dynamice   quals
    from   get         global   group        in         into
    join   let         on       orderby      partial    remove
    select set         value    var          where      yield

使用上下文关键字，在他们所用的环境中不能出现歧义。

字面量，标点与操作符
~~~~~~~~~~~~~~~~~~~~

字面量是静态嵌入到程序中的基本数据块。在我们的示例中所用的字面最是12与30。

标点用来帮助划分程序的结构。下面是在我们的示例程序中所用的标点符号：

； { }

分号用来结束一条语句。这就意味着语句可以跨越多行：

.. code:: csharp

    Console.WriteLine
      (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);

花括号用来将多条语句组织为一个语句块。

操作符转换并组合表达式。C#中的大多数运算符都是以符号来表示的，例如乘法操作符\*。我们将会在本章稍后的部分详细讨论运算符。下面是在我们的示例程序中所用的运算符：

. () \* =

句点表示某物的成员（或是数字字面量的小数点）。括号会在声明或是调用方法时使用；当方法不接受参数时则使用空括号。等号用于赋值（双等号==用于相等比较）。

注释
~~~~

C#提供了两种不同的源码文档风格：单行注释与多行注释。单行注释以双斜线开头并且直到本行的结束。例如：

.. code:: csharp

    int x = 3;   // Comment about assigning 3 to x

多行注释以/\*开头，以\*/结束。例如：

.. code:: csharp

    int x = 3;   /* This is a comment that
                    spans two lines */

注释中也许会嵌入XML文档标记。

类型基础
--------

类型（type）定义了一个值的蓝图。值（value）是通过变量或是常量所表示的存储位置。变量表示一个可以修改的值，而常量表示不可以修改的值。在我们的第一个程序中，我们创建一个名为x的局部变量：

.. code:: csharp

    static void Main()
    {
      int x = 12 * 30;
      Console.WriteLine (x);
    }

C#中的所有值都是一个特定类型的实例。值的含义以及变量可以具有的可能值的集合是由其类型来定义的。x的类型为int。

预定义的类型示例
~~~~~~~~~~~~~~~~

预定义的类型是由编译器所支持的类型。int类型是一个预定义类型，表示适合于32位内存的整数集合，由-2^31到2^31-1。我们可以使用int类型的实例来执行函数运算，例如算术运算：

.. code:: csharp

    int x = 12 * 30;

另一个预定义的C#类型是string。string类型表示一个字符序列，例如".NET"或是"\ `http://oreilly.com"。我们可以通过在字符串上调用函数来使用字符串，例如： <http://oreilly.com"。我们可以通过在字符串上调用函数来使用字符串，例如：>`__

.. code:: csharp

    string message = "Hello world";
    string upperMessage = message.ToUpper();
    Console.WriteLine (upperMessage);               // HELLO WORLD
    int x = 2010;
    message = message + x.ToString();
    Console.WriteLine (message);                    // Hello world2010

预定义的布尔类型只有两个值：true与false。bool类型通常用于基于if语句的条件分支执行。例如：

.. code:: csharp

    bool simpleVar = false;
    if (simpleVar)
      Console.WriteLine ("This will not print");
    int x = 5000;
    bool lessThanAMile = x < 5280;
    if (lessThanAMile)
      Console.WriteLine ("This will print");

自定义类型示例
~~~~~~~~~~~~~~

就如同我们可以由简单的函数构建复杂的函数，我们可以由基本类型构建复杂类型。在这个示例中，我们将会定义一个名为UnitConverter的自定义类型－用作无符号号数转换蓝图的类：

.. code:: csharp

    using System;
    public class UnitConverter
    {
      int ratio;                                                 // Field
      public UnitConverter (int unitRatio) {ratio = unitRatio; } // Constructor
      public int Convert   (int unit)    {return unit * ratio; } // Method
    }
    class Test
    {
      static void Main()
      {
        UnitConverter feetToInchesConverter = new UnitConverter (12);
        UnitConverter milesToFeetConverter  = new UnitConverter (5280);
        Console.WriteLine (feetToInchesConverter.Convert(30));    // 360
        Console.WriteLine (feetToInchesConverter.Convert(100));   // 1200
        Console.WriteLine (feetToInchesConverter.Convert(
                             milesToFeetConverter.Convert(1)));   // 63360
      }
    }

**类型的成员**

一个类型包含数据成员与函数成员。UnitConverter的数据成员是名为ratio的域。UnitConverter的函数成员是Convert方法与UnitConverter的构造函数。

**预定义类型与自定义类型的对称**

C#的一个优美之处就是预定义类型与自定义类型之间几乎没有区别。预定义的int类型作为整数的蓝图，他存储32位数据并且提供使用这个数据的函数成员，例如ToString。类似的，我们自定义的UnitConverter类型作为无符号整数转换的蓝图，他存储数据，ratio，并且提供使用该数据的函数成员。

**构造函数与初始化**

数据是通过实例化一个类型来创建的。预定义的类型可以简单的通过使用字面量来实例化。例如，下面的两行代码实例了两个整数（12与30），用来计算第三个实例x：

.. code:: csharp

    int x = 12 * 30;

当创建自定义类型的新实例时需要使用new操作符。我们可以使用下面的语句来创建并声明一个UnitConverter类型的实例：

.. code:: csharp

    UnitConverter feetToInchesConverter = new UnitConverter (12);

在new操作符实例化一个对象之后，对象的构造函数就会被调用来执行初始化。构造函数的定义类似于方法，所不同的是方法的名字与返回类型简化为类型的名字：

.. code:: csharp

    public class UnitConverter
    {
      ...
      public UnitConverter (int unitRatio) { ratio = unitRatio; }
      ...
    }

**实例与静态成员**

在类型的实例上所操作的数据成员与函数成员被称之为实例成员。UnitConverter的Convert方法以及int的ToString方法就是实例成员的示例。默认情况下，类型的成员是实例成员。

并不在类型实例上操作而是在类型本身上操作的数据成员与函数成员必须被标记为static。Test.Main与Console.WriteLine方法就是静态方法。实际上Console类是一个静态类，这就意味着其所有的成员都是静态的。我们实际上不会创建Console的实例，Console是在整个程序中共享的。

为了与静态成员进行对比，在下面的代码中实例域Name属于Panda的一个特定实例，而Population为所有的Panda实例所共有：

.. code:: csharp

    public class Panda
    {
      public string Name;             // Instance field
      public static int Population;   // Static field
      public Panda (string n)         // Constructor
      {
        Name = n;                     // Assign the instance field
        Population = Population + 1;  // Increment the static Population field
      }
    }

下面的代码创建了两个Panda实例，输出他们的名字，并且输出总的数量：

.. code:: csharp

    using System;
    class Program
    {
      static void Main()
      {
        Panda p1 = new Panda ("Pan Dee");
        Panda p2 = new Panda ("Pan Dah");
        Console.WriteLine (p1.Name);      // Pan Dee
        Console.WriteLine (p2.Name);      // Pan Dah
        Console.WriteLine (Panda.Population);   // 2
      }
    }

**public关键字**

public关键字向其他的类公开成员。在这个示例中，如果Panda中的Name域不是public的，Test类就不访问这个域。将一个成员标记为public就意味着类型之间的交互：“这些是我希望其他类型可以看到的－其他的所有内容都是我私有的实现细节。”在面向对象的术语中，我们说公有的成员封装了类的私有成员。

转换
~~~~

C#可以在兼容类型的实例之间进行转换。转换总是由一个已存在的值创建一个新的值。转换可以隐式的或是显示的：隐式的转换是自动发生的，而显示的转换需要转换操作。在下面的示例中，我们隐式的将int类型转换为long类型（容量是int类型的两倍），并且显示的将int转换为short类型（容量为int类型的一半）：

.. code:: csharp

    int x = 12345;       // int is a 32-bit integer
    long y = x;          // Implicit conversion to 64-bit integer
    short z = (short)x;  // Explicit conversion to 16-bit integer

只有当下列的两个条件为真时也会发生隐式转换：

-  编译器可以保证转换的成功
-  在转换为没有信息丢失

相应的，当下列的一个条件为真时需要进行显式转换：

-  编译器不能保证转换总会成功
-  在转换过程也许会发生信息的丢失

值类型与引用类型
~~~~~~~~~~~~~~~~

所有的C#类型都可以分为下列几类：

-  值类型
-  引用类型
-  泛型参数
-  指针类型

值类型由大多数的内建类型（特别是所有的数字类型，char类型与bool类型）以及自定义的struct与enum类型构成。

引用类型由所有的类，数组，委托以及接口类型构成。

值类型与引用类型之间的基本区别在于他们在内存中如何处理。

**值类型**

值类型变量或是常量的内容只简单的是一个值。例如，内建的值类型int的内容是一个32位的数据。

我们可以使用struct关键字来自定义值类型（如图2-1）：

.. code:: csharp

    public struct Point { public int X, Y; }

.. figure:: csharp_2_1.png
   :alt: csharp_2_1.png

   csharp\_2\_1.png
值类型实例的赋值总是会进行实例拷贝。例如：

.. code:: csharp

    static void Main()
    {
      Point p1 = new Point();
      p1.X = 7;
      Point p2 = p1;             // Assignment causes copy
      Console.WriteLine (p1.X);  // 7
      Console.WriteLine (p2.X);  // 7
      p1.X = 9;                  // Change p1.X
      Console.WriteLine (p1.X);  // 9
      Console.WriteLine (p2.X);  // 7
    }

图2-2显示了p1与p2具有独立的存储空间。

.. figure:: csharp_2_2.png
   :alt: csharp_2_2.png

   csharp\_2\_2.png
**引用类型**

引用类型要比值类型复杂得多，他由两部分构成：对象以及对象的引用。引用类型变量或常量的内容是到包含值的对象的引用。下面是使用class来重写我们前面的示例所形成Point类型（如图2-3所示）：

.. code:: csharp

    public class Point{ public int X, Y;}

.. figure:: csharp_2_3.png
   :alt: csharp_2_3.png

   csharp\_2\_3.png
赋值引用类型变量会拷贝引用，而不是对象实例。这可以使得多个变量指向同一个对象－并不是普通的值类型。如果我们重复前面的示例，但是现在Point是一个类，对X的操作会影响Y：

.. code:: csharp

    static void Main()
    {
      Point p1 = new Point();
      p1.X = 7;
      Point p2 = p1;             // Copies p1 reference
      Console.WriteLine (p1.X);  // 7
      Console.WriteLine (p2.X);  // 7
      p1.X = 9;                  // Change p1.X
      Console.WriteLine (p1.X);  // 9
      Console.WriteLine (p2.X);  // 9
    }

图2-4显示了p1与p2是指向同一个对象的两个引用。

.. figure:: csharp_2_4.png
   :alt: csharp_2_4.png

   csharp\_2\_4.png
**Null**

引用可以被赋值为字面量null，表明引用并没有指向任何对象：

.. code:: csharp

    class Point {...}
    ...
    Point p = null;
    Console.WriteLine (p == null);   // True
    // The following line generates a runtime error
    // (a NullReferenceException is thrown):
    Console.WriteLine (p.X);

相应的，值类型不能被赋值为null值：

.. code:: csharp

    struct Point {...}
    ...
    Point p = null;  // Compile-time error
    int x = null;    // Compile-time error

**存储花费**

值类型会精确的占用存储其数据域所需要内存。在下面的示例中，Point需要八个字节的内存：

.. code:: csharp

    struct Point
    {
      int x;  // 4 bytes
      int y;  // 4 bytes
    }

引用类型需要为引用与对象单独分配内存。对象需要的内存数量为其内部成员所需要内存数量加上额外的花费。确切的内存消耗是.NET运行时所固有的，但是最小的花费是八个字节，用于存储对象类型的键以及临时信息，例如多线程时的锁定状态以及标识其是否为GC所移动的标记。每一个对象的引用需要额外的4个或8个字节，这依据于.NET是运行在32位还是64位平台上。

预定义的类型分类
~~~~~~~~~~~~~~~~

C#中预定义的类型为：

值类型

-  数字

   -  带符号整数（sbyte，short，int，long）
   -  无符号整数（byte，ushort，uint，ulong）
   -  实数（float，double，decimal）

-  逻辑值（bool）
-  字符（char）

引用类型

-  字符串（string）
-  对象（object）

C#中预定义的类型是System名字空间中框架类型的别名。在下面的两条语句之间只有语法上的不同：

.. code:: csharp

    int i = 5;
    System.Int32 i = 5;

除了decimal的预定义值类型集合被称之为CLR中的基本类型。之所以被称之为基本类型是因为他是由编译代码的结构所直接支持的，并且这通常转换为底层处理器的直接支持。例如：

.. code:: csharp

                       // Underlying hexadecimal representation
    int i = 7;         // 0x7
    bool b = true;     // 0x1
    char c = 'A';      // 0x41
    float f = 0.5f;    // uses IEEE floating-point encoding

System.IntPtr与System.UIntPtr类型也是基本类型。

数值类型
--------

C#的预定义数值类型显示在表2-1中。

.. figure:: csharp_table_2_1.png
   :alt: csharp_table_2_1.png

   csharp\_table\_2\_1.png
在整数类型中，int与long是一等臣民，并且同时为C#与运行时所喜欢。其他的整数类型通常用于交互或是有足够的空间时所用。

在实数类型中，float与double通常被称之为浮点类型并且通常用于科学计算。decimal类型通常用于基于10的数学以及需要高精度的财务计算。

数值字面量
~~~~~~~~~~

整数字面量可以使用十进制或是十六进制形式；十六进制以0x前缀来表示。例如：

.. code:: csharp

    int x = 127;
    long y = 0x7F;

实数字面量可以使用十进制或是幂次形式来表示。例如：

.. code:: csharp

    double d = 1.5;
    double million = 1E06;

**数值字面量类型推测**

默认情况下，编译器会将数值字面量推测为double或是一个整数类型：

-  如果字面量包含一个十进制小数点或是幂次符号（E），则推测为double。
-  否则，字面量类型是列表中可以满足字面量值的第一个类型：int，unit，long与ulong。

例如：

.. code:: csharp

    Console.WriteLine (        1.0.GetType());  // Double  (double)
    Console.WriteLine (       1E06.GetType());  // Double  (double)
    Console.WriteLine (          1.GetType());  // Int32   (int)
    Console.WriteLine ( 0xF0000000.GetType());  // UInt32  (uint)

**数值后缀**

数值后缀显示的定义了字面量的类型。后缀可以为小写或是大写形式，可用的后缀如下表示：

.. figure:: csharp_2_suffix.png
   :alt: csharp_2_suffix.png

   csharp\_2\_suffix.png
后缀U与L并不是必须的，因为uint，long与ulong类型总是可以被推测出来或是由int隐式转换：

.. code:: csharp

    long i = 5;     // Implicit lossless conversion from int literal to long

D后缀在技术上是冗余的，因为所有带有十进制小数点的字面量都可以被推测为double。而我们总是可以向数值字面量添加小数点：

.. code:: csharp

    double x = 4.0;

F与M后缀是最经常用到的，并且应用在指定float与decimal字面量的情况。如果没有F后缀，下面的代码行不会通过编译，因为4.5可以被推测为double类型，而double并不能隐式的转换为float：

.. code:: csharp

    float f = 4.5F;

对于十进制字面量也是如此：

.. code:: csharp

    decimal d = ?1.23M;     // Will not compile without the M suffix.

我们将会在接下来的章节中详细描述数值转换的语义。

数值转换
~~~~~~~~

**整数到整数的转换**

当目标类型可以表示源类型的所有值时，整数转换是隐式进行的。否则，则需要使用显式转换。例如：

.. code:: csharp

    int x = 12345;       // int is a 32-bit integral
    long y = x;          // Implicit conversion to 64-bit integral
    short z = (short)x;  // Explicit conversion to 16-bit integral

**浮点数到浮点数的转换**

float可以隐式转换为double，因为double可以表示float的所有值。相反的转换必须显示进行。

**浮点到整数的转换**

所有的整数类型可以隐式的转换为所有的浮点类型：

.. code:: csharp

    int i = 1;
    float f = i;

相反的转换必须显示进行：

.. code:: csharp

    int i2 = (int)f;

隐式的将一个大的整数类型转换为浮点类型可以保留量级（magnitude），但也许会丢失精度。这是因为浮点类型要比整数类型具有更大的量级，但是也许会具有较小的精度。使用大数字重写我们的代码如下：

.. code:: csharp

    int i1 = 100000001;
    float f = i1;          // Magnitude preserved, precision lost
    int i2 = (int)f;       // 100000000

**十进制转换**

所有的整数类型都可以隐式的转换为十进制类型，因为十进制类型可以表示C#整数值的所有可能值。其他的数值类型转换为十进制类型或是由十进制类型转换为其他数值类型必须显示进行。

算术操作符
~~~~~~~~~~

C#为8位与16位整数以外的所有数值类型定义了算术操作符（+，-，\*，/，%）：

-  + 相加
-  - 相减
-  

   -  相乘

-  / 相除
-  % 取模

自加与自减操作符
~~~~~~~~~~~~~~~~

自加与自减操作符(++,
--)会将数值类型加1或减1。操作符可以在变量前也可以在变量后，这依据于我们是否希望表达式在计算之前更新变量。例如：

.. code:: csharp

    int x = 0;
    Console.WriteLine (x++);   // Outputs 0; x is now 1
    Console.WriteLine (++x);   // Outputs 2; x is now 2
    Console.WriteLine (--x);   // Outputs 1; x is now 1

特殊的整数操作
~~~~~~~~~~~~~~

**整数相除**

在整数类型上的相除操作总是会去掉余数。使用值为0的变量相除会生成运行时错误（DivideByZeroException）：

.. code:: csharp

    int a = 2 / 3;      // 0
    int b = 0;
    int c = 5 / b;      // throws DivisionByZeroException

使用字面量0相除会生成编译时错误。

**整数溢出**

运行时，整数类型上的算术操作会产生溢出。默认情况下，这会悄悄发生，不会抛出异常。尽管C#规范并没有指明溢出的结果，而CLR总会引起包装行为。例如，在最小可能的int值上减1会导致最大可能的int值：

.. code:: csharp

    int a = int.MinValue;
    a--;
    Console.WriteLine (a == int.MaxValue); // True

**整数算术溢出检测操作符**

checked操作符可以在整数表达式或是语句超出类型的算术限制时通知运行时产生OverflowException，而不是静默处理。checked操作可以影响使用++，--，+，-（双目与单目），\*，/以及在整数类型之间显示转换操作符的表达式。

checked操作可以用在表达式或是语句块的周围。例如：

.. code:: csharp

    int a = 1000000;
    int b = 1000000;int c = checked (a * b);      // Checks just the expression.
    checked                       // Checks all expressions
    {                             // in statement block.
       ...
       c = a * b;
       ...
    }

我们可以通过使用/checked+命令行开关编译来为程序中的所有表达式启用算术溢出检测。如果我们需要为特定的表达式或是语句禁止溢出检测，我们可以使用unchecked操作符。例如，下面的代码不会抛出异常－尽管他是使用/checked+来编译的：

.. code:: csharp

    int x = int.MaxValue;
    int y = unchecked (x + 1);
    unchecked { int z = x + 1; }

**为常量表达式进行溢出检测**

无论是否指定了/checked编译器开关，编译时的表达式计算总是会进行溢出检测－除非我们应用了unchecked操作符：

.. code:: csharp

    int x = int.MaxValue + 1;               // Compile-time error
    int y = unchecked (int.MaxValue + 1);   // No errors

**位操作符**

C#支持下列的位操作符：

.. figure:: csharp_2_bitwise.png
   :alt: csharp_2_bitwise.png

   csharp\_2\_bitwise.png
8位与16位整数
~~~~~~~~~~~~~

8位与16位的整数类型是byte，sbyte，short与ushort。这些类型缺少他们自己的算术操作符，所以C#会在需要时将他们转换为较大的类型。当尝试将转换后的结果赋值给一个较小的整数类型时会产生编译时错误：

.. code:: csharp

    short x = 1, y = 1;
    short z = x + y;          // Compile-time error

在上面的示例中，x与y被隐式转换为int，从而可以进行加法运算。这就意味着结果也是一个int，他不可以隐式的转换为short（因为这会导致数据的丢失）。要使其通过编译，我们必须使用显式转换：

.. code:: csharp

    short z = (short) (x + y);   // OK

特殊的float与double值
~~~~~~~~~~~~~~~~~~~~~

与整数类型不同，浮点类型有一些特殊的值。这些特殊的值是NaN（非数字），+无穷，-无穷与-0。float与double类具有一些用于NaN，+无穷，-无穷以及其他值（MaxValue，MinValue与Epsilon）的常量。例如：

.. code:: csharp

    Console.WriteLine (double.NegativeInfinity);   // -Infinity

double与float用于表示特殊值的常量如下所示：

.. figure:: csharp_2_floatdouble.png
   :alt: csharp_2_floatdouble.png

   csharp\_2\_floatdouble.png
将一个非零值除以零会导致一个无穷值。例如：

.. code:: csharp

    Console.WriteLine ( 1.0 /  0.0);                  //  Infinity
    Console.WriteLine (?1.0 /  0.0);                  // -Infinity
    Console.WriteLine ( 1.0 / ?0.0);                  // -Infinity
    Console.WriteLine (?1.0 / ?0.0);                  //  Infinity

零除以零或是无穷减无穷会导致一个NaN。例如：

.. code:: csharp

    Console.WriteLine ( 0.0 /  0.0);                  //  NaN
    Console.WriteLine ((1.0 /  0.0) ? (1.0 / 0.0));   //  NaN

当使用==时，NaN不等于任何值，也不等于NaN：

.. code:: csharp

    Console.WriteLine (0.0 / 0.0 == double.NaN);    // False

要测试一个值是否为NaN，我们必须使用float.IsNaN或是double.IsNaN方法：

.. code:: csharp

    Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True

然而，当使用object.Equals方法时，两个NaN的值是相等的：

.. code:: csharp

    Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));   // True

float与double遵循IEEE754格式类型规范，并为大多数的处理器所支持。

double与decimal
~~~~~~~~~~~~~~~

double对于科学计算十分有用（例如计算空间坐标）。decimail.
对于财务计算以及人造值而不是真实世界的测量结果十分有用。下面是他们之间的区别：

.. figure:: csharp_2_doubledecimal.png
   :alt: csharp_2_doubledecimal.png

   csharp\_2\_doubledecimal.png
实数近似错误
~~~~~~~~~~~~

float与double在内部表示基为2的数字。正是由于这个原因，只有可以表示为基为2的数字也会被精确的表示。实际上，这就意味着大多数带有分数的字面量（基为10）不会被精确的表示。例如：

.. code:: csharp

    float tenth = 0.1f;                       // Not quite 0.1
    float one   = 1f;
    Console.WriteLine (one - tenth * 10f);    // ?1.490116E-08

这就是为什么float与double不能用于财务计算的原因。相应的，decimal以10底，而可以精确的表示以10为底的数字（及其因子，以2和5为底）。因为实数字面量以10为底，decimal可以精确的表示例如0.1这样的数字。然而，double与decimal都不能精确表示底为10的循环小数：

.. code:: csharp

    decimal m = 1M / 6M;               // 0.1666666666666666666666666667M
    double  d = 1.0 / 6.0;             // 0.16666666666666666

这会导致近似错误：

.. code:: csharp

    decimal notQuiteWholeM = m+m+m+m+m+m;  // 1.0000000000000000000000000002M
    double  notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989

这会破坏相等与比较操作：

.. code:: csharp

    Console.WriteLine (notQuiteWholeM == 1M);   // False
    Console.WriteLine (notQuiteWholeD < 1.0);   // True

布尔类型与操作符
----------------

C#的bool类型（System.Boolean类型的别名）是可以使用字面量true与false赋值的逻辑值。

尽管一个布尔值只需要一位存储，但是运行时会使用一个字节的内存，因为这是运行时与处理器可以高效操作的最小内存块。为了避免数组情况下空间利用率低的问题，框架在System.Collections名字空间中提供了BitArray类，这是专门设计为每个布尔值使用1位存储。

布尔转换
~~~~~~~~

在布尔类型与数值类型之间不能进行转换。

相等与比较运算符
~~~~~~~~~~~~~~~~

==与!=用于测试类型的相等与不等，但总会返回一个bool值。值类型通常具有一个非常简单的相等的概念：

.. code:: csharp

    int x = 1;
    int y = 2;
    int z = 1;
    Console.WriteLine (x == y);         // False
    Console.WriteLine (x == z);         // True

对于引用类型，默认情况下相等是基于引用，而不是底层对象的实际值：

.. code:: csharp

    public class Dude
    {
      public string Name;
      public Dude (string n) { Name = n; }
    }
    ...
    Dude d1 = new Dude ("John");
    Dude d2 = new Dude ("John");
    Console.WriteLine (d1 == d2);       // False
    Dude d3 = d1;
    Console.WriteLine (d1 == d3);       // True

相等与比较操作符，==，!=，<，>，>=，<=可以适用于所有的数值类型，但是对于实数需要小心使用。比较操作符也可以应用在enum类型成员之上，通过比较其底层整数值实现。

条件操作符
~~~~~~~~~~

&&与!!操作测试与与或条件。他们经常与!操作符结合使用，后者表示非。在这个示例中，如果是雨天或是晴天，只要不是风天，UserUmbrella方法就会返回true：

.. code:: csharp

    static bool UseUmbrella (bool rainy, bool sunny, bool windy)
    {
      return !windy && (rainy || sunny);
    }

当可能时，&&与\|\|会进行短路计算。在前面的例子中，如果是风天，表达式（rainy\|\|sunny）就不会进行计算。短路的本质是使得表达式（如下面的表达式）运行而不会抛出NullReferenceException：

.. code:: csharp

    if (sb != null && sb.Length > 0) ...

&与\|操作也可以测试与与或条件：

.. code:: csharp

    return !windy & (rainy | sunny);

他们之间的区别就在于后者不会短路。正是由于这个原因，他们很少在条件运算符中使用。

三目条件运算符（简单的称之为条件运算符）的格式为q?a:b，也就是如果条件q为真则计算a，否则计算b。例如：

.. code:: csharp

    static int Max (int a, int b)
    {
      return (a > b) ? a : b;
    }

条件运算符在LINQ查询中特别有用。

字符串与字符
------------

C#的char类型（System.Char类型的别名）表示一个Unicode字符并且占用两个字节。char字面量在单引号中指定：

.. code:: csharp

    char c = 'A';       // Simple character

转义字符表示不可以表达或是按字面量解释的字符。一个转义序列由反斜线后跟一个具有特殊意义的字符表示。例如：

.. code:: csharp

    char newLine = '\n';
    char backSlash = '\\';

转义字符显示在表2-2中。

.. figure:: csharp_table_2_2.png
   :alt: csharp_table_2_2.png

   csharp\_table\_2\_2.png
\\u（或是\\x）转义序列可以让我们以其四位十六进制代码来指定任意的Unicode字符：

.. code:: csharp

    char copyrightSymbol = '\u00A9';
    char omegaSymbol     = '\u03A9';
    char newLine         = '\u000A';

字符转换
~~~~~~~~

由char到数值类型的隐式转换适用于可以适应于一个无符号short的数值类型。对于其他的数值类型，需要显式转换。

字符串类型
~~~~~~~~~~

C#的字符串类型（System.String类型的别名）表示一个不可修改的Unicode字符序列。字符串字面量在双引号中进行指定：

string a = "Heat";

可以应用char字面量的转义序列也可以应用于字符串之中：

string a = "Here's a tab:\\t";

这样的代价就是当我们需要反斜线的字面量时我们必须书写两次：

string a1 = "\\\\\\\\server\\\\fileshare\\\\helloworld.cs";

为了避免这一问题，C#允许逐字的字符串字面量。逐字的字符串字面量以@为前缀并且不支持转义序列。下面的逐字字符串与前面的字符串相同：

string a2 = @ "\\\\server\\fileshare\\helloworld.cs";

逐字的字符串字面量也可以跨越多行：

.. code:: csharp

    string escaped  = "First Line\r\nSecond Line";
    string verbatim = @"First Line
    Second Line";
    // Assuming your IDE uses CR-LF line separators:
    Console.WriteLine (escaped == verbatim);  // True

我们可以通过在逐字字符串字面量中书写两次来包含双引号字符：

string xml = @"";

**字符串联合**

+操作符可以联合两个字符串：

string s = "a" + "b";

右边的操作数也许是一个非字符串的值，在这种情况下会调用此值的ToString方法。例如：

.. code:: csharp

    string s = "a" + 5;  // a5

因为字符串是不可修改的，使用+操作符重复构建一个字符串效率非常低：一个更好的解决方案是使用System.Text.StringBuillder类型。

**字符串比较**

string并不支持用于比较的操作符。我们必须使用字符串的CompareTo方法。

数组
----

数组表示某个特定类型的确定数目的元素。数组中的元素总是存储在一个连续的内存块中，从而提供高效的访问。

数组使用元素类型之后的方括号来表示。例如：

char[] vowels = new char[5]; // Declare an array of 5 characters

方括号同时对数组进行索引，通过位置访问特定的元素：

.. code:: csharp

    vowels [0] = 'a';
    vowels [1] = 'e';
    vowels [2] = 'i';
    vowels [3] = 'o';
    vowels [4] = 'u';
    Console.WriteLine (vowels [1]);      // e

这会输出“e”，因为数组元素是由0开始的。我们可以使用for循环语句来遍历数组中的每一个元素。这个示例中的for循环整数i由0循环到4：

.. code:: csharp

    for (int i = 0; i < vowels.Length; i++)
      Console.Write (vowels [i]);            // aeiou

数组的Length属性返回数组中元素的数目。一旦数组被创建，其长度就不能正修改。System.Collection名字空间以及子空间中提供了更高级的数据结构，例如动态变化尺寸的数组与字典。

数组初始化表达式指定了数组中的每一个元素。例如：

char[] vowels = new char[] {'a','e','i','o','u'};

或是简单的：

char[] vowels = {'a','e','i','o','u'};

所有的数组都是由System.Array类继承来的，他为所有的数组提供了共同的服务。这些成员包括获取与设置数组元素的方法。

默认元素初始化
~~~~~~~~~~~~~~

创建数组总是使用默认值对数组元素进行预初始化。类型的默认值是内存位清零的结果。例如，考虑创建一个整数的数组。因为int是一个值类型，这会在一个连续的内存块中分配1000个整数。每个元素的默认值为0：

.. code:: csharp

    int[] a = new int[1000];
    Console.Write (a[123]);            // 0

**值类型与引用类型**

数组元素的类型值类型还是引用类型对程序有着较大的性能影响。当元素类型是值类型时，每一个元素值作为数组的一部分进行分配。例如：

.. code:: csharp

    public struct Point { public int X, Y; }
    ...
    Point[] a = new Point[1000];
    int x = a[500].X;                  // 0

如果Point是一个类，创建数组则会分配1000个空引用：

.. code:: csharp

    public class Point { public int X, Y; }
    ...
    Point[] a = new Point[1000];
    int x = a[500].X;                  // Runtime error, NullReferenceException

为了避免这种错误，我们必须在初始化数组之后显示初始化1000个Point：

.. code:: csharp

    Point[] a = new Point[1000];
    for (int i = 0; i < a.Length; i++) // Iterate i from 0 to 999
       a[i] = new Point();             // Set array element i with new point

数组本身总是一个引用类型对象，而无论元素类型是什么。例如，下面的语句是合法的：

.. code:: csharp

    int[] a = null;

多维数组
~~~~~~~~

多维数组有两种变化：矩形（rectangular）与锯齿（jagged）数组。矩形数组代表n维的内存块，而锯齿数组是数组的数组。

**矩形数组**

矩形数组的声明使用逗号来分隔每个维度。下面的语句声明了一个二维的矩形数组，其中的维度为3x3：

.. code:: csharp

    int [,] matrix = new int [3, 3];

数组的GetLength方法返回指定维度的长度（由0开始）：

.. code:: csharp

    for (int i = 0; i < matrix.GetLength(0); i++)
      for (int j = 0; j < matrix.GetLength(1); j++)
        matrix [i, j] = i * 3 + j;

矩形数组可以使用下面的语句进行初始化（这个示例中的每一个元素都被初始化为与前面示例相同的值）：

.. code:: csharp

    int[,] matrix = new int[,]
    {
      {0,1,2},
      {3,4,5},
      {6,7,8}
    };

    '''锯齿数组'''

    锯齿数组的声明使用连续的方括号来表示每一个维度。下面是一个声明二维锯齿数组的例子，其中最外层的维度为3：

    int [][] matrix = new int [3][];

    在这个声明中并没有指定内层的维度。与矩形数组不同，每一个内层数组可以是不确定的长度。每一个内层数组被隐式的初始化为null，而不是空数组。每一个内层数组必须手动创建：

    <syntaxhighlight lang="csharp">
    for (int i = 0; i < matrix.Length; i++)
    {
      matrix[i] = new int [3];                    // Create inner array
      for (int j = 0; j < matrix[i].Length; j++)
        matrix[i][j] = i * 3 + j;
    }

锯齿数组可以使用下面的语句进行初始化：

.. code:: csharp

    int[][] matrix = new int[][]
    {
      new int[] {0,1,2},
      new int[] {3,4,5},
      new int[] {6,7,8}
    };

简化数组初始化表达式
~~~~~~~~~~~~~~~~~~~~

有两种方法可以简化数组初始化表达式。第一种方法就是忽略new操作符与类型标识符：

.. code:: csharp

    char[] vowels = {'a','e','i','o','u'};
    int[,] rectangularMatrix =
    {
      {0,1,2},
      {3,4,5},
      {6,7,8}
    };
    int[][] jaggedMatrix =
    {
      new int[] {0,1,2},
      new int[] {3,4,5},
      new int[] {6,7,8}
    };

第二种方法就是使用var关键字，这会通知编译器隐式输入一个局部变量：

.. code:: csharp

    var i = 3;           // i is implicitly of type int
    var s = "sausage";   // s is implicitly of type string
    // Therefore:
    var rectMatrix = new int[,]    // rectMatrix is implicitly of type int[,]
    {
      {0,1,2},
      {3,4,5},
      {6,7,8}
    };
    var jaggedMat = new int[][]    // jaggedMat is implicitly of type int[][]
    {
      new int[] {0,1,2},
      new int[] {3,4,5},
      new int[] {6,7,8}
    };

隐式输入可以在一维数组上利用得更为深入。我们可以在new关键字后忽略类型标识符并且使得编译器推测数组类型：

var vowels = new[] {'a','e','i','o','u'}; // Compiler infers char[]

为了使得隐式数组输入正常工作，元素必须可以隐式的转换为单一类型：

var x = new[] {1,10000000000}; // all convertible to long

边界检测
~~~~~~~~

所有的数组索引都由运行时进行边界检测。如果我们使用不正确的索引，则会抛出IndexOutOfRangeException：

.. code:: csharp

    int[] arr = new int[3];
    arr[3] = 1;               // IndexOutOfRangeException thrown

与Java类似，边界检测对于类型安全与简化调试是必须的。

变量与参数
----------

变量表示具有可修改值的存储位置。变量可以是局部变量，参数（value,ref,out)，域（实例或静态）或是数组元素。

栈与堆
~~~~~~

栈与堆是变量与常量所在的位置。每一个都具有不同的生命周期语义。

**栈**

栈是用于存储局部变量与参数的内存块。随着进入函数与退出函数，栈会在逻辑上增长与缩小。考虑下面的方法：

.. code:: csharp

    static int Factorial (int x)
    {
      if (x == 0) return 1;
      return x * Factorial (x-1);
    }

这个方法是递归的，意味着他会调用其自身。每次进入方法时，就会在栈上分配一个新的int，而每次退出方法时，int就会被删除。

**堆**

堆是对象所在的内存块。当一个新对象被创建时，他会在堆上创建，并且返回对象的引用。在程序运行过程中，随着新对象被创建，堆开始被填满。运行时有一个垃圾收集器定时的由堆上删除对象，从而我们的计算机不会耗尽所有的内存。一旦没有引用指向对象，则对象就可以被删除。

在下面的示例中，我们创建一个通过变量ref1来引用的StringBuilder对象，并且输出其内容。然后StringBuilder对象立即就可以进行垃圾收集，因为并没有后续的操作使用这个对象。

然后，我们创建另一个通过变量ref2引用的StringBuilder对象，并且将这个引用拷贝到ref3。尽管在此以后ref2并没有被使用，ref3会使得相同的StringBuilder对象保持存活，从而保证该对象不会为垃圾收集器回收，直到我们完成ref3的使用。

.. code:: csharp

    using System;
    using System.Text;
    class Test
    {
      static void Main()
      {
        StringBuilder ref1 = new StringBuilder ("object1");
        Console.WriteLine (ref1);
        // The StringBuilder referenced by ref1 is now eligible for GC.
        StringBuilder ref2 = new StringBuilder ("object2");
        StringBuilder ref3 = ref2;
        // The StringBuilder referenced by ref2 is NOT yet eligible for GC.
        Console.WriteLine (ref3);                   // object2
      }
    }

值类型实例（以及对象引用）会在变量被声明时开始生命周期。如果实例被声明为对象内部的一个域，或是作为一个数组元素，该实例就会存活在堆上。

堆同时存储静态域与常量。与在堆上分配的对象不同（可以进行垃圾回收），他们程序退出之后一直存在。

明确赋值
~~~~~~~~

C#强制明确赋值策略。实践中，这就意味着在unsafe的环境以外，访问未初始化的内存是不可能的。确定赋值有三个含义：

-  局部变量在被读取之前必须赋值
-  当方法被调用时必须提供函数参数
-  所有其他的变量（例如域与数组元素）会被运行时自动初始化

例如，下面的代码会导致运行时错误：

.. code:: csharp

    static void Main()
    {
      int x;
      Console.WriteLine (x);        // Compile-time error
    }

域与数组元素会使用其类型的默认值进行初始化。下面的代码会输出0，因为数组被隐式的赋值为默认值：

.. code:: csharp

    static void Main()
    {
      int[] ints = new int[2];
      Console.WriteLine (ints[0]);    // 0
    }

下面的代码会输出0，因为域被隐式的赋值为默认值：

.. code:: csharp

    class Test
    {
      static int x;
      static void Main() { Console.WriteLine (x); }   // 0
    }

默认值
~~~~~~

所有的类型实例都有默认值。预定义类型的默认值是内存位清零的结果：

.. figure:: csharp_2_defaultvalues.png
   :alt: csharp_2_defaultvalues.png

   csharp\_2\_defaultvalues.png
我们可以使用default关键字获取任意类型的默认值：

decimal d = default (decimal);

自定义值类型中的默认值（例如struct）与自定义类型的域的默认值相同。

参数
~~~~

方法有一个参数序列。参数定义了必须提供给方法的参数集合。在这个示例中，Foo方法有一个名为p的int类型参数：

.. code:: csharp

    static void Foo (int p)
    {
      p = p + 1;                // Increment p by 1
      Console.WriteLine(p);     // Write p to screen
    }
    static void Main() { Foo (8); }

我们可以使用ref与out修饰符来控制如何传递参数：

.. figure:: csharp_2_parameter.png
   :alt: csharp_2_parameter.png

   csharp\_2\_parameter.png
**按值传递参数**

默认情况下，C#中的参数是按值传递的，这是到目前为止最普通的形式。这就意味着传递给方法会创建一个值的拷贝：

.. code:: csharp

    class Test
    {
      static void Foo (int p)
      {
        p = p + 1;                // Increment p by 1
        Console.WriteLine (p);    // Write p to screen
      }
      static void Main()
      {
        int x = 8;
        Foo (x);                  // Make a copy of x
        Console.WriteLine (x);    // x will still be 8
      }
    }

为p赋一个新值并不会改变x的内容，因为p与x位于不同的内存地址。

按值传递引用类型的参数会拷贝引用，而不是拷贝对象。在下面的示例中，Foo与Main实例会看到相同的StringBuilder对象，但是却有不同的引用。换句话说，sb与fooSB是指向相同StringBuilder
对象的不同引用：

.. code:: csharp

    class Test
    {
      static void Foo (StringBuilder fooSB)
      {
        fooSB.Append ("test");
        fooSB = null;
      }
      static void Main()
      {
        StringBuilder sb = new StringBuilder();
        Foo (sb);
        Console.WriteLine (sb.ToString());    // test
      }
    }

因为fooSB是一个引用的拷贝，将其设置为null并不使得sb变为null。（然而如果需要这样，fooSB会使用ref修饰符进行声明与调用，sb就会变为null。）

**ref修饰符**

要按引用传递，C#提供了ref参数修饰符。在下面的示例中，p与x与指向的内存地址：

.. code:: csharp

    clss Test
    {
      static void Foo (ref int p)
      {
        p = p + 1;               // Increment p by 1
        Console.WriteLine (p);   // Write p to screen
      }
      static void Main()
      {
        int x = 8;
        Foo (ref  x);            // Ask Foo to deal directly with x
        Console.WriteLine (x);   // x is now 9
      }
    }

现在为p赋一个新值就会改变x的内容。注意，当输出与调用方法如何需要ref修饰符。这就使得程序的目的清晰明白。

ref修饰可以用来实现交换方法：

.. code:: csharp

    class Test
    {
      static void Swap (ref string a, ref string b)
      {
        string temp = a;
        a = b;
        b = temp;
      }
      static void Main()
      {
        string x = "Penn";
        string y = "Teller";
        Swap (ref x, ref y);
        Console.WriteLine (x);   // Teller
        Console.WriteLine (y);   // Penn
      }
    }

**out修饰符**

out参数类似于ref参数，所不同的是：

-  在进入方法之前不需要被赋值
-  在离开方法之前必须被赋值

out修饰符经常用来由方法中返回多个值。例如：

.. code:: csharp

    class Test
    {
      static void Split (string name, out string firstNames,
                         out string lastName)
      {
         int i = name.LastIndexOf (' ');
         firstNames = name.Substring (0, i);
         lastName   = name.Substring (i + 1);
      }
      static void Main()
      {
        string a, b;
        Split ("Stevie Ray Vaughn", out a, out b);
        Console.WriteLine (a);                      // Stevie Ray
        Console.WriteLine (b);                      // Vaughn
      }
    }

类似于ref参数，out参数是按引用传递的。

**按引用传递的含义**

当我们按引用传递参数时，我们是将一个已存在的变量的存储位置进行重新命名，而不是创建一个新的存储位置。在下面的示例中，变量x与变量y表示相同的实例：

.. code:: csharp

    class Test
    {
      static int x;
      static void Main() { Foo (out x); }
      static void Foo (out int y)
      {
        Console.WriteLine (x);                // x is 0
        y = 1;                                // Mutate y
        Console.WriteLine (x);                // x is 1
      }
    }

**params修饰符**

params参数修饰符可以在方法的最后一个参数上指定，从而方法可以接受任意数目的特定类型的参数。参数类型必须声明为数组。例如：

.. code:: csharp

    class Test
    {
      static int Sum (params int[] ints)
      {
        int sum = 0;    
        for (int i = 0; i < ints.Length; i++)
          sum += ints[i];                       // Increase sum by ints[i]
        return sum;
      }
      static void Main()
      {
        int total = Sum (1, 2, 3, 4);
        Console.WriteLine (total);              // 10
      }
    }

我们也可以在普通的数组上使用params参数。Main中的第一行代码在语义上与下面的代码等同：

int total = Sum (new int[] { 1, 2, 3, 4 } );

**可选参数（C# 4.0）**

在C#
4.0中，方法，构造函数以及索引器都可以声明可选参数。如果一个参数在其声明中指定了默认值则是可选参数：

.. code:: csharp

    void Foo (int x = 23) { Console.WriteLine (x); }

当调用方法时可以忽略可选参数：

Foo(); // 23

默认参数23实际上被传递给可选参数x，编译器会在调用时将值23编译进代码。前面Foo方法的调用在语义上与下面的代码相同：

Foo (23);

因为编译器会简单的替换可选参数的默认值。

可选参数的默认值必须指定为常量表达式，或是值类型无需参数的构造函数。可选参数不能使用ref或是out标记。

在方法声明与方法调用中，强制参数必须出现在可选参数的前面（params参数例外，他总是出现在最后）。在下面的示例中，显式值1被传递给x，而默认值0被传递给y：

.. code:: csharp

    void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }
    void Test()
    {
      Foo(1);    // 1, 0
    }

要进行相反的操作（将默认值传递给x而显示值传递y），我们必须使用命名参数组合可选参数。

**命名参数（C# 4.0）**

除了通过位置标记参数以外，我们还可以通过名字标记参数。例如：

.. code:: csharp

    void Foo (int x, int y) { Console.WriteLine (x + ", " + y); }
    void Test()
    {
      Foo (x:1, y:2);  // 1, 2
    }

命名参数可以以任意顺序出现。下面对Foo的调用在语义上是相同的：

.. code:: csharp

    Foo (x:1, y:2);
    Foo (y:2, x:1);

我们可以混合使用命名参数与位置参数：

Foo (1, y:2);

然而有一个限制：位置参数必须出现在命名参数之前。所以我们不能使用下面的代码来调用Foo：

Foo (x:1, 2); // Compile-time error

命名参数在与可选参数组合时特别有用。例如，考虑下面的方法：

void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }

我们可以只提供d的值来进行调用，如下所示：

Bar (d:3);

当调用COM API时，这会十分有用。

**var－隐式输入的局部变量**

经常有这样的情况，我们在一步中声明并初始化变量。如果编译器能够由初始化表达中推测类型，我们就可以使用关键字var来代替类型声明。例如：

.. code:: csharp

    var x = "hello";
    var y = new System.Text.StringBuilder();
    var z = (float)Math.PI;

这与下面的代码等同：

.. code:: csharp

    string x = "hello";
    System.Text.StringBuilder y = new System.Text.StringBuilder();
    float z = (float)Math.PI;

由于这种直接的等价性，隐式输入的变量是静态输入的。例如，下面的代码会产生编译时错误：

.. code:: csharp

    var x = 5;
    x = "hello";    // Compile-time error; x is of type int

表达式与操作符
--------------

表达式本质上代表一个值。最简单的表达式类型是常量和变量。表达式可以使用操作符进行转换与组合。操作符使用一个或是多个输入操作数来输出一个新表达式。下面是一个常量表达式的例子：

12

我们可以使用\*操作组合两个操作数（字面量表达式12与30），如下所示：

12\*30

之所以可以构建复杂的表达式是因为操作数本身也可能是一个表达式，例如下面示例中的操作(12\*30)：

1 + (12 \* 30)

依据操作数的数目，C#中的操作符可以分为一目，又目或是三目操作符。双目操作符总是使用中缀形式，其中操作符位于两个操作数之间。

初级表达式
~~~~~~~~~~

初级表达式包括由语言基础所固有的操作符组成的表达式。如下面的例子：

Math.Log (1)

这个表达式由两个初级表达式组成。第一个表达式执行成员查找（.操作符），第二个表达式执行方法调用（使用()操作符）。

空表达式
~~~~~~~~

空表达式是没有值的表达式。如下面的示例：

Console.WriteLine (1)

因为空表达式没有值，因而不能用作操作数来构建更为复杂表达式：

1 + Console.WriteLine (1) // Compile-time error

赋值表达式
~~~~~~~~~~

赋值表达式使用=操作将另一个表达式的结果赋值给一个变量。例如：

x = x \* 5

赋值表达并不是空表达式。他实际带有赋值的值，因而可以组合到其他表达式中。如下面的示例：

y = 5 \* (x = 2)

这种风格的表达式可以用来初始化多个值：

a = b = c = d = 0

复合赋值表达式是使用另一个操作符组合赋值的简化语义。例如：

x \*= 2 // equivalent to x = x \* 2 x <<= 1 // equivalent to x = x << 1

运算符优先级与结合性
~~~~~~~~~~~~~~~~~~~~

当一个表达式包含多个操作符时，优先级与结合性确定了计算的顺序。具有高优先级的操作符要先于具有低优先级的操作而执行。如果操作符具有相同的优先级，操作符的结合性决定了计算的顺序。

**优先级**

下面的表达式：

1 + 2 \* 3

会按如下方式进行计算，因为\*比+的优先级要高：

1 + (2 \* 3)

**左结合操作符**

双目操作符（除了赋值，lambda，与null接合操作符）是左结合的；换句话说，他们会由左向右进行计算。例如，下面的表达式：

8 / 4 / 2

由于左结合性，会按如下方式进行计算：

( 8 / 4 ) / 2 // 1

我们可以插入括号来改变实际的计算顺序：

8 / ( 4 / 2 ) // 4

**右结合操作符**

赋值操作符，lambda，null接合与条件操作符是右结合操作符；换句话说，他们会由右到左进行计。右结合性会使得如下的多赋值表达式通过编译：

x = y = 3;

首先将3赋值给y，然后将表达式的结果赋值给x。

操作符表
~~~~~~~~

表2-3以优先级顺序列出了C#中的操作符。相同类别中的操作符具有相同的优先级。我们会在操作符重载中解释用户可重载的操作符。

|csharp\_table\_2\_3\_1.png| |csharp\_table\_2\_3\_2.png|
|csharp\_table\_2\_3\_3.png| |csharp\_table\_2\_3\_4.png|

语句
----

函数由以出现在的顺序执行的语句组成。一个语句块是出现在花括号之间的语句系列。

声明语句
~~~~~~~~

声明语句声明一个新的变量，可以选择使用表达式初始化变量。声明语句以分号结束。我们可以使用逗号分隔的列表声明多个相同类型的变量。例如：

.. code:: csharp

    string someWord = "rosebud";
    int someNumber = 42;
    bool rich = true, famous = false;

常量的声明类型于变量声明，所不同的是常量在声明之后不能修改，并且初始化必须出现在声明中：

.. code:: csharp

    const double c = 2.99792458E08;
    c += 10;                        // Compile-time Error

**局部变量**

局部变量与常量的作用域可以扩展到当前块。在当前块或是嵌套块中我们不能使用相同的名字声明另一个局部变量。例如：

.. code:: csharp

    static void Main()
    {
      int x;
      {
        int y;
        int x;            // Error - x already defined
      }
      {
        int y;            // OK - y not in scope
      }
      Console.Write (y);  // Error - y is out of scope
    }

表达式语句
~~~~~~~~~~

表达式语句是表达式，同时也是一个正确的语句。表达式语句必须修改状态或是调用可以修改状态的某些内容。修改状态本质上意味着修改变量。可能的表达语句如下：

-  赋值操作符（包括自增与自减表达式）
-  方法调用表达式
-  对象实例化表达式

如下面的一些示例：

.. code:: csharp

    // Declare variables with declaration statements:
    string s;
    int x, y;
    System.Text.StringBuilder sb;
    // Expression statements
    x = 1 + 2;                 // Assignment expression
    x++;                       // Increment expression
    y = Math.Max (x, 5);       // Assignment expression
    Console.WriteLine (y);     // Method call expression
    sb = new StringBuilder();  // Assignment expression
    new StringBuilder();       // Object instantiation expression

当我们调用一个构造函数或是返回值的方法时，我们并没有被强迫使用结果。然而，除非构造函数或是方法修改状态，否则语句是完全没用的：

.. code:: csharp

    new StringBuilder();     // Legal, but useless
    new string ('c', 3);     // Legal, but useless
    x.Equals (y);            // Legal, but useless

选择语句
~~~~~~~~

C#具有下列机制来条件的控制程序的执行流程：

-  选择语句（if，switch）
-  条件操作符（?:）
-  循环语句（while，do...while，for，foreach）

本节讨论最简单的两种结构：if-else语句与switch语句。

**if语句**

if语句会依据bool表达式是否为真来执行代码体。例如：

.. code:: csharp

    if (5 < 2 * 3)
    {
      Console.WriteLine ("true");       // True
    }

如果代码体是一条语句，我们可以忽略花括号：

.. code:: csharp

    if (5 < 2 * 3)
      Console.WriteLine ("true");       // True

**else子句**

if语句后可以跟else子句：

.. code:: csharp

    if (2 + 2 == 5)
      Console.WriteLine ("Does not compute");
    else
      Console.WriteLine ("False");        // False

在else子句中，我们可以嵌套其他的if语句：

.. code:: csharp

    if (2 + 2 == 5)
      Console.WriteLine ("Does not compute");
    else
      if (2 + 2 == 4)
        Console.WriteLine ("Computes");    // Computes

**使用花括号改变执行流程**

else子句总是与语句块中前一个if语句相匹配。例如：

.. code:: csharp

    if (true)
      if (false)
        Console.WriteLine();
      else
        Console.WriteLine ("executes");

这在语义上与下面的代码相同：

.. code:: csharp

    if (true)
    {
      if (false)
        Console.WriteLine();
      else
        Console.WriteLine ("executes");
    }

我们可以通过移动花括号来改变执行流程：

.. code:: csharp

    if (true)
    {
      if (false)
        Console.WriteLine();
    }
    else
      Console.WriteLine ("does not execute");

通过花括号，我们可以显示表述我们的意图。这可以改善嵌套if语句的可读性－尽管编译器并没有要求这样做。一个值得注意的例外就是下面的模式：

.. code:: csharp

    static void TellMeWhatICanDo (int age)
    {
      if (age >= 35)
        Console.WriteLine ("You can be president!");
      else if (age >= 21)
        Console.WriteLine ("You can drink!");
      else if (age >= 18)
        Console.WriteLine ("You can vote!");
      else
        Console.WriteLine ("You can wait!");
    }

在这里我们使用if与else语句来模拟其他语言中的"elsif"结构（C#的#elif预处理器指令）。Visual
Studio的自动格式化会识别这种模式并且保持缩进。尽管在语义来说每一个后跟else语句的if语句在功能上都是嵌套在else语句之中。

**switch语句**

switch语句可以使得我们依据变量所具有的可能值的选择来分支程序执行。switch语句也许会比多个if语句生成更为清晰的代码，因为switch语句要求表达式只计算一次。例如：

.. code:: csharp

    static void ShowCard(int cardNumber)
    {
      switch (cardNumber)
      {
        case 13:
          Console.WriteLine ("King");
          break;
        case 12:
          Console.WriteLine ("Queen");
          break;
        case 11:
          Console.WriteLine ("Jack");
          break;
        case ?1:                         // Joker is ?1
          goto case 12;                  // In this game joker counts as queen
        default:                         // Executes for any other cardNumber
          Console.WriteLine (cardNumber);
          break;
      }
    }

我们只能在静态计算的类型表达式上执行分支，这就将类型限制为内建的整数类型，string类型与enum类型。

在每一个case语句的结束处，我们可以使用某种类型的跳转语句表明接下来要执行到哪里。下面是一些选择：

-  break（跳转到switch语句的结束处）
-  goto case x（跳转到另一个case语句）
-  goto default（跳转到default子句）
-  其他的跳转语句－也就是return，throw，continue或是goto label

当多个值需要执行相同的代码时，我们可以顺序列出case：

.. code:: csharp

    switch (cardNumber)
    {
      case 13:
      case 12:
      case 11:
        Console.WriteLine ("Face card");
        break;
      default:
        Console.WriteLine ("Plain card");
        break;
    }

switch语句的这种特性是比多个if-else语句生成更清晰代码的关键。

**循环语句**

C#可以通过while，do-while，for与foreach语句重复执行语句序列。

**while与do-while循环**

当bool表达式为真时while循环会重复执行代码体。表达式会在循环体执行之前进行测试。例如：

.. code:: csharp

    int i = 0;
    while (i < 3)
    {
      Console.WriteLine (i);
      i++;
    }

输出结果为：

.. code:: csharp

    0
    1
    2

do-while循环在功能上与while循环的唯一不同在于前者在语句块执行之后测试表达式（保证表达式总是至少执行一次）。在这里将前面的表达式使用do-while循环重写：

.. code:: csharp

    int i = 0;
    do
    {
      Console.WriteLine (i);
      i++;
    }
    while (i < 3);

**for循环**

for循环类似于while循环，但是具有初始以及循环变量的特殊子句。for循环包含如下的三个子句：

.. code:: csharp

    for (initialization-clause; condition-clause; iteration-clause)
      statement-or-statement-block

初始化子句：在循环开始之前执行；用来初始化一个或是多个循环变量。

条件子句：bool表达式，当为真时，执行循环体。

循环子句：在语句块的每一次循环之后执行；通常用于更新循环变量。

例如下面的代码将会输出0到2：

.. code:: csharp

    for (int i = 0; i < 3; i++)
      Console.WriteLine (i);

下面的代码会输出前10个Fibonacci数字：

.. code:: csharp

    for (int i = 0, prevFib = 1, curFib = 1; i < 10; i++)
    {
      Console.WriteLine (prevFib);
      int newFib = prevFib + curFib;
      prevFib = curFib; curFib = newFib;
    }

for语句三个部分中的任何一个都可以被忽略。我们可以使用下面的代码实现无限循环：

.. code:: csharp

    for (;;)
      Console.WriteLine ("interrupt me");

**foreach循环**

foreach在可枚举的对象中的每一个元素上迭代。C#与.NET框架中的大多数类型表示可枚举的元素集合或列表。例如，数级与字符串都可以枚举。下面是一个字符串中的字符上枚举的例子：

.. code:: csharp

    foreach (char c in "beer")   // c is the iteration variable
      Console.WriteLine (c);

输出结果如下：

.. code:: csharp

    b
    e
    e
    r

我们会在第4章定义可枚举的对象。

跳转语句
~~~~~~~~

C#的跳转语句是break，continue，goto，return与throw。

**break语句**

break语句结束循环或是switch语句代码体的执行：

.. code:: csharp

    int x = 0;
    while (true)
    {
      if (x++ > 5)
        break ;      // break from the loop
    }
    // execution continues here after break
    ...

**continue语句**

continue语句会放弃循环中余下代码的执行并且开始下一次循环。下面的循环略过了偶数：

.. code:: csharp

    for (int i = 0; i < 10; i++)
    {
      if ((i % 2) == 0)       // If i is even,
        continue;             // continue with next iteration
      Console.Write (i + " ");
    }

输出结果为： 1 3 5 7 9

**goto语句**

goto语句将执行转移到代码块中的另一个标签。格式如下：

goto statement-label;

或者当使用switch语句时格式如下：

goto case case-constant;

标签语句只是代码块中的一个占位符，以一个冒号后缀表示。下面的代码由1循环到5，模仿for循环：

.. code:: csharp

    int i = 1;
    startLoop:
    if (i <= 5)
    {
      Console.Write (i + " ");
      i++;
      goto startLoop;
    }

输出结果为： 1 2 3 4 5

goto case-constant语句将执行转到switch块中另一个case。

**return语句**

return语句退出方法并且如果方法非空时必须返回一个方法返回类型的表达式：

.. code:: csharp

    static decimal AsPercentage (decimal d)
    {
      decimal p = d * 100m;
      return p;             // Return to the calling method with value
    }

return语句可以出现在方法中的任意位置。

**throw语句**

throw语句抛出一个异常表明发生了错误。

.. code:: csharp

    if (w == null)
      throw new ArgumentNullException (...);

其他语句
~~~~~~~~

lock语句是用于调用Monitor类的Enter与Exit方法的语法简写。

using语句提供了一种优雅的语法在finally块中在实现了IDisposable的对象上调用Dispose。

名字空间
--------

名字空间是一个域，其中的类型名字必须是唯一的。类型通常组织在层次名字空间中－同时为了避免名字冲突以及使得类型名字易于查找。例如，处理公钥的RAS类型使用下面的名字空间进行定义：

System.Security.Cryptography

名字空间构成了类型名字的一部分。下面代码调用RAS的Create方法：

.. code:: csharp

    System.Security.Cryptography.RSA rsa =
      System.Security.Cryptography.RSA.Create();

namespace关键字为块中的类型定义了一个名字空间。例如：

.. code:: csharp

    namespace Outer.Middle.Inner
    {
      class Class1 {}
      class Class2 {}
    }

名字空间中的句点表明了嵌套名字空间的层次。下面的代码在语义上与前面的示例完全相同：

.. code:: csharp

    namespace Outer
    {
      namespace Middle
      {
        namespace Inner
        {
          class Class1 {}
          class Class2 {}
        }
      }
    }

我们可以其完全修饰名来引用类型，其中包含由最外层到最内层全部的名字空间。例如，我们用
Outer.Middle.Inner.Class1来引用前面示例中的Class1。

没有定义在任何名字空间中的类型位于全局名字空间中。全局名字空间也包含最顶层的名字空间，例如我们示例中的Outer。

using指令
~~~~~~~~~

using指令引入一个名字空间。这是一种方便的方法，可以不需要完全的修饰名来引用类型。下面的示例在语义上与我们前面的示例相同：

.. code:: csharp

    using Outer.Middle.Inner;
    class Test
    {
      static void Main()
      {
        Class1 c;
      }
    }

名字空间中的规则
~~~~~~~~~~~~~~~~

**名字作用域**

在外层名字空间中声明的名字可以无限的在内层名字空间中使用。在下面的代码中，名字Middle与Class1被隐式引入到Inner中：

.. code:: csharp

    namespace Outer
    {
      namespace Middle
      {
        class Class1 {}
        namespace Inner
        {
          class Class2 : Class1  {}
        }
      }
    }

如果我们希望引用位于我们名字空间层次结构不同分支中的类型时，我们可以使用部分修饰名。在下面的示例中，我们将SalesReport构建在Common.ReportBase基础之上：

.. code:: csharp

    namespace MyTradingCompany
    {
      namespace Common
      {
        class ReportBase {}
      }
      namespace ManagementReporting
      {
        class SalesReport : Common.ReportBase  {}
      }
    }

**名字隐藏**

如果相同的名字同时出现在内层与外层名字空间中时，内层名字就会获得胜利。要引用外层名字空间中的类型，我们必须修饰其名字：

.. code:: csharp

    namespace Outer
    {
      class Foo { }
      namespace Inner
      {
        class Foo { }
        class Test
        {
          Foo f1;         // = Outer.Inner.Foo
          Outer.Foo f2;   // = Outer.Foo
        }
      }
    }

**重复的名字空间**

我们可以重复名字空间的声明，只要名字空间中的类型名字不冲突即可：

.. code:: csharp

    namespace Outer.Middle.Inner
    {
      class Class1 {}
    }
    namespace Outer.Middle.Inner
    {
      class Class2 {}
    }

我们还可以将上面的示例分为两个源，从而我们可以每一个类编译进入不同的程序集中。

源文件1：

.. code:: csharp

    namespace Outer.Middle.Inner
    {
      class Class1 {}
    }

源文件2：

.. code:: csharp

    namespace Outer.Middle.Inner
    {
      class Class2 {}
    }

**嵌入using指令**

我们可以名字空间中嵌入using指令。这就允许我们将using指令的作用域局限在名字空间声明中。在下面的示例中，Class1在一个名字空间中可见，但是在另一个名字空间中不可见：

.. code:: csharp

    namespace N1
    {
      class Class1 {}
    }
    namespace N2
    {
      using N1;
      class Class2 : Class1 {}
    }
    namespace N2
    {
      class Class3 : Class1 {}   // Compile-time error
    }

类型与名字空间的别名
~~~~~~~~~~~~~~~~~~~~

引入名字空间也许会导致类型名称冲突。我们可以仅引入我们所需要的特定类型，为每个类型指定一个别名，而不引全部的名字空间。例如：

.. code:: csharp

    using PropertyInfo2 = System.Reflection.PropertyInfo;
    class Program { PropertyInfo2 p; }

完整的名字空间也可以有别名，例如：

.. code:: csharp

    using R = System.Reflection;
    class Program { R.PropertyInfo p; }

高级名字空间特性
~~~~~~~~~~~~~~~~

**Extern**

extern别名可以使得我们的程序引用在相同的完全修饰名中的两个类型（例如，名字空间与类型名完全相同）。这种应用场景并不常见，只有当两个类型来自不同的程序集中时才会出现这种情况。考虑下面的示例：

库1：

.. code:: csharp

    // csc target:library /out:Widgets1.dll widgetsv1.cs
    namespace Widgets
    {
      public class Widget {}
    }

库2：

.. code:: csharp

    // csc target:library /out:Widgets2.dll widgetsv2.cs
    namespace Widgets
    {
      public class Widget {}
    }

程序：

.. code:: csharp

    // csc /r:Widgets1.dll /r:Widgets2.dll application.cs
    using Widgets;
     
    class Test
    {
      static void Main()
    // csc /r:Widgets1.dll /r:Widgets2.dll application.cs
    using Widgets;
     
      {
        Widget w = new Widget();
      }
    }

这段程序并不能通过编译，因为Widget是不明确的。extern别名可以解决我们程序中的这种不明确性：

.. code:: csharp

    // csc /r:W1=Widgets1.dll /r:W2=Widgets2.dll application.cs
    extern alias W1;
    extern alias W2;
    class Test
    {
      static void Main()
      {
        W1.Widgets.Widget w1 = new W1.Widgets.Widget();
        W2.Widgets.Widget w2 = new W2.Widgets.Widget();
      }
    }

**名字空间别名修饰符**

正如我们前面所提到的，内层名字空间中的名字会隐藏外层名字空间中的名字。然而，有时甚至是完全修饰的类型名字也不能解决这种冲突。考虑下面的示例：

.. code:: csharp

    namespace N
    {
      class A
      {
        public class B {}                    // Nested type
        static void Main() { new A.B(); }    // Instantiate class B
      }
    }
    namespace A
    {
      class B {}
    }

Main方法可以实例化嵌入类B，也可能是名字空间A中的类B。编译器总是为当前名字空间中的标识符指定更高的优先级；所以在这种情况下，实例化嵌入类B。

为了解决这样的冲突，名字空间可以相对于下面的情况进行修饰：

-  全局名字空间－所有名字空间的根（使用环境关键字global关键字进行标识）
-  extern别名集合

        标记可以用于名字空间的别名修饰。在这个示例中，我们使用全局名字空间来修饰：

.. code:: csharp

    namespace N
    {
      class A
      {
        static void Main()
        {
          System.Console.WriteLine (new A.B());
          System.Console.WriteLine (new global::A.B());
        }
        public class B {}
      }
    }
    namespace A
    {
      class B {}
    }

下面的代码是一个使用别名修饰的例子：

.. code:: csharp

    extern alias W1;
    extern alias W2;
    class Test
    {
      static void Main()
      {
        W1::Widgets.Widget w1 = new W1::Widgets.Widget();
        W2::Widgets.Widget w2 = new W2::Widgets.Widget();
      }
    }

Chapter 3. Creating Types in C#
===============================

在本章中，我们将会深入类型与类型成员。

类
--

类是最常见的引用类型。最简单的类声明如下：

.. code:: csharp

    class YourClassName
    {
    }

更为复杂的类可以包含下列内容：

前缀关键字class：属性与类修饰符。非嵌入类的修饰符可以为public, internal,
abstract, sealed, static, unsafe与partial

后跟YourClassName：泛型类型参数，基类与接口

在花括号内：
类成员（方法，属性，索引器，事件，域，构造函数，操作符函数，嵌入类型以及清理器）

本章将会探讨除属性，操作符函数以及unsafe关键字以外的所有结构。下面部分将会枚举每一个类成员。

域
~~

域是类或是结构的成员变量。例如：

.. code:: csharp

    class Octopus
    {
      string name;
      public int Age = 10;
    }

域可以使用下列修饰符：

静态修饰符：static 访问修饰符：public internal private protected
继承修饰符：new 不安全代码修饰符：unsafe 只读修饰符：readonly
线程修饰符：volatile

**只读修饰符**

readonly修饰符可以阻止域在构造之后被改。只读域只可以在其声明中或是类型的构造函数中进行赋值。

**域初始化**

域初始化是可选的。未初始化的域具有默认值（0,\\0, null,
false）。域初始化器在构造函数之前运行：

public int Age = 10;

**同时声明多个域**

为了方便，我们可以在一个逗号分隔的列表中声明相同类型的多个域。这是一种使得所有的域共享相同的属性与域修饰符的方便方法：

.. code:: csharp

    static readonly int legs = 8,
                        eyes = 1;

方法
~~~~

方法以语句序列的方式执行动作。方法可以通过指定参数由调用者接收输入数据，通过指定返回类型向调用者返回输出数据。方法可以指定void返回类型，表明他并没有向其调用者返回任何值。方法同时可以通过ref/out参数向其调用者返回数据。

方法的签名在类型中必须是唯一的。方法的签名由其名字与参数类型组成（但是不是的名字，也不是返回类型）。

方法可以使用下列修饰符：

静态修饰符：static 访问修饰符：public internal private protected
继承修饰符：new virtual abstract override sealed
非托管代码修饰符：unsafe extern

**重载方法**

类型可以重载方法（具有相同名字的多个方法），只要签名不同即可。例如，下面的方法可以在相同的类型中共存：

.. code:: csharp

    void Foo (int x);
    void Foo (double x);
    void Foo (int x, float y);
    void Foo (float x, int y);

然而下面的方法对不能在相同的类型中共存，因为返回类型与params修饰符并不是方法签名的一部分：

.. code:: csharp

    void  Foo (int x);
    float Foo (int x);           // Compile-time error
    void  Goo (int[] x);
    void  Goo (params int[] x);  // Compile-time error

**按值传递与按引用传递**

参数是按值传递还是按引用传递也是方法签名的一部分。例如，Foot(int)可以与Foo(ref
int)或是Foo(out int)共存。然而，Foo(ref int)与Foo(out int)不能共存：

.. code:: csharp

    void Foo (int x);
    void Foo (ref int x);      // OK so far
    void Foo (out int x);      // Compile-time error

实例构造器
~~~~~~~~~~

构造器在类或是结构上运行初始化代码。构造器的定义类似于方法，所不同的时方法名与返回类型限制为类型的名字：

.. code:: csharp

    public class Panda
    {
      string name;                   // Define field
      public Panda (string n)        // Define constructor
      {
        name = n;                    // Initialization code (set up field)
      }
    }
    ...
    Panda p = new Panda ("Petey");   // Call constructor

构造器可以使用下列的修饰符：

访问修饰符：public internal private protected 非托管代码修饰符：unsafe
extern

**重载构造器**

类或是结构可以重载构造器。为了避免代码重复，一个构造器可以使用this关键字来调用另一个构造器：

.. code:: csharp

    using System;
    public class Wine
    {
      public decimal Price;
      public int Year;
      public Wine (decimal price) { Price = price; }
      public Wine (decimal price, int year) : this (price) { Year = year; }
    }

当一个构造器调用另一个构造器时，被调用的构造器首先执行。

我们可以以如下方式将表达式传递给另一个构造器：

.. code:: csharp

    public Wine (decimal price, DateTime year) : this (price, year.Year) { }

表达式本身不能使用this引用，例如，来调用一个实例方法。然而，他可以调用静态方法。

**隐式无参数构造器**

对于类，如果我们没有定义任何构造器，C#编译器就会自动生成一个无参数的构造器。然而，一旦我们定义了至少一个构造器，无参数的构造器就不再自动生成。

对于结构，无参数构造器是结构所固有的；所以，我们不能定义自己的构造器。结构的隐式无参数构造器的角色就是使用默认值初始化所用域。

**构造器与域初始化顺序**

在前面，我们了解了在其声明中使用默认值初始化域：

.. code:: csharp

    class Player
    {
      int shields = 50;   // Initialized first
      int health = 100;   // Initialized second
    }

域初始化发生在构造器执行之前，并且以域声明的顺序进行初始化。

**非公开构造器**

构造器并不需要是公开的。具有非公开构造器的一个通常原因是通过静态方法调用来控制实例创建。静态方法可以用来由一个池中返回对象，而不是必须创建一个新对象，或依据输入参数返回不同的子类。这种模式的模板如下：

.. code:: csharp

    public class Class1
    {
      Class1() {}                             // Private constructor
      public static Class1 Create (...)
      {
        // Perform custom logic here to return an instance of Class1
        ...
      }
    }

对象初始化器
~~~~~~~~~~~~

为了简化对象的初始化，对象可访问的域或是属性可以在构造之后直接使用一条语句进行初始化。例如，考虑下面的类：

.. code:: csharp

    public class Bunny
    {
      public string Name;
      public bool LikesCarrots;
      public bool LikesHumans;
      public Bunny () {}
      public Bunny (string n) { Name = n; }
    }

使用对象初始化器，我们可以以下面的方式来实例化Bunny对象：

.. code:: csharp

    // Note parameterless constructors can omit empty parentheses
    Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
    Bunny b2 = new Bunny ("Bo")     { LikesCarrots=true, LikesHumans=false };

构造了b1与b2的代码与前面的代码：

.. code:: csharp

    Bunny temp1 = new Bunny();    // temp1 is a compiler-generated name
    temp1.Name = "Bo";
    temp1.LikesCarrots = true;
    temp1.LikesHumans = false;
    Bunny b1 = temp1;
    Bunny temp2 = new Bunny ("Bo");
    temp2.LikesCarrots = true;
    temp2.LikesHumans = false;
    Bunny b2 = temp2;

临时变量保证如果在初始化过程中抛出异常，我们就不会得到一个半初始化的对象。

对象初始化器是在C# 3.0中引入的。

this引用
~~~~~~~~

this引用指向实例本身。在下面的示例中，Marry方法使用this来调用partner的mate域：

.. code:: csharp

    public class Panda
    {
      public Panda Mate;
      public void Marry (Panda partner)
      {
        Mate = partner;
        partner.Mate = this;
      }
    }

this引用同时可以明确区分局部变量与域中的参数。例如：

.. code:: csharp

    public class Test
    {
      string name;
      public Test (string name) { this.name = name; }
    }

this引用只可以在类或结构的非静态方法中可用。

属性（Property）
~~~~~~~~~~~~~~~~

属性在外面看来类似域，但是内部他们包含逻辑，类似方法。例如，通过下面的代码我们并不能分辨CurrentPrice是域还是属性：

.. code:: csharp

    Stock msft = new Stock();
    msft.CurrentPrice = 30;
    msft.CurrentPrice -= 3;
    Console.WriteLine (msft.CurrentPrice);

属性声明类似域，但是添加了get/set块。下面显示了如何将CurrentPrice实现为属性：

.. code:: csharp

    public class Stock
    {
      decimal currentPrice;           // The private "backing" field
      public decimal CurrentPrice     // The public property
      {
        get { return currentPrice; } set { currentPrice = value; }
      }
    }

get与set表示属性访问器。当读取属性时运行get访问器。他必须返回一个属性类型的值。当属性被赋值时运行set访问器。他有一个隐式的名为value的参数，我们通常将其赋值私有域。

尽管属性以与域相同的方式进行访问，他们的不同在于前者为实现者提供了读取与设置值的完全控制。这种控制可以使得实现者选择在内部需要哪些表示，而不需要向属性的用户公开内部细节。在这个示例中，如果value超出了值的范围，则set方法就会抛出异常。

属性可以使用下面的修饰符：

静态修饰符：static 访问修饰符：public internal private protected
继承修饰符：new virtual abstract override sealed
非托管代码修饰符：unsafe extern

**只读与计算属性**

如果只指定了get访问器则属性是只读的，而如果只指定了set访问器则属性是只写的。只写的属性很少使用。

属性通常有一个后端域来存储底层数据。然而，属性也可以由其他数据计算得到。例如：

.. code:: csharp

    decimal currentPrice, sharesOwned;
    public decimal Worth
    {
      get { return currentPrice * sharesOwned; }
    }

**自动属性**

属性的最通常实现是简单的读取与写入作为属性的相同类型的私有域的getter与setter。自动属性声明指示编译器提供这种实现。我们可以以下面的方式重新声明第一个示例：

.. code:: csharp

    public class Stock
    {
      ...
      public decimal CurrentPrice { get; set; }
    }

编译器自动生成一个后端域，这是不可引用的编译器生成的名字。如果我们希望属性对于其他类型是只读的，set访问器可以被标识为private。自动属性是在C#
3.0中引入的。

**get与set可以访问性**

get与set访问器可以具有不同的访问级别。通常的用法是将public属性指定了internal或是在setter上指定private访问修饰符：

.. code:: csharp

    public class Foo
    {
      private decimal x;
      public decimal X
      {
        get         { return x;  }
        private set { x = Math.Round (value, 2); }
      }
    }

注意，我们使用更宽泛的访问级别（在这里为public）来声明了属性自身，然后向我们希望具有更少可访问性的访问器添加了修饰符。

**CLR属性实现**

C#属性访问器在内部被编译为名为get\_XXX与set\_XXX的方法：

.. code:: csharp

    public int  get_CurrentPrice {...}
    public void set_CurrentPrice (decimal value) {...}

简单的非虚属性访问器被JIT编译器编译为内联的，从而减少了访问属性与访问域之间的性能区别。内联是一种优化，其中方法调用被方法体所代替。

索引器
~~~~~~

索引器提供了一种自然的语法来访问类或是结构中的元素，该类或是结构封装了一个值的列表或是字典。索引器类似于属性，但是通过索引参数而不是属性名字来访问。string有一个索引器从而使得我们可以通过int索引来访问其中每一个char值：

.. code:: csharp

    string s = "hello";
    Console.WriteLine (s[0]); // 'h'
    Console.WriteLine (s[3]); // 'l'

当索引为整数类型时，使用索引器的语法类似于使用数组的语法。

**实现索引器**

要编写一个索引器，定义一个名为this的属性，在括号中指定参数。例如：

.. code:: csharp

    class Sentence
    {
      string[] words = "The quick brown fox".Split();
      public string this [int wordNum]      // indexer
      {
        get { return words [wordNum];  }
        set { words [wordNum] = value; }
      }
    }

下面是我们如何使用这个索引器：

.. code:: csharp

    Sentence s = new Sentence();
    Console.WriteLine (s[3]);       // fox
    s[3] = "kangaroo";
    Console.WriteLine (s[3]);       // kangaroo

一个类型可以定义多个索引器，每一个使用不同类型的参数。一个索引器也可以有多个参数：

.. code:: csharp

    public string this [int arg1, string arg2]
    {
      get { ... }  set { ... }
    }

如果我们忽略set访问器，则索引器就变为只读的了。

**CLR索引器实现**

索引器在内部编译为名为get\_Item与set\_Item的方法，如下所示：

.. code:: csharp

    public string get_Item (int wordNum) {...}
    public void set_Item (int wordNum, string value) {...}

编译器默认选择Item作为名字－实际上我们可以使用下面的属性通过修饰我们的索引器来进行修改：

[System.Runtime.CompilerServices.IndexerName ("Blah")]

常量
~~~~

常量是其值不能变化的域。常量是在编译时静态计算的，并且编译器在使用时在字面上替换该值，类似于C++中的宏。常量可以是任何的内建数值类型，bool，char，string或是枚举类型。

常量是通过const关键字来声明的，并且必须使用值进行初始化。例如：

.. code:: csharp

    public class Test
    {
      public const string Message = "Hello World";
    }

常量要比static
readonly域的限制严格得多－同时在我们可以使用的类型以及域初始化语义两个方面。常量不同于static
readonly域的另一个方面就是常量的计算发生在编译时。例如：

.. code:: csharp

    public static double Circumference (double radius)
    {
      return 2 * System.Math.PI * radius;
    }

被编译为：

.. code:: csharp

    public static double Circumference (double radius)
    {
      return 6.2831853071795862 * radius;
    }

将PI定义为常量是有道理的，因为他绝不会发生变化。相对应的，static
readonly域在每个不同的程序中会具有不同的值。

常量还可以声明为局限于方法。例如：

.. code:: csharp

    static void Main()
    {
      const double twoPI  = 2 * System.Math.PI;
      ...
    }

常量可以使用下列的修饰符：

访问修饰符：public internal private protected 继承修饰符：new

**静态构造器**

静态构造器对于每个类型只执行一次，而不是每个实例执行一次。一个类型只可以定义一个静态构造器，且他必须是无参数的，而且与类型具有相同的名字：

.. code:: csharp

    class Test
    {
      static Test() { Console.WriteLine ("Type Initialized"); }
    }

运行时会在类型使用之前自动调用静态构造器。两件事情可以触发调用：

-  实例化类型
-  访问类型中的静态成员

静态构造器只可以使用的修饰符为unsafe与extern。

静态构造器与域初始化顺序
~~~~~~~~~~~~~~~~~~~~~~~~

静态域初始化器在静态构造器调用之前运行。如果一个类型没有静态构造器，域初始化器会在类型被使用之前执行。（这就意味着静态构造器的存在也许会使得域初始化器在程序中的运行晚于他们本来的运行时机。）

静态域初始化器以域被声明的顺序进行初始化。下面的代码演示了这一点：X被初始化0而Y被初始化为3。

.. code:: csharp

    class Foo
    {
      public static int X = Y;    // 0
      public static int Y = 3;    // 3
    }

如果我们交换两个域初始化器的顺序，则两个域都被初始化为3。下面的程序会输出0，然后是3，因为实例化Foo的域初始化器在X被初始化为3之前执行：

.. code:: csharp

    class Program
    {
      static void Main() { Console.WriteLine (Foo.X); }   // 3
    }
    class Foo
    {
      public static Foo Instance = new Foo();
      public static int X = 3;
      Foo() { Console.WriteLine (X); }   // 0
    }

如果我们交换两行代码的顺序，则示例会输入3 3。

静态类
~~~~~~

一个类可以标记为static，表明该类由静态成员组成并且不能被继承。System.Console与System.Math类就是静态类的好例子。

清理器
~~~~~~

清理器是类方法，该方法会在垃圾收集器回未被引用的对象的内存之前执行。清理器的语法是以~符号为前缀的类名字：

.. code:: csharp

    class Class1
    {
      ~Class1()
      {
        ...
      }
    }

这实际上是C#重写Object的Finalize方法的语法，而编译器会将其扩展为下面的方法声明：

.. code:: csharp

    protected override void Finalize()
    {
      ...
      base.Finalize();
    }

我们将会在第12章详细讨论垃圾收集。

清理器允许使用下面的修饰符：

非托管代码修饰符：unsafe

部分（partial）类型与方法
~~~~~~~~~~~~~~~~~~~~~~~~~

部分类型允许类型的声明可以被分开－通常跨越多个文件。一个常见的应用场景就是由其他的源（例如XSD）自动生成的部分类以及使用额外的手动编写方法作为参数的类所形成的部分类。例如：

.. code:: csharp

    // PaymentFormGen.cs - auto-generated
    partial class PaymentForm { ... }
    // PaymentForm.cs - hand-authored
    partial class PaymentForm { ... }

每一部分必须有partial声明；下面的代码是非法的：

.. code:: csharp

    partial class PaymentForm {}
    class PaymentForm {}

部分不能有冲突的成员。例如，使用相同参数的构造器不可以重复。部分类型是由编译器进行整体解析的，这就意味着每一部分必须在编译时是可用的，而且必须位于相同的程序集中。

有两种方法来指定使用部分类的基类：

-  在每一部分指定相同的基类。例如：

 partial class PaymentForm : ModalForm {} partial class PaymentForm :
ModalForm {}

.. raw:: html

   </syntaxhighlight>

-  只在其中一部分指定基类。例如：

.. code:: csharp

    partial class PaymentForm : ModalForm {}
    partial class PaymentForm {}

另外，每部分都可以独立指定要实现的接口。

**部分方法**

一个部分类型可以包含部分方法。这可以使得一个自动生成的部分类型为手动编写的代码提供可以自定义的钩子。例如：

.. code:: csharp

    partial class PaymentForm    // In auto-generated file
    {
      ...
      partial void ValidatePayment (decimal amount);
    }
    partial class PaymentForm    // In hand-authored file
    {
      ...
      partial void ValidatePayment (decimal amount)
      {
        if (amount > 100)
          ...
      }
    }

一个部分方法由两部分组成：定义与实现。定义通常是由代码生成器所编写的，而实现通常是手动编写的。如果没有提供实现，部分方法的定义就会被编译去掉。这可以使得自动生成的代码自由提供关联，而不需要担心代码的膨胀。部分方法必须是void且隐式为private。

部分方法是在C# 3.0中引入的。

继承
----

一个类可以由其他类继承来扩展或是自定义原始类。由一个类继承可以使得我们重用那个类中的功能而不是从头开始构建。一个类只能由一个类继承，但是他本身可以由多个类继承，从而形成类的层次结构。在这个示例中，我们由定义一个名为Asset的类开始：

.. code:: csharp

    public class Asset
    {
      public string Name;
    }

接下来我们定义名为Stock与House的类，这两个类由Asset继承。他们拥有Asset类所有的所有成员，并加上他们定义的额外成员：

.. code:: csharp

    public class Stock : Asset   // inherits from Asset
    {
      public long SharesOwned;
    }

    public class House : Asset   // inherits from Asset
    {
      public decimal Mortgage;
    }

下面的代码显示了我们如何使用这些类：

.. code:: csharp

    Stock msft = new Stock { Name="MSFT",
                             SharesOwned=1000 };
    Console.WriteLine (msft.Name);         // MSFT
    Console.WriteLine (msft.SharesOwned);  // 1000
    House mansion = new House { Name="Mansion",
                                Mortgage=250000 };
    Console.WriteLine (mansion.Name);      // Mansion
    Console.WriteLine (mansion.Mortgage);  // 250000

子类，Stock与House，由基类Asset继承了Name属性。

多态
~~~~

引用是多态的。这就意味着类型x的一个变量可以指向继承x的对象。例如，考虑下面的方法：

.. code:: csharp

    public static void Display (Asset asset)
    {
      System.Console.WriteLine (asset.Name);
    }

这个可以方法可以同时显示Stock与House，因为他们都是Asset：

.. code:: csharp

    Stock msft    = new Stock ... ;
    House mansion = new House ... ;
    Display (msft);
    Display (mansion);

多态的运行是建立在子类（Stock与House）具有基类（Asset）所有特性的基础上的。然而，相反的情况并不正确。如果修改Display来接受House，我们就不能传递进Asset：

.. code:: csharp

    static void Main() { Display (new Asset()); }    // Compile-time error
    public static void Display (House house)         // Will not accept Asset
    {
      System.Console.WriteLine (house.Mortgage);
    }

转换与引用转换
~~~~~~~~~~~~~~

一个对象引用可以：

-  隐式向上转换为基类引用
-  显式向下转换为子类引用

兼容引用类型之间的向上转换与向下转换执行引用转换：创建一个指向相同对象的新引用。向上转换总是会成功；只有当对象是合适的类型时向下转换才会成功。

**向上转换**

向上转换操作由子类引用创建一个基类引用。例如：

.. code:: csharp

    Stock msft = new Stock();
    Asset a = msft;              // Upcast

在向上转换之后，变量a仍然与变量msft指向相同的Stock对象。引用所指向的对象本身并没有被修改或是转换：

.. code:: csharp

    Console.WriteLine (a == msft);        // True

尽管a与msft指向相同的对象，但是a在对象上只有有限的视野：

.. code:: csharp

    Console.WriteLine (a.Name);           // OK
    Console.WriteLine (a.SharesOwned);    // Error: SharesOwned undefined

最后一行代码会生成编译时错误，因为变量a是Asset类型的，尽管他指向Stock类型的对象。要获得其SharedOwned域，我们将Asset向下转换为Stock。

**向下转换**

向下转换操作由基类引用创建一个子类引用。例如：

.. code:: csharp

    Stock msft = new Stock();
    Asset a = msft;                      // Upcast
    Stock s = (Stock)a;                  // Downcast
    Console.WriteLine (s.SharesOwned);   // <No error>
    Console.WriteLine (s == a);          // True
    Console.WriteLine (s == msft);       // True

与向上转换类似，转换只影响引用，而不是底层的对象。向下转换需要显式进行，因为在运行向下转换很可能会失败：

.. code:: csharp

    House h = new House();
    Asset a = h;               // Upcast always succeeds
    Stock s = (Stock)a;        // Downcast fails: a is not a Stock

如果向下转换失败，则会抛出InvalidCastException。

**as操作符**

as操作符执行向下转换，如果向下转换失败，则计算为null（而不是抛出异常）：

.. code:: csharp

    Asset a = new Asset();
    Stock s = a as Stock;       // s is null; no exception thrown

当我们在接下来要测试结果是否为null，as操作符就会十分有用：

.. code:: csharp

    if (s != null) Console.WriteLine (s.SharesOwned);

as操作符不能执行自定义转换，并且他不能执行数值转换：

long x = 3 as long; // Compile-time error

**is操作**

is操作符测试引用转换是否成功；换句话说，测试一个对象是否由一个特定的类派生（或是实现接口）。他通常用于在进行向下转换之前测试：

.. code:: csharp

    if (a is Stock)
      Console.WriteLine (((Stock)a).SharesOwned);

is操作符并没有考虑处碹义或是数值转换，但是他却考虑了拆箱转换。

虚函数成员
~~~~~~~~~~

标记为virtual的函数可以由希望提供特定实现的子类来重写。方法，属性，索引器与事件都可以声明为virtual：

.. code:: csharp

    public class Asset
    {
      public string Name;
      public virtual decimal Liability { get { return 0; } }
    }

子类通过应用override修饰符来重写虚方法：

.. code:: csharp

    public class Stock : Asset
    {
      public long SharesOwned;
    }
    public class House : Asset
    {
      public decimal Mortgage;
      public override decimal Liability { get { return Mortgage; } }
    }

默认情况下，Asset的Liability为0。Stock并不需要特例化此行为。然而，House特例化Liability属性来返回Mortgage的值：

.. code:: csharp

    House mansion = new House { Name="McMansion", Mortgage=250000 };
    Console.WriteLine (mansion.Liability);      // 250000

签名，返回类型，以及虚方法与重写方法的可访问性必须相同。重写方法可以通过base关键字来调用其基类实现。

抽象类与抽象成员
~~~~~~~~~~~~~~~~

声明为abstract的类不能被实例化。相反，只有其子类可以被实例铧。

抽象类可以来定义抽象成员。抽象成员类似于虚成员，所不同的是他们并不提供默认实现。该实现必须由子类来提供，除非子类也被声明为抽象的：

.. code:: csharp

    public abstract class Asset
    {
      // Note empty implementation
      public abstract decimal NetValue { get; }
    }
    public class Stock : Asset
    {
      public long SharesOwned;
      public decimal CurrentPrice;
      // Override like a virtual method.
      public override decimal NetValue
      {
        get { return CurrentPrice * SharesOwned; }
      }
    }

隐藏继承成员
~~~~~~~~~~~~

基类和子类可以定义相同的成员。例如：

.. code:: csharp

    public class A      { public int Counter = 1; }
    public class B : A  { public int Counter = 2; }

类B中的Counter域被称之为隐藏了类A中的Counter域。通常，这是当一个成员被添加到基类中然后一个相同的成员被添加到子类时偶然发生的。由于这个原因，编译器会生成警告，然后使用下面的方式解决不确定性：

-  到A的引用（在编译时）绑定到A.Counter
-  到B的引用（在编译时）绑定到B.Counter

有时我们希望故意的隐藏成员，在这种情况下我们可以在子类的成员上应用new修饰符。new修饰的作用就是本来会产生的编译器警告：

.. code:: csharp

    public class A     { public     int Counter = 1; }
    public class B : A { public new int Counter = 2; }

new修饰符将我们的意图告知编译器—以及其他程序－重复的成员并不是偶然产生的。

**new与virtual**

考虑下面的类层次结构：

.. code:: csharp

    public class BaseClass
    {
      public virtual void Foo()  { Console.WriteLine ("BaseClass.Foo"); }
    }
    public class Overrider : BaseClass
    {
      public override void Foo() { Console.WriteLine ("Overrider.Foo"); }
    }
    public class Hider : BaseClass
    {
      public new void Foo()      { Console.WriteLine ("Hider.Foo"); }
    }

Overrider与Hider行为之间的区别在下面的代码中进行演示：

.. code:: csharp

    Overrider over = new Overrider();
    BaseClass b1 = over;
    over.Foo();                         // Overrider.Foo
    b1.Foo();                           // Overrider.Foo
    Hider h = new Hider();
    BaseClass b2 = h;
    h.Foo();                           // Hider.Foo
    b2.Foo();                          // BaseClass.Foo

密封函数与方法
~~~~~~~~~~~~~~

一个重写的函数成员可以使用sealed关键字密封其实现从而防止被子类进行重写。在我们前面虚函数成员的示例中，我们可以密封Liability的House实现，从而防止由House派生的类重写Liability，如下所示：

public sealed override decimal Liability { get { return Mortgage; } }

我们还可以通过在类本身上应用sealed修饰符来密封类本身，隐式密封所有的虚函数。密封一个类要比密封一个成员函数更为常见。

base关键字
~~~~~~~~~~

base关键字类似于this关键字。他有两个目的：

-  由子类访问重写的函数成员
-  调用基类的构造器

在这个示例中，House使用base关键字来访问Liability的Asset实现：

.. code:: csharp

    public class House : Asset
    {
      ...
      public override decimal Liability
      {
        get { return base.Liability + Mortgage; }
      }
    }

通过base关键字，我们可以非虚拟的方式访问Asset的Liability属性。这就意味着我们总是可以访问这个属性的Asset版本，而无论实例的实际运行时类型。

相同的方法同样适用于Liability被隐藏而是被重写。（我们也可以通过在调用这个函数之前转换为基类来访问隐藏成员。）

构造器与继承
~~~~~~~~~~~~

子类必须声明其自己的构造器。例如，如果我们以下面的方式定义Subclass：

.. code:: csharp

    public class Baseclass
    {
      public int X;
      public Baseclass () { }
      public Baseclass (int x) { this.X = x; }
    }
    public class Subclass : Baseclass { }

则下面的代码是非法的：

Subclass s = new Subclass (123);

子类必须重新定义他希望公开的构造器。然而，如果这样做，他就可以通过base关键字来调用基类的构造器：

.. code:: csharp

    public class Subclass : Baseclass
    {
      public Subclass (int x) : base (x) { }
    }

base关键字的作用类似于this关键字，所不同的是他调用基类中的构造器。

基类的构造器总是首先执行；这可以保证基类的初始化在特例的初始化之前。

**隐式调用基类的无参数构造器**

如果子类中的构造器忽略了base关键，则基类类型的无参数构造器就会隐式调用：

.. code:: csharp

    public class BaseClass
    {
      public int X;
      public BaseClass() { X = 1; }
    }
    public class Subclass : BaseClass
    {
      public Subclass() { Console.WriteLine (X); }  // 1
    }

如果基类没有无参数的构造器，则子类就会被强制在其构造器中使用base关键字。

**构造器与域初始化顺序**

当一个对象被实例化时，初始化以下面的顺序发生：

#. 由子类到基类：

-  

   -  域初始化

#. 由基类到子类：

-  

   -  执行构造器体

如下面的代码所示：

.. code:: csharp

    public class B
    {
      int x = 0;         // Executes 3rd
      public B (int x)
      {
        ...              // Executes 4th
      }
    }
    public class D : B
    {
      int y = 0;         // Executes 1st
      public D (int x)
        : base (x + 1)   // Executes 2nd
      {
         ...             // Executes 5th
      }
    }

重载与解析
~~~~~~~~~~

继承对于方法重载有一个有趣的影响。考虑下面的两个重载：

.. code:: csharp

    static void Foo (Asset a) { }
    static void Foo (House h) { }

当重载被调用时，最特殊的类型具有高优先级：

.. code:: csharp

    House h = new House (...);
    Foo(h);                      // Calls Foo(House)

要调用的特定重载是静态确定的（在编译时）而不是运行时确定的。下面的代码调用Foo(Asset)，尽管其运行时类型为House：

.. code:: csharp

    Asset a = new House (...);
    Foo(a);                      // Calls Foo(Asset)

object类型
----------

object（System.Object）是所有类型的最终基类。任意的类型都可以向上转换为object。

为了演示这是如何有用，考虑通常目的的栈。栈是基于LIFO原则的数据结构。栈有两个操作：push一个对象到栈，以及由栈中pop一个对象。下面是一个可以存储10个对象的简单实现：

.. code:: csharp

    public class Stack
    {
      int position;
      object[] data = new object[10];
      public void Push (object obj)   { data[position++] = obj;  }
      public object Pop()             { return data[--position]; }
    }

因为Stack使用object类型，我们可以向Stack或是由Stack中Push或Pop任意的类型实例：

.. code:: csharp

    Stack stack = new Stack();
    stack.Push ("sausage");
    string s = (string) stack.Pop();   // Downcast, so explicit cast is needed
    Console.WriteLine (s);             // sausage

object是一个引用类型。尽管这样，值类型，例如int，可以转换为object或是由object转换，因而也可以添加到我们的栈中。C#的这种特性被称为类型一致，如下所示：

.. code:: csharp

    stack.Push (3);
    int three = (int) stack.Pop();

当我们在值类型与object之间进行转换时，CLR必须执行一些特殊的工作来连接值类型与引用类型之间语义上的区别。这个过程就称之为装箱与拆箱。

装箱与拆箱
~~~~~~~~~~

装箱就是将值类型的实例转换为引用类型实例的。引用类型可以是object类或是一个接口。在这个示例中，我们将int装箱为一个对象：

.. code:: csharp

    int x = 9;
    object obj = x;           // Box the int

拆箱是相反的操作，将对象转换为原始的值类型：

int y = (int)obj; // Unbox the int

拆箱需要显示转换。运行时会检测所表述的值类型是否与实际的对象类型相匹配，如果检测失败则会抛出InvalidCastException。例如，下面的代码会抛出异常，因为long与int不匹配：

.. code:: csharp

    object obj = 9;           // 9 is inferred to be of type int
    long x = (long) obj;      // InvalidCastException

然而下面的代码可以成功：

.. code:: csharp

    object obj = 9;
    long x = (int) obj;

下面的代码也可以：

.. code:: csharp

    object obj = 3.5;              // 3.5 is inferred to be of type double
    int x = (int) (double) obj;    // x is now 3

在最后一个示例中，(double)执行拆箱，而(int)执行数值转换。

**装箱与拆箱的拷贝语义**

装箱将值类型的实例拷贝到新对象中，而拆箱则是将对象的内容拷贝回值类型实例中。在下面的示例中，修改i的值并不会改变之前的装箱拷贝：

.. code:: csharp

    int i = 3;
    object boxed = i;
    i = 5;
    Console.WriteLine (boxed);    // 3

静态与运行时类型检测
~~~~~~~~~~~~~~~~~~~~

C#同时静态（在编译时）与运行时检测类型。

静态类型检测使得编译器无需要运行来验证我们程序的正确性。下面的代码会失败，因为编译会强制静态类型：

int x = "5";

当我们通过引用转换或是拆箱进行向下转换时，由CLR进行运行类型检测。例如：

.. code:: csharp

    object y = "5";
    int z = (int) y;          // Runtime error, downcast failed

之所以可以进行运行时类型检测是因为堆上的每一个对象在内部都存储一个类型标记。这个标记可以通过调用object的GetType方法来获取。

GetType方法与typeof操作符
~~~~~~~~~~~~~~~~~~~~~~~~~

C#中的所有类型在运行时都是通过System.Type来表示的。有两种基本方法来获取System.Type对象：

-  在实例上调用GetType
-  在类型名字上使用typeof操作符

GetType是在运行时评估的；typeof是在编译时静态评估的。

System.Type具有的属性包括类型的名字，程序集，基类型等。例如：

.. code:: csharp

    using System;
    public class Point { public int X, Y; }
    class Test
    {
      static void Main()
      {
        Point p = new Point();
        Console.WriteLine (p.GetType().Name);             // Point
        Console.WriteLine (typeof (Point).Name);          // Point
        Console.WriteLine (p.GetType() == typeof(Point)); // True
        Console.WriteLine (p.X.GetType().Name);           // Int32
        Console.WriteLine (p.Y.GetType().FullName);       // System.Int32
      }
    }

System.Type同时包含一些扮演运行时反映模型入口的方法，我们会在第17章中描述。

ToString方法
~~~~~~~~~~~~

ToString方法返回类型实例的默认文本表示。这个方法会为所有的内建类型所重写。下面是使用int类型的ToString方法的示例：

.. code:: csharp

    int x = 1;
    string s = x.ToString();     // s is "1"

我们可以在自定义类型上重写ToString方法，如下所示：

.. code:: csharp

    public class Panda
    {
      public string Name;
      public override string ToString() { return Name; }
    }
    ...
    Panda p = new Panda { Name = "Petey" };
    Console.WriteLine (p);   // Petey

当我们直接在值类型上调用重写的object成员，例如ToString方法时，不会产生装箱操作。只有当我们转换时才会产生装箱操作：

.. code:: csharp

    int x = 1;
    string s1 = x.ToString();    // Calling on nonboxed value
    object box = x;
    string s2 = box.ToString();  // Calling on boxed value

object成员列表
~~~~~~~~~~~~~~

下面是object的所有成员：

.. code:: csharp

    public class Object
    {
      public Object();
      public extern Type GetType();
      public virtual bool Equals (object obj);
      public static bool Equals  (object objA, object objB);
      public static bool ReferenceEquals (object objA, object objB);
      public virtual int GetHashCode();
      public virtual string ToString();
      protected override void Finalize();
      protected extern object MemberwiseClone();
    }

我们将会在第6章描述Equals，ReferenceEquals与GetHashCode方法。

结构
----

struct类似于class，他们之间的关键区别如下：

-  结构是一个值类型，而类是一个引用类型
-  结构不支持继承（并不是隐式由object继承，或是更确切的说是，是由System.ValueType继承）

结构可以有类所有的所有成员，除了下列内容：

-  无参数构造器
-  清理器
-  虚成员

当需要值类型的语义时，使用结构来代替类。结构的好例子就是数值类型，其中通过拷贝值赋值要比拷贝引用赋值更为自然。因为结构是一个值类型，每一个实例并不需要在堆上对象实例化；当创建许多类型的实例时这将是十分有的资源节省。例如，创建一个值类型的数组只需要一次堆分配。

**结构构造语义**

结构的构造语义如下：

-  我们不能重写的无参数构造器隐式存在。这会执行域的位清零操作。
-  当我们定义一个结构构造器时，我们必须显式为每一个域赋值。
-  在结构中我们不能域初始化器。

下面是声明并调用结构构造器的例子：

.. code:: csharp

    public struct Point
    {
      int x, y;
      public Point (int x, int y) { this.x = x; this.y = y; }
    }
    ...
    Point p1 = new Point ();       // p1.x and p1.y will be 0
    Point p2 = new Point (1, 1);   // p1.x and p1.y will be 1

下面的示例生成三个编译时错误：

.. code:: csharp

    public struct Point
    {
      int x = 1;                          // Illegal: cannot initialize field
      int y;
      public Point() {}                   // Illegal: cannot have
                                          // parameterless constructor
      public Point (int x) {this.x = x;}  // Illegal: must assign field y
    }

将struct改变class则上面的示例就是合法的了。

访问修饰符
----------

为了实现封装，类型或是类型成员会通过向声明添加五个访问修饰符中的一个来限制其他类型或是其他程序集的访问：

-  public：完全可访问；对于枚举或是接口的成员隐式完全访问
-  internal：只对于所包含的程序集或友元程序可访问；对于非嵌入类型的默认访问性
-  private：只在包含的类型内可见；对于类或是结构成员的默认访问性
-  protected：只在包含的类型或是子类中可见
-  protected
   internal：protected与internal访问性的结合（这比单独的protected或是internal具有更少的限制）

示例
~~~~

Class2可以在其程序集外部被访问；Class1则不可以：

.. code:: csharp

    class Class1 {}                  // Class1 is internal (default)
    public class Class2 {}

ClassB向相同程序集中的其他类型公开了域x；ClassA则没有：

 class ClassA { int x; } // x is private (default) class ClassB {
internal int x; }

.. raw:: html

   </syntaxhighlight>

Subclass中的函数可以访问Bar，但是不能访问Foo：

.. code:: csharp

    class BaseClass
    {
      void Foo()           {}        // Foo is private (default)
      protected void Bar() {}
    }
    class Subclass : BaseClass
    {
       void Test1() { Foo(); }       // Error - cannot access Foo
       void Test2() { Bar(); }       // OK
    }

友元程序集
~~~~~~~~~~

在高级场景中，我们可以通过添加System.Runtime.CompilerServices.InternalsVisibleTo程序集属性来指定友元程序集的名，从而向其他的友元程序集公开internal成员，如下所示：

[assembly: InternalsVisibleTo ("Friend")]

如果友元有一个强名字，我们必须指定其完全的160字节的公钥：

[assembly: InternalsVisibleTo ("StrongFriend,
PublicKey=0024f000048c...")]

我们可以使用LINQ查询由一个强命名程序集中解出完全公钥：

.. code:: csharp

    string key = string.Join ("",
       Assembly.GetExecutingAssembly().GetName().GetPublicKey()
      .Select (b => b.ToString ("x2"))
      .ToArray());

访问性隐藏(Accessibility Capping)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

类型可以隐藏其声明成员的访问性。最常见的隐藏的例子就是我们有一个internal类型，而他有public方法。例如：

class C { public void Foo() {} }

C（默认）的internal访问性隐藏了Foo的访问性，从而使得Foo也成为internal。Foo应该标记为public的原因就是稍后C被修改为public之后，更易于重构。

访问修饰符的限制
~~~~~~~~~~~~~~~~

当重写基类的函数时，访问性必须与重写的函数相同。例如：

.. code:: csharp

    class BaseClass             { protected virtual  void Foo() {} }
    class Subclass1 : BaseClass { protected override void Foo() {} }  // OK
    class Subclass2 : BaseClass { public    override void Foo() {} }  // Error

编译器会阻止不一致的访问修饰符的使用。例如，子类本身的访问性可以少于基类，但是不能多：

.. code:: csharp

    internal class A {}
    public class B : A {}          // Error

接口
----

接口类似于类，但是他提供了规范而不是成员的实现。接口的特殊性体现在以下几方面：

-  一个类可以实现多个接口。相对应的，一个类只能由一个父类继承。
-  接口成员全部是隐式抽象的。相对应的，一个类可以提供抽象成员与带有实现的具体成员。
-  结构可以实现接口。相对应的，结构不能由类继承。

接口的声明类似于类的声明，但是他并没有为其成员提供实现，因为其所有成员都是隐式抽象的。这些成员将会由实现该接口的类或是结构来实现。接口只能包含方法，属性，事件与索引器，也就是可以抽象的类成员。

下面是定义在System.Collections中的IEnumreator接口的定义：

.. code:: csharp

    public interface IEnumerator
    {
      bool MoveNext();
      object Current { get; }
      void Reset();
    }

接口的成员总是隐式公开的，并且不能声明访问修饰符。实现接口意味着为其所有成员提供了一个public实现：

.. code:: csharp

    internal class Countdown : IEnumerator
    {
      int count = 11;
      public bool MoveNext () { return count-- > 0 ;               }
      public object Current   { get { return count; }              }
      public void Reset()     { throw new NotSupportedException(); }
    }

我们可以隐式将一个对象转换为他所实现的任意接口。例如：

.. code:: csharp

    IEnumerator e = new Countdown();
    while (e.MoveNext())
      Console.Write (e.Current);      // 109876543210

注意，尽管CountDown是一个内部类，实现了IEnumerator的成员可以将CountDown的实例转换为IEnumerator来公开调用。例如，相同程序集中的一个公开类型定义了如下的方法：

.. code:: csharp

    public static class Util
    {
      public static object GetCountDown()
      {
        return new CountDown();
      }
    }

其他程序集中的调用者可以进行如下的调用：

.. code:: csharp

    IEnumerator e = (IEnumerator) Util.GetCountDown();
    e.MoveNext();

如果IEnumerator本身被定义为internal，则上面的代码是不可行的。

扩展接口
~~~~~~~~

接口可以由其他的接口继承。例如：

.. code:: csharp

    public interface IUndoable             { void Undo(); }
    public interface IRedoable : IUndoable { void Redo(); }

IRedoable继承了IUndoable的所有成员。

显式接口实现
~~~~~~~~~~~~

实现多个接口有时会导致成员签名之间的冲突。我们可以通过显示实现一个接口成员来解决这种冲突。考虑下面的示例：

.. code:: csharp

    interface I1 { void Foo(); }
    interface I2 { int Foo(); }
    public class Widget : I1, I2
    {
      public void Foo ()
      {
        Console.WriteLine ("Widget's implementation of I1.Foo");
      }
      int I2.Foo()
      {
        Console.WriteLine ("Widget's implementation of I2.Foo");
        return 42;
      }
    }

因为I1与I2具有相冲突的Foo签名，Widget显式实现了I2的Foo方法。这可以使得两个方法在一个类中共存。调用显式实现的成员的唯一方法就是转换为其接口：

.. code:: csharp

    Widget w = new Widget();
    w.Foo();                      // Widget's implementation of I1.Foo
    ((I1)w).Foo();                // Widget's implementation of I1.Foo
    ((I2)w).Foo();                // Widget's implementation of I2.Foo

显式实现接口成员的另一个原因就是隐藏高度特殊化的成员并且转换为类型的通常使用情况。例如，实现了ISerializable的类型通常希望避免展示其ISerializable成员，除非显式转换为接口。

虚实现接口成员
~~~~~~~~~~~~~~

默认情况下，隐式实现的接口成员是sealed的。为了能够被重写他必须在基类中被标记为virtual或是abstract。例如：

.. code:: csharp

    public interface IUndoable { void Undo(); }
    public class TextBox : IUndoable
    {
      public virtual void Undo()
      {
         Console.WriteLine ("TextBox.Undo");
      }
    }
    public class RichTextBox : TextBox
    {
      public override void Undo()
      {
        Console.WriteLine ("RichTextBox.Undo");
      }
    }

通过基类或是通过接口调用接口成员都会调用子类的实现：

.. code:: csharp

    RichTextBox r = new RichTextBox();
    r.Undo();                          // RichTextBox.Undo
    ((IUndoable)r).Undo();             // RichTextBox.Undo
    ((TextBox)r).Undo();               // RichTextBox.Undo

显式实现在的接口成员不能被标记为virtual，也不能以通常的方式重写。然而却可以被重新实现。

在子类中实现接口
~~~~~~~~~~~~~~~~

子类可以实现父类已经实现在的任意的接口成员。重新实现会劫持成员实现（当通过接口调用时）并且无论基类的成员是否为virtual都能实现。同时无论成员是隐式还是显式实现也同样会工作－尽管正如我们所演示的，他在显式实现中工作得最好。

在下面的示例中，TextBox显式实现了IUndoable.Undo，因而他不能被标记为virtual，为了能够重写，RichTextBox必须重新实现IUndoable的Undo方法：

.. code:: csharp

    public interface IUndoable { void Undo(); }
    public class TextBox : IUndoable
    {
      void IUndoable.Undo() { Console.WriteLine ("TextBox.Undo"); }
    }
    public class RichTextBox : TextBox, IUndoable
    {
      public new void Undo() { Console.WriteLine ("RichTextBox.Undo"); }
    }

通过接口调用重新实现的成员会调用子类的实现：

.. code:: csharp

    RichTextBox r = new RichTextBox();
    r.Undo();                 // RichTextBox.Undo      Case 1
    ((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2

假定同样的RichTextBox定义，但是TextBox隐式实现Undo接口：

.. code:: csharp

    public class TextBox : IUndoable
    {
      public void Undo() { Console.WriteLine ("TextBox.Undo"); }
    }

这会为我们提供另一种调用Undo的方式，这种方法将会“破坏”系统，如示例3所示：

.. code:: csharp

    RichTextBox r = new RichTextBox();
    r.Undo();                 // RichTextBox.Undo      Case 1
    ((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2
    ((TextBox)r).Undo();      // TextBox.Undo          Case 3

示例显示了重新实现劫持只有在通过接口调用成员时有效，而通过基类调用时无效。这通常并不是我们所希望的，因为这意味着不一致的语义。重新实现是重写显式实现的接口成员的最合适策略。

**接口重新实现的另一种方法**

即使使用显式成员实现，接口重新实现也是有问题的，原因如下：

-  子类没有办法调用父类的方法
-  基类的作者也许并没有预料到方法会被重新实现并且也并不会允许潜在的结果。

当继承未被预料时，重新实现是最后的手段。然而，一个更好的选择是设计绝不需要重新实现的基类。有两种方法来实现这一点：

-  当隐式实现成员时，如果可能将其标记为virtual
-  当显式实现成员时，如果我们预料到子类也许需要重写些逻辑则使用下列模式：

.. code:: csharp

    public class TextBox : IUndoable
    {
      void IUndoable.Undo()         { Undo(); }   // Calls method below
      protected virtual void Undo() { Console.WriteLine ("TextBox.Undo"); }
    }
    public class RichTextBox : TextBox
    {
      protected override void Undo() { Console.WriteLine("RichTextBox.Undo"); }
    }

如果我们并不希望任何继承，我们可以将类标记为sealed来阻止接口重新实现。

接口与装箱
~~~~~~~~~~

将一个结构转换为接口会引起装箱。在结构上调用隐式实现的成员并不会引起装箱：

.. code:: csharp

    interface  I { void Foo();          }
    struct S : I { public void Foo() {} }
    ...
    S s = new S();
    s.Foo();         // No boxing.
    I i = s;         // Box occurs when casting to interface.
    i.Foo();

枚举
----

枚举是一种特殊的值类型，可以使得我们指定一个命名的数值常量组。例如：

.. code:: csharp

    public enum BorderSide { Left, Right, Top, Bottom }

我们可以以下面的方式来使用枚举：

.. code:: csharp

    BorderSide topSide = BorderSide.Top;
    bool isTop = (topSide == BorderSide.Top);   // true

每一个枚举成员都有一个底层的整数值。默认情况下：

-  底层值是int类型
-  自动以枚举成员声明的顺序赋值为0，1，2等

我们可以指定另一种整数类型，如下所示：

public enum BorderSide : byte { Left, Right, Top, Bottom }

同时我们也许会希望为每一个枚举成员显式指定一个底层值：

public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }

枚举转换
~~~~~~~~

我们可以使用显式转换将enum实例转换为其底层整数值，或者是相反的转换：

.. code:: csharp

    int i = (int) BorderSide.Left;
    BorderSide side = (BorderSide) i;
    bool leftOrRight = (int) side <= 2;

我们也可以显式的将一种枚举类型转换另一种枚举类型。假定HorizontalAlignment定义如下：

.. code:: csharp

    public enum HorizontalAlignment
    {
      Left = BorderSide.Left,
      Right = BorderSide.Right,
      Center
    }

枚举类型之间的转换使用底层整数值：

.. code:: csharp

    HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;
    // same as:
    HorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.Right;

enum表达式中的数值字面量0会被编译器特殊对待并且不需要显式的转换：

.. code:: csharp

    BorderSide b = 0;    // No cast required
    if (b == 0) ...

0的特殊处理有两个原因：

-  枚举的每一个成员通常用作默认值
-  对于组合的枚举类型，0意味着“没有标记”

Flags枚举
~~~~~~~~~

我们可以组合枚举成员。为了避免不确定性，可组合的枚举的成员需要显式赋值，通常是2的幂次。例如：

.. code:: csharp

    [Flags]
    public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }

为了使用组合的枚举值，我们使用位操作符，例如\|与&。这会在底层的整数值上进行操作：

.. code:: csharp

    BorderSides leftRight = BorderSides.Left | BorderSides.Right;
    if ((leftRight & BorderSides.Left) != 0)
      Console.WriteLine ("Includes Left");     // Includes Left
    string formatted = leftRight.ToString();   // "Left, Right"
    BorderSides s = BorderSides.Left;
    s |= BorderSides.Right;
    Console.WriteLine (s == leftRight);   // True
    s ^= BorderSides.Right;               // Toggles BorderSides.Right
    Console.WriteLine (s);                // Left

通过约定，Flags属性应总是可以应用在其成员可以组合的枚举类型上。如果我们没有使用Flags属性声明这样的enum，我们也可以组合成员，但是在enum实例上调用ToString方法会输出一个数字而不是一系列名字。

通过约定，可组合的枚举类型被指定为一个复数名字而不是一个单数名字。

为了方便，我们可以在枚举声明自身中包含组合成员：

.. code:: csharp

    [Flags]
    public enum BorderSides
    {
      Left=1, Right=2, Top=4, Bottom=8,
      LeftRight = Left | Right,
      TopBottom = Top  | Bottom,
      All       = LeftRight | TopBottom
    }

枚举操作符
~~~~~~~~~~

可以在枚举上使用的操作符如下：

.. code:: csharp

    =   ==   !=   <   >   <=   >=   +   -   ^  &  |   ?
    +=   -=   ++  -   sizeof

位操作符，算术操作符以及比较操作符返回底层整数值的处理结果。加操作符应用在枚举与整数类型之间，而不是两个枚举之间。

类型安全问题
~~~~~~~~~~~~

考虑下面的枚举：

.. code:: csharp

    public enum BorderSide { Left, Right, Top, Bottom }

因为枚举类型可以与底层的整数类型之间进行转换，实际的值也许会落在合法的枚举成员的边界之外。例如：

.. code:: csharp

    BorderSide b = (BorderSide) 12345;
    Console.WriteLine (b);                // 12345

位操作符与算术操作也会产生类似的不正确的值：

.. code:: csharp

    BorderSide b = BorderSide.Bottom;
    b++;                                  // No errors

不正确的BorderSide会破坏下面的代码：

.. code:: csharp

    void Draw (BorderSide side)
    {
      if      (side == BorderSide.Left)  {...}
      else if (side == BorderSide.Right) {...}
      else if (side == BorderSide.Top)   {...}
      else                               {...} // Assume BorderSide.Bottom
    }

一个解决方法就是添加另一个else子句：

.. code:: csharp

      ...
      else if (side == BorderSide.Bottom) ...
      else throw new ArgumentException ("Invalid BorderSide: " + side, "side");

另一种方法就是显式检测枚举值的正确的性。静态的Enum.IsDefined方法可以完成这一工作：

.. code:: csharp

    BorderSide side = (BorderSide) 12345;
    Console.WriteLine (Enum.IsDefined (typeof (BorderSide), side));   // False

不幸的是，Enum.IsDefined并不能用于标记的枚举。然而，下面的助手方法会在指定的标记枚举正确时返回true：

.. code:: csharp

    static bool IsFlagDefined (Enum e)
    {
      decimal d;
      return !decimal.TryParse(e.ToString(), out d);
    }
    [Flags]
    public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }
    static void Main()
    {
      for (int i = 0; i <= 16; i++)
      {
        BorderSides side = (BorderSides)i;
        Console.WriteLine (IsFlagDefined (side) + " " + side);
      }
    }

嵌套类型
--------

嵌套类型是在一个类型的作用域之外声明的类型。例如：

.. code:: csharp

    public class TopLevel
    {
      public class Nested { }               // Nested class
      public enum Color { Red, Blue, Tan }  // Nested enum
    }

嵌套类型具有下列特性：

-  他可以访问封装类型的私有方法以及封装类型可以访问的所用内容
-  他可以使用所有的访问修饰符声明，而不仅仅是public与internal
-  嵌套类型的可见性默认为private而不是internal
-  在封装类型的外面访问嵌套类型需要使用封装类型的名字作修饰

例如，为了在我们的TopLevel类之外访问Color.Red，我们必须使用下面的方式：

.. code:: csharp

    TopLevel.Color color = TopLevel.Color.Red;
    </syntaxhighligt>

    所有的类型都可以被嵌套；然而，只有类与结构可以嵌套。

    下面是由一个嵌套类型访问类型的私有成员的示例：

    <syntaxhighlight lang="csharp">
    public class TopLevel
    {
      static int x;
      class Nested
      {
        static void Foo() { Console.WriteLine (TopLevel.x); }
      }
    }

下面是在一个嵌套类型上应用protected访问修饰符的示例：

.. code:: csharp

    public class TopLevel
    {
      protected class Nested { }
    }
    public class SubTopLevel : TopLevel
    {
      static void Foo() { new TopLevel.Nested(); }
    }

下面是由封装类型的外面引用嵌套类型的示例：

.. code:: csharp

    public class TopLevel
    {
      public class Nested { }
    }
    class Test
    {
      TopLevel.Nested n;
    }

当编译器生成捕获构造器状态，例如迭代器与匿名方法，的私有类时，会大量使用嵌套类。

泛型
----

C#用两种单独的机制用于编写在不同的类型之间重用的代码：继承与泛型。其中继承使用基类类型表示重用性，泛型使用包含“占位”类型的“模板”表示重用性。与继承相比，泛型可以增加类型安全性并且减少转换与装箱。

泛型类型
~~~~~~~~

泛型类型声明类型参数－由泛型类型消费者来填充的占位符类型，泛型类型消费者提供了类型参数。下面是一个泛型类型Stack，被设计为类型T的栈实例。Stack声明了单一的类型参数T：

.. code:: csharp

    public class Stack<T>
    {
      int position;
      T[] data = new T[100];
      public void Push (T obj)   { data[position++] = obj;  }
      public T Pop()             { return data[--position]; }
    }

我们可以以如下的方式使用Stack：

.. code:: csharp

    Stack<int> stack = new Stack<int>();
    stack.Push(5);
    stack.Push(10);
    int x = stack.Pop();        // x is 10
    int y = stack.Pop();        // y is 5

Stack使用类型参数int填充类型参数T，在需要时隐式创建类型。Stack实际具有下列定义：

.. code:: csharp

    public class ###
    {
      int position;
      int[] data;
      public void Push (int obj)   { data[position++] = obj;  }
      public int Pop()             { return data[--position]; }
    }

由技术上来说，我们称Stack是一个开放类型，而Stack是一个封装类型。在运行时，所有的泛型实例都是封闭的－填充了占位符类型。这就意味着下面的语句是非法的：

var stack = new Stack(); // Illegal: What is T?

除非是在本身将T定义为类型参数的类或是方法中：

.. code:: csharp

    public class Stack<T>
    {
      ...
      public Stack<T> Clone()
      {
        Stack<T> clone = new Stack<T>();   // Legal
        ...
      }
    }

为什么存在泛型
~~~~~~~~~~~~~~

泛型用来编写在不同的类型之间可重用的代码。假定我们需要一个整数的栈，但是我们没有泛型类型。一个解决方法就是为所需要的每一个元素类型硬编码一个类的单独版本（例如IntStack，StringStack）。很明显，这会引起代码重复。另一种解决方法是使用object作为元素类型来编写一个泛型化的栈：

.. code:: csharp

    public class ObjectStack
    {
      int position;
      object[] data = new object[10];
      public void Push (object obj) { data[position++] = obj;  }
      public object Pop()           { return data[--position]; }
    }

然而，ObjectStack并不会硬编码的IntStack那样工作。特别是，ObjectStatck需要在编译时不能检测的装箱与向下转换操作：

.. code:: csharp

    // Suppose we just want to store integers here:
    ObjectStack stack = new ObjectStack();
    stack.Push ("s");          // Wrong type, but no error!
    int i = (int)stack.Pop();  // Downcast - runtime error

我们所需要的是能够用于所用元素类型的栈的泛型实现，以及一种主法使得我们可以很容易将栈特例为特定元素类型以增加类型安全并减少转换与装箱操作。泛型通过使得我们参数化元素类型来为我们提供我们所需要的。Stack同时具有ObjctStack与IntStack的优点。类似于ObjectStack，Stack被编写一次来处理所有的类型。类似于IntStack，Stack是特定于特定类型的－美妙之处就在于这个类型是T，我们可以在需要时替换。

泛型方法
~~~~~~~~

泛型方法在方法的签名内声明类型参数。

通过泛型方法，许多基础的算法就可以以一种通用的目的实现。下面是交换任意两个类型值的泛型方法：

.. code:: csharp

    static void Swap<T> (ref T a, ref T b)
    {
      T temp = a;
      a = b;
      b = temp;
    }

Swap可以以下面的方式使用：

.. code:: csharp

    int x = 5;
    int y = 10;
    Swap (ref x, ref y);

通常并没有必要向泛型方法提供类型参数，因为编译器可以隐式的推测类型。如果存在不确定性，泛型方法可以使用类型参数进行调用，如下所示：

Swap (ref x, ref y);

在泛型类型中，方法并不是泛型一类，除非他引入了类型参数。在我们泛型栈中的Pop方法并没有使用类型的类型参数，T，因而并不是一个泛型方法。

方法与类型是唯一可以引入类型参数的组成部分。属性，索引，事件，域，构造器，操作符等并不能声明类型参数，尽管他们可以共享由他们的封装类型所声明的类型参数。例如，在我们泛型栈的示例中，我们可以编写一个返回泛型项的索引器：

public T this [int index] { get { return data [index]; } }

类似的，构造器可以分享已存在的类型参数，但是不能引入类型参数：

public Stack() { } // Illegal

类型参数
~~~~~~~~

类型参数可以在类，结构，接口，委托以及方法的声明中引入。其他的组成部分，例如属性，不能引入类型参数，但是可以使用类型参数。例如，属性Value使用T：

.. code:: csharp

    public struct Nullable<T>
    {
      public T Value { get; set; }
    }

一个泛型类型或是泛型方法可以有多个参数。例如：

class Dictionary {...}

实例化方法如下：

Dictionary myDic = new Dictionary();

或者：

var myDic = new Dictionary();

泛型类型名字与泛型方法名字可以被重载，只要类型参数不同即可。例如，下面的两个类型名字并不冲突：

.. code:: csharp

    class A<T> {}
    class A<T1,T2> {}

typeof与非绑定的泛型类型
~~~~~~~~~~~~~~~~~~~~~~~~

开放泛型类型在运行时并不存在：开放泛型类型被封闭作为编译的一部分。然而，未绑定的泛型类型在运行时是可能存在的－作为Type对象。在C#中指定未绑定泛型类型的唯一方法是使用typeof操作符：

.. code:: csharp

    class A<T> {}
    class A<T1,T2> {}
    ...
    Type a1 = typeof (A<>);   // Unbound type (notice no type arguments).
    Type a2 = typeof (A<,>);  // Use commas to indicate multiple type args.

我们也可以使用typeof操作来指定一个封闭类型：

Type a3 = typeof (A);

或是一个开放类型：

class B { void X() { Type t = typeof (T); } }

默认泛型值
~~~~~~~~~~

default关键字可以用来获取指定给泛型类型参数的默认值。引用类型的默认值为null，值类型的默认值为类型的域位清零的结果：

.. code:: csharp

    static void Zap<T> (T[] array)
    {
      for (int i = 0; i < array.Length; i++)
        array[i] = default(T);
    }

泛型约束
~~~~~~~~

默认情况下，类型参数可以使用任意类型进行替换。可以在类型参数上应用约束来要求更为特定的类型参数。可能的约束如下：

.. code:: csharp

    where T : base-class   // Base class constraint
    where T : interface    // Interface constraint
    where T : class        // Reference-type constraint
    where T : struct       // Value-type constraint (excludes Nullable types)
    where T : new()        // Parameterless constructor constraint
    where U : T            // Naked type constraint

在下面的示例中，GenericClass要T由SomeClass派生并且实现Interface1，要求U提供无参数的构造器：

.. code:: csharp

    class     SomeClass {}
    interface Interface1 {}
    class GenericClass<T> where T : SomeClass, Interface1
                          where U : new()
    {...}

约束可以应用在定义类型参数的任意位置，方法或是类型定义中。

基类约束或是接口约束指定类型参数必须继承或是实现某个类或接口。这个可以使得该类型的实例隐式转换为该类或是接口。例如，假定我们要编写一个通用的Max方法，他会返回两个值中的大值。我们可以利用定义在框架中名为IComparable的泛型接口：

.. code:: csharp

    public interface IComparable<T>   // Simplified version of interface
    {
      int CompareTo (T other);
    }

如果other大于this则CompareTo会返回正数。使用这个接口作为约束，我们可以编写如下的Max方法：

.. code:: csharp

    static T Max <T> (T a, T b) where T : IComparable<T>
    {
      return a.CompareTo (b) > 0 ? a : b;
    }

Max方法可以接受实现了IComparable接口的任意类型：

.. code:: csharp

    int z = Max (5, 10);               // 10
    string last = Max ("ant", "zoo");  // zoo

类约束与结构结构约束指定了T必须是引用类型或是（非空的）值类型。结构约束的最好例子就是System.Nullable结构：

struct Nullable where T : struct {...}

无参数构造器约束要求T有一个公开的无参数构造器。如果定义了这个约束，我们可以在T上调用new()：

.. code:: csharp

    static void Initialize<T> (T[] array) where T : new()
    {
      for (int i = 0; i < array.Length; i++)
        array[i] = new T();
    }

无修饰类型约束要求类型参数派生于其他的类型参数。在这个示例中，方法FilteredStack返回另一个Stack，包含元素子集：

.. code:: csharp

    class Stack<T>
    {
      Stack<U> FilteredStack<U>() where U : T {...}
    }

继承泛型类型
~~~~~~~~~~~~

泛型类可以像非泛型类一样继承。子类可以使得父类的类型参数开放，如下面的示例所示：

.. code:: csharp

    class Stack<T>                   {...}
    class SpecialStack<T> : Stack<T> {...}

或者子类使用确定类型关闭泛型类型参数：

class IntStack : Stack {...}

子类型也可以引入新的类型参数：

.. code:: csharp

    class List<T>                     {...}
    class KeyedList<T,TKey> : List<T> {...}

自引用泛型声明
~~~~~~~~~~~~~~

当关闭类型参数时，类型可以将其自身命名为确定类型：

.. code:: csharp

    public interface IEquatable<T> { bool Equals (T obj); }
    public class Balloon : IEquatable<Balloon>
    {
      public string Color { get; set; }
      public int CC { get; set; }
      public bool Equals (Balloon b)
      {
        if (b == null) return false;
        return b.Color == Color && b.CC == CC;
      }
    }

下面的代码也是合法的：

.. code:: csharp

    class Foo<T> where T : IComparable<T> { ... }
    class Bar<T> where T : Bar<T> { ... }

静态数据
~~~~~~~~

对于每一个关闭类型，静态数据是唯一的：

.. code:: csharp

    class Bob<T> { public static int Count; }
    class Test
    {
      static void Main()
      {
        Console.WriteLine (++Bob<int>.Count);     // 1
        Console.WriteLine (++Bob<int>.Count);     // 2
        Console.WriteLine (++Bob<string>.Count);  // 1
        Console.WriteLine (++Bob<object>.Count);  // 1
      }
    }

类型参数与转换
~~~~~~~~~~~~~~

C#的转换操作符可以执行多种转换类型，包括：

-  数值转换
-  引用转换
-  装箱/拆箱转换
-  自定义转换

发生哪种类型的转换的决定是编译时基于操作的已知类型确定的。对于泛型类型参数则有一些有趣的场景，因为精确的操作数类型在编译时是未知的。如果这导致不确定性，编译器会生成错误。

最常见的场景是当我们希望执行引用转换时：

.. code:: csharp

    StringBuilder Foo<T> (T arg)
    {
      if (arg is StringBuilder)
        return (StringBuilder) arg;   // Will not compile
      ...
    }

不知道T的实际类型，编译器会认为我们希望其为自定义转换。最简单的解决方法是使用as操作符，这是确定的，因为他不能执行自定义转换：

.. code:: csharp

    StringBuilder Foo<T> (T arg)
    {
      StringBuilder sb = arg as StringBuilder;
      if (sb != null) return sb;
      ...
    }

更通常的解决方示是将其转换为object。这种方法之所以起作用是因为与object之间的转换并不是自定义转换，而是引用或装箱/拆箱转换。在这种情况下，StringBuilder是一个引用类型，所以他是引用转换：

`` return (StringBuilder) (object) arg;``

拆箱转换也会引入不确定性。下面的操作可能是拆箱，数值转换或是自定义转换：

int Foo (T x) { return (int) x; } // Compile-time error

解决方法就是首先转换为object，然后转换为int：

int Foo (T x) { return (int) (object) x; }

Covariance
~~~~~~~~~~

假定S继承B，如果X<S>允许引用转换到X<B>，则类型X就是covariant。

换句话说，如果下列语句合法，则IFoo是covariant：

.. code:: csharp

    IFoo<string> b = ...;
    IFoo<object> s = b;

在C#
4.0中，泛型接口允许covariant（泛型委托也是如此），但是泛型类并不支持。数组也支持covariance（如果S继承B，则S[]可以转换为B[]），在这里我们会进行讨论比较。

**类**

泛型类不是协变的（covariant），从而保证静态类型安全。考虑下面的代码：

.. code:: csharp

    class Animal {}
    class Bear : Animal {}
    class Camel : Animal {}
    public class Stack<T>   // A simple Stack implementation
    {
      int position;
      T[] data = new T[100];
      public void Push (T obj)   { data[position++] = obj;  }
      public T Pop()             { return data[--position]; }
    }

下面的代码会编译失败：

.. code:: csharp

    Stack<Bear> bears = new Stack<Bear>();
    Stack<Animal> animals = bears;            // Compile-time error

限制可以使用下面的代码防止运行时失败的可能：

animals.Push (new Camel()); // Trying to add Camel to bears

然而，缺少协变会阻碍可重用性。例如，假定我们希望编写一个Wash
Animal栈的方法：

.. code:: csharp

    public class ZooCleaner
    {
      public static void Wash (Stack<Animal> animals) {...}
    }

在Bear栈上调用Wash会产生编译时错误。一个解决方法就是使用约束重新定义Wash方法：

.. code:: csharp

    class ZooCleaner
    {
      public static void Wash<T> (Stack<T> animals) where T : Animal { ... }
    }

我们可以像下面这样调用Wash：

.. code:: csharp

    Stack<Bear> bears = new Stack<Bear>();
    ZooCleaner.Wash (bears);

另一个解决方法是使得Stack实现一个协变的泛型接口，我们稍后将会看到。

**数组**

由于历史原因，数组类型是协变的。如果B继承于A，则B[]可以被转换为A[]（两个都是引用类型）。例如：

.. code:: csharp

    Bear[] bears = new Bear[3];
    Animal[] animals = bears;     // OK

这种重用性的缺点就是运行时的元素赋值会失败：

animals[0] = new Camel(); // Runtime error

**接口**

作为C#
4.0，泛型接口支持通过out修饰符标记的类型参数的协变。与数组不同，修饰符保证接口的协变是完全类型安全的。为了进行演示，假定我们的Stack类实现了下面的接口：

public interface IPoppable { T Pop(); }

T上的out修饰符是C#
4.0新引入的，表明T只用于输出位置（例如方法的返回类型）。out修饰符将接口标记为协变的，并且允许我们编写下面的代码：

.. code:: csharp

    var bears = new Stack<Bear>();
    bears.Push (new Bear());
    // Bears implements IPoppable<Bear>. We can convert to IPoppable<Animal>:
    IPoppable<Animal> animals = bears;   // Legal
    Animal a = animals.Pop();

由bears到animals的转换是为编译器所允许的－因为接口是协变的。这是类型安全的，因为编译器尝试避免的情况－将Camel压入栈－并不会发生，因为并没有办法向接口提供Camel，其中T只能在输出位置出现。

我们可以保留转换协变性来解决重用问题的能力，如前所述：

.. code:: csharp

    public class ZooCleaner
    {
      public static void Wash (IPoppable<Animal> animals) { ... }
    }

如果我们在输入位置使用一个协变的类型参数，则编译器会生成错误。

Contravariance
--------------

我们在前面了解到，如果X<S>允许引用转换为X<B>，则类型X是协变的，其中S继承自B。当我们可以执行相同的转换时，则类型是逆变的－由X<B>到X<S>。这是由C#
4.0中的接口所支持的－当泛型类型参数只出现在输入位置时，由in修饰符进行修饰。扩展我们前面的例子，如果Stack类实现了下面的接口：

public interface IPushable { void Push (T obj); }

则我们可以合法的执行下面的操作：

.. code:: csharp

    IPushable<Animal> animals = new Stack<Animal>();
    IPushable<Bear> bears = animals;    // Legal
    bears.Push (new Bear());

在IPushable中并没有成员输出T，所以我们不会遇到将animals转换为bears的麻烦（例如，没有办法通过接口Pop）。

为了提供另一个例子，考虑下面的接口，定义为.NET框架的一部分：

.. code:: csharp

    public interface IComparer<in T>
    {
      // Returns a value indicating the relative ordering of a and b
      int Compare (T a, T b);
    }

因为这个接口是逆变的，我们可以使用IComparer来比较两个字符串：

.. code:: csharp

    var objectComparer = Comparer<object>.Default;
    // objectComparer implements IComparer<object>
    IComparer<string> stringComparer = objectComparer;
    int result = stringComparer.Compare ("Brett", "Jemaine");

与协变相对应的，如果我们尝试在输出位置使用逆变参数，则编译器会报告错误（例如，作为返回值，或是可读属性）。

C#泛型与C++模板
---------------

程序中C#泛型类似于C++模板，但是他们的作用完全不同。在两种情况下，必须出现生产者与消费者之间的合成，其中生产者的占位符类型是由消费者填充的。然而，对于C#泛型，生产者类型（例如，如List的开放类型）可以编译到库中（例如mscorlib.dll）。这之所以起作用是因为生产者与产生关闭类型的消费者之间的合成只有在运行时才会实际发生。对于C++模板，这种合成是在编译时执行的。这就意味着在C++中我们不会将模板库部署为dll－他们只作为源码存在。同时这也使得动态检测，单独创建，按需参数化类型变得很困难。

要深入了解为什么会出现这种情况，考虑C#中的Max方法：

.. code:: csharp

    static T Max <T> (T a, T b) where T : IComparable<T>
    {
      return a.CompareTo (b) > 0 ? a : b;
    }

为什么我们不能像下面这样实现呢？

.. code:: csharp

    static T Max <T> (T a, T b)
    {
      return a > b ? a : b;             // Compile error
    }

原因在于Max方法只被编译一次，并且适用于T的所有可能值。后一种方法不能成功，是因为并不是T的所有值都能理解>的含义－事实上，并不是所有的T都会有一个>操作符。相对应的，下面的代码显示了使用C++模板编写的Max方法。这段代码会对于每一个T值进行单独编译，依据对于一个特定的T是否理解>的语义，如果T不支持>操作符则会编译失败：

.. code:: cpp

    template <class T> T Max (T a, T b)
    {
      return a > b ? a : b;
    }

Chapter 4. Advanced C#
======================

在本章中，我们将会在前一章所探讨的概念的基础上探讨C#高级主题。我们应依次阅读前四节；我们可以任意阅读余下的章节。

委托
----

委托自动将方法调用者与目标方法之间建立关联。委托包括两方面：类型与实例。委托类型定义了调用者与目标将要遵循的协议，组成一个参数类型与返回类型的列表。委托实例是一个指向一个（或多个）遵循协议的目标方法的对象。

委托实例表面上作为调用者的委托：调用者调用委托，然后委托调用目标方法。这间接的分离了调用者与目标方法。

委托类型声明以delegate关键字为前缀，但是类似于一个（抽象）方法声明。例如：

delegate int Transformer (int x);

要创建委托实例，我们可以将一个方法赋值给委托变量：

.. code:: csharp

    class Test
    {
      static void Main()
      {
        Transformer t = Square;          // Create delegate instance
        int result = t(3);               // Invoke delegate
        Console.WriteLine (result);      // 9
      }
      static int Square (int x) { return x * x; }
    }

调用委托类似于调用方法（因为委托的目的就是提供一种间接级别）：

t(3);

语句：

Transformer t = Square;

是下列语句的简写：

Transformer t = new Transformer (Square);

而

t(3)

是下列语句的简写：

t.Invoke (3);

使用委托编写插件方法
~~~~~~~~~~~~~~~~~~~~

委托变量可以动态的赋值为方法。这对于编写插件方法十分有用。在这个示例中，我们有一个名为Transform的实用方法，用来在一个整数数组中的每一个元素上应用转换。Transform方法有一个委托参数，用来指定插件转换。

.. code:: csharp

    public delegate int Transformer (int x);
    class Util
    {
      public static void Transform (int[] values, Transformer t)
      {
        for (int i = 0; i < values.Length; i++)
          values[i] = t (values[i]);
      }
    }
    class Test
    {
      static void Main()
      {
        int[] values = { 1, 2, 3 };
        Util.Transform (values, Square);      // Dynamically hook in Square
        foreach (int i in values)
          Console.Write (i + "  ");           // 1   4   9
      }
      static int Square (int x) { return x * x; }
    }

多播委托
~~~~~~~~

所有的委托实例都具有多播的功能。这就意味着一个委托实例不仅可以指向一个目标方法，而且可以指向一个目标方法列表。+与+=操作符可以组合委托实例。例如：

.. code:: csharp

    SomeDelegate d = SomeMethod1;
    d += SomeMethod2;

最后一行代码与下面的代码功能相同：

d = d + SomeMethod2;

现在调用d则会同时调用SomeMethod1与SomeMethod2。委托以他们被添加的顺序进行调用。

在一个值为null的委托变量上调用+或是+=操作符也可以工作，而这种方式等同于为变量赋一个新值：

.. code:: csharp

    SomeDelegate d = null;
    d += SomeMethod1;       // Equivalent (when d is null) to d = SomeMethod1;

类似的，在具有一个目标的委托变量上调用-=操作符等同于将变量赋值为null。

如果多播委托具有非空的返回类型，调用者可以由最后一个调用的方法获得返回值。之前的方法仍然被调用，但是他们的返回值为丢弃。在多播应用的大多数场景中，他们都具有void返回类型，所以不会出现这种细微之处。

**多播委托示例**

假定我们要编写一个需要较长时运行的例程。该例程通过调用委托来向调用者报告进度。在这个示例中，HardWord例程具有一个ProgressReport委托参数，调用该委托来显示进度：

.. code:: csharp

    public delegate void ProgressReporter (int percentComplete);
    public class Util
    {
      public static void HardWork (ProgressReporter p)
      {
        for (int i = 0; i < 10; i++)
        {
          p (i * 10);                           // Invoke delegate
          System.Threading.Thread.Sleep (100);  // Simulate hard work
        }
      }
    }

为了监视进度，Main方法创建一个多播委托实例p，从而进度是通过两个独立的方法来进行监视的：

.. code:: csharp

    class Test
    {
      static void Main()
      {
        ProgressReporter p = WriteProgressToConsole;
        p += WriteProgressToFile;
        Util.HardWork (p);
      }
      static void WriteProgressToConsole (int percentComplete)
      {
        Console.WriteLine (percentComplete);
      }
      static void WriteProgressToFile (int percentComplete)
      {
        System.IO.File.WriteAllText ("progress.txt",
                                      percentComplete.ToString());
      }
    }

实例与静态方法目标
~~~~~~~~~~~~~~~~~~

当一个委托对象被赋值给一个实例方法时，委托对象不仅要维护到方法的引用，而且要维护到方法所属的实例的引用。System.Delegate类的Target属性表示这个实例（对于引用静态方法的委托为null）。例如：

.. code:: csharp

    public delegate void ProgressReporter (int percentComplete);
    class Test
    {
      static void Main()
      {
        X x = new X();
        ProgressReporter p = x.InstanceProgress;
        p(99);                                 // 99
        Console.WriteLine (p.Target == x);     // True
        Console.WriteLine (p.Method);          // Void InstanceProgress(Int32)
      }
    }
    class X
    {
      public void InstanceProgress (int percentComplete)
      {
        Console.WriteLine (percentComplete);
      }
    }

泛型委托类型
~~~~~~~~~~~~

一个委托类型可以包含泛型类型参数。例如：

public delegate T Transformer (T arg);

使用这个定义，我们可以编写适用于任意类型的泛型化的实用方法：

.. code:: csharp

    public class Util
    {
      public static void Transform<T> (T[] values, Transformer<T> t)
      {
        for (int i = 0; i < values.Length; i++)
          values[i] = t (values[i]);
      }
    }
    class Test
    {
      static void Main()
      {
        int[] values = { 1, 2, 3 };
        Util.Transform (values, Square);      // Dynamically hook in Square
        foreach (int i in values)
          Console.Write (i + "  ");           // 1   4   9
      }
      static int Square (int x) { return x * x; }
    }

Func与Action委托
~~~~~~~~~~~~~~~~

使用泛型委托，编写足够通用适用于任意返回类型与任意数目参数的方法的委托类型集合成为可能。这些委托就是定义在System名字空间中的Func与Action委托：

.. code:: csharp

    delegate TResult Func <out TResult>                ();
    delegate TResult Func <in T, out TResult>          (T arg);
    delegate TResult Func <in T1, in T2, out TResult>  (T1 arg1, T2 arg2);
    ... and so on, up to T16
    delegate void Action                 ();
    delegate void Action <in T>          (T arg);
    delegate void Action <in T1, in T2>  (T1 arg1, T2 arg2);
    ... and so on, up to T16

这些委托极其通用。我们前面示例中的Transform委托可以使用需要一个类型T参数并且返回相同类型值的Func委托来替换：

.. code:: csharp

    public static void Transform<T> (T[] values, Func<T,T> transformer)
    {
      for (int i = 0; i < values.Length; i++)
        values[i] = transformer (values[i]);
    }

这些委托唯一没有覆盖的实际场景就是ref/out与指针参数。

委托与接口
~~~~~~~~~~

委托可以解决的问题也可以由接口来解决。例如，下列的代码显示了如何使用ITransformer接口来解决我们的过滤问题：

.. code:: csharp

    public interface ITransformer
    {
      int Transform (int x);
    }
    public class Util
    {
     public static void TransformAll (int[] values, ITransformer t)
     {
       for (int i = 0; i < values.Length; i++)
         values[i] = t.Transform (values[i]);
     }
    }
    class Squarer : ITransformer
    {
      public int Transform (int x) { return x * x; }
    }
    ...
    static void Main()
    {
      int[] values = { 1, 2, 3 };
      Util.TransformAll (values, new Squarer());
      foreach (int i in values)
        Console.WriteLine (i);
    }

如果下列条件中的一个或是多个为真，则选择设计委托要优于选择设计接口中：

-  接口只定义一个方法
-  需要多播功能
-  订阅者需要多次实现接口

在ITransformer示例中，我们并不需要多播。然而接口只定义了一个方法。而且，我们的订阅者需要多次实现ITransformer来支持不同的转换，例如平方或是立方。使用接口，我们被强制为每一个转换编写一个单独的类型，因为Test只能实现ITransformer一次。这是十分麻烦的：

.. code:: csharp

    class Squarer : ITransformer
    {
      public int Transform (int x) { return x * x; }
    }
    class Cuber : ITransformer
    {
      public int Transform (int x) {return x * x * x; }
    }
    ...
    static void Main()
    {
      int[] values = { 1, 2, 3 };
      Util.TransformAll (values, new Cuber());
      foreach (int i in values)
        Console.WriteLine (i);
    }

委托兼容
~~~~~~~~

**类型兼容**

委托类型彼此之间是不兼容的，尽管他们的签名也许相同：

.. code:: csharp

    delegate void D1();
    delegate void D2();
    ...
    D1 d1 = Method1;
    D2 d2 = d1;                           // Compile-time error

注，然而下面的代码是允许的：

D2 d2 = new D2 (d1);

如果委托实例具有方法目标，则认为他们是相等的：

.. code:: csharp

    delegate void D();
    ...
    D d1 = Method1;
    D d2 = Method1;
    Console.WriteLine (d1 == d2);         // True

对于多播委托，如果我们以相同的顺序指向相同的目标，则认为他们是相等的。

**参数兼容性**

当我们调用一个方法时，我们可以提供比方法的参数更为特殊化的类型的参数。这是普通的多态行为。由于相同的原因，委托也可以具有比其方法目标更为特殊的参数类型。这被称之为逆变性。

如下面的示例：

.. code:: csharp

    delegate void StringAction (string s);
    class Test
    {
      static void Main()
      {
        StringAction sa = new StringAction (ActOnObject);
        sa ("hello");
      }
      static void ActOnObject (object o)
      {
        Console.WriteLine (o);   // hello
      }
    }

委托不会以其他的角色调用方法。在这个示例中，StringAction被使用string类型的参数进行调用。当参数到达目标方法时，参数会隐式的向上转换为object。

**返回类型兼容**

如果我们调用一个方法，我们也许会获得一个比我们所要求的更为特殊的类型。这是普通的多态行为。由于同样的原因，委托的返回类型可以比其目标方法的返因类型更为宽泛。例如：

.. code:: csharp

    delegate object ObjectRetriever();
    class Test
    {
      static void Main()
      {
        ObjectRetriever o = new ObjectRetriever (RetriveString);
        object result = o();
        Console.WriteLine (result);      // hello
      }
      static string RetriveString() { return "hello"; }
    }

ObjectRetriever希望返回一个object，但是object的子类也可以：委托返回类型是协变的。

**泛型委托类型参数变化（C# 4.0）**

在第3章中我们了解了泛型接口如何支持协变与逆变类型参数。委托也存在同样的功能。

如果我们定义一个泛型委托类型，良好的实践是：

-  将只用作返回值的类型参数标记为协变的(out)
-  将用在参数上的任意类型参数标记为逆变的(in)

这样做可以使得通过考虑类型之间的继承关系而进行的转换更为自然。

下面的委托（定义在System名字空间中）支持协变：

delegate TResult Func();

允许：

.. code:: csharp

    Func<string> x = ...;
    Func<object> y = x;

下列的委托（定义在System名字空间中）支持逆变：

delegate void Action (T arg);

允许：

.. code:: csharp

    Action<object> x = ...;
    Action<string> y = x;

事件
----

当使用委托时，通常会出现两种角色：广播者与订阅者。

广播者是一个包含委托域的类型。广播者通过调用委托来决定何时广播。

订阅者是一个方法目标容器。订阅者通过在广播者委托上调用+=与-=来决定何时启动与停止监听。订阅者并不知道其他的订阅者。

事件是形成这种模式的语言特性。event是一个只公开广播者/订阅者模型所需要的委托特性子集的结构。事件的主要目的就是阻止订阅者彼此之间的干扰。

声明事件最简单的方法是将event关键字放在委托成员的前面：

.. code:: csharp

    public class Broadcaster
    {
      public event ProgressReporter Progress;
    }

Broadcaster类型中的代码可以完全访问Progress，并且将其看作一个委托。Broadcaster之外的代码只能在Progress事件上执行+=与-=操作。

考虑下面的示例。Stock类会在每次Stock的Price变化时触发PriceChanged事件：

.. code:: csharp

    public delegate void PriceChangedHandler (decimal oldPrice,
                                              decimal newPrice);
    public class Stock
    {
      string symbol;
      decimal price;
      public Stock (string symbol) { this.symbol = symbol; }
      public event PriceChangedHandler PriceChanged;
      public decimal Price
      {
        get { return price; }
        set
        {
          if (price == value) return;      // Exit if nothing has changed
          if (PriceChanged != null)        // If invocation list not empty,
            PriceChanged (price, value);   // fire event.
          price = value;
        }
      }
    }

如果我们由示例中移除event关键字，，那么PriceChanged就变为一个普通的委托域，我们的示例依然可以给出相同的结果。然而，Stock就会变得不稳健，因为订阅者可以执行下面的操作从而彼此之间进行干扰：

-  通过重新赋值PriceChanged（而不是使用+=操作符）来替换其他的订阅者。
-  清空所有的订阅者（通过将PriceChanged设置为null）。
-  通过调用委托来向其他的订阅者广播。

标准事件模式
~~~~~~~~~~~~

.NET框架为编写事件定义了一个标准模式。其目的是在框架与用户代码之间提供一致性。标准事件模式的核心是System.EventArgs：没有任何成员（而不是静态Empty属性）的预定义框架类。EventArgs是一个为事件传输信息的基类。在我们Stock的示例中，我们可以派生EventArgs在PriceChanged事件被触发时传送旧的与新的价格：

.. code:: csharp

    public class PriceChangedEventArgs : System.EventArgs
    {
      public readonly decimal LastPrice;
      public readonly decimal NewPrice;
     
      public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
      {
        LastPrice = lastPrice;
        NewPrice = newPrice;
      }
    }

为了重用性，EventArgs子类通过其所包含的信息来命名（而是他将要使用的事件）。他通常通过或是只读域公开数据。

有了EventArgs子类，接下来就是为事件选择或是定义一个委托。有三条规则：

-  他必须是void返回类型
-  他必须接受两个参数：第一个是object类型，而第二个EventArgs子类。第一个参数表示事件的广播者，而第二个参数包含要传递的额外信息。
-  名字必须以EventHandler结尾。

框架定义了一个名为System.EventHandler<>满足这些规则的泛型委托：

.. code:: csharp

    public delegate void EventHandler<TEventArgs>
      (object source, TEventArgs e) where TEventArgs : EventArgs;

接下来要定义一个所选委托类型的事件。在这里我们使用泛型EventHandler委托：

.. code:: csharp

    public class Stock
    {
      ...
      public event EventHandler<PriceChangedEventArgs> PriceChanged;
    }

最手，模式要求我们编写一个触发事件的受保护的虚方法。名字必须与事件名字相匹配，以单词On前缀，并接受一个EventArgs参数：

.. code:: csharp

    public class Stock
    {
      ...
      public event EventHandler<PriceChangedEventArgs> PriceChanged;
      protected virtual void OnPriceChanged (PriceChangedEventArgs e)
      {
        if (PriceChanged != null) PriceChanged (this, e);
      }
    }

这提供了一个中心点，由此子类可以调用或是重写事件。下面是一个复杂的示例：

.. code:: csharp

    using System;
    public class PriceChangedEventArgs : EventArgs
    {
      public readonly decimal LastPrice;
      public readonly decimal NewPrice;
      public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
      {
        LastPrice = lastPrice; NewPrice = newPrice;
      }
    }
    public class Stock
    {
      string symbol;
      decimal price;
      public Stock (string symbol) {this.symbol = symbol;}
      public event EventHandler<PriceChangedEventArgs> PriceChanged;
      protected virtual void OnPriceChanged (PriceChangedEventArgs e)
      {
        if (PriceChanged != null) PriceChanged (this, e);
      }
      public decimal Price
      {
        get { return price; }
        set
        {
          if (price == value) return;
          OnPriceChanged (new PriceChangedEventArgs (price, value));
          price = value;
        }
      }
    }
    class Test
    {
      static void Main()
      {
        Stock stock = new Stock ("THPW");
        stock.Price = 27.10M;
        // Register with the PriceChanged event
        stock.PriceChanged += stock_PriceChanged;
        stock.Price = 31.59M;
      }
      static void stock_PriceChanged (object sender, PriceChangedEventArgs e)
      {
        if ((e.NewPrice - e.LastPrice) / e.LastPrice > 0.1M)
          Console.WriteLine ("Alert, 10% stock price increase!");
      }
    }

当事件并不包含额外的信息时，可以使用预定义的非泛型的EventHandler委托。在这个示例中，我们重写了Stock，从而PriceChanged事件会在价格变化之后触发，并且没有关于事件的必须信息，仅是事件发生了。我们同时利用了EventArgs.Empty属性来避免不必要的EventArgs实例的实例化。

.. code:: csharp

    public class Stock
    {
      string symbol;
      decimal price;
      public Stock (string symbol) { this.symbol = symbol; }
      public event EventHandler PriceChanged;
      protected virtual void OnPriceChanged (EventArgs e)
      {
        if (PriceChanged != null) PriceChanged (this, e);
      }
      public decimal Price
      {
        get { return price; }
        set
        {
          if (price == value) return;
          price = value;
          OnPriceChanged (EventArgs.Empty);
        }
      }
    }

事件访问器
~~~~~~~~~~

事件的访问是其+=与-=功能的实现。默认情况下，访问器是编译器隐式实现的。考虑下面的事件声明：

public event EventHandler PriceChanged;

编译器将其转换为：

-  一个私有的委托域
-  一对公开的事件处理器函数，其实现将+=与-=操作转向私有的委托域

我们可以通过定义显式的事件访问器来接管这一过程。下面是是我们前面示例中PriceChanged事件的手工实现：

.. code:: csharp

    private EventHandler _priceChanged;         // Declare a private delegate
    public event EventHandler PriceChanged
    {
      add    { _priceChanged += value; }
      remove { _priceChanged -= value; }
    }

这个示例在功能上与C#的默认访问器实现完全相同。通过定义我们自己的事件访问顺，我们指示C#不要生成默认的域与访问器逻辑。

通过显式的事件访问器，我们可以在存储上应用更为复杂的策略并且访问底层委托。有三种有用的场景：

-  当事件访问器仅是传递广播事件的另一个类时
-  当类公开了大量的事件，而大多数时候只存在很少的订阅者，例如窗体控制。在这些情况下，最好是将订阅者的委托存储在一个字典中，因为字典要比大量的空委托域引用占用更少的空间。
-  当显式实现声明事件的接口时

下面是一个演示最后一点的例子：

.. code:: csharp

    public interface IFoo { event EventHandler Ev; }
    class Foo : IFoo
    {
      private EventHandler ev;
      event EventHandler IFoo.Ev
      {
        add    { ev += value; }
        remove { ev -= value; }
      }
    }

事件修饰符
~~~~~~~~~~

类似于方法，事件可以是virtual，override，abstract或是sealed。事件还可以是静态的：

.. code:: csharp

    public class Foo
    {
      public static event EventHandler<EventArgs> StaticEvent;
      public virtual event EventHandler<EventArgs> VirtualEvent;
    }

Lambda表达式
------------

Lambda表达式是在委托实例内编写的未命名方法。编译器会立即将Lambda表达式转换为：

-  委托实例
-  Experssion类型的表达式树，以可遍历的对象模型的方式表示Lambda表达式中的代码。这可以使得Lambda表达式稍后在运行时解释。

给定下列的委托类型：

delegate int Transformer (int i);

我们可以赋值并调用Lambda表达式x=>x\*x，如下所示：

.. code:: csharp

    Transformer sqr = x => x * x;
    Console.WriteLine (sqr(3));    // 9

Lambda表达式具有下列形式：

(parameters) => expression-or-statement-block

为了方便，当且仅当只有一个可推测的类型的参数时，我们可以忽略括号。

在我们的示例中，只有一个参数x，而表达式是x\*x：

x => x \* x;

Lambda表达式的每一个参数与一个委托参数相对应，而表达式类型（也许为void）与委托的返回类型相对应。

在我们的示例中，x与参数i相对应，而表达式x\*x与返回类型int相对应，所以与Transformer委托相兼容：

delegate int Transformer (int i);

Lambda表达式的代码可以是一个语句块，而不仅是一条语句。我们可以将我们的代码重写如下：

x => { return x \* x; };

Lambda表达式更通常用于Func与Action委托中，所以我们经常会看到我们前面的示例被编写为：

Func sqr = x => x \* x;

下面是接受两个参数的表达式示例：

.. code:: csharp

    Func<string,string,int> totalLength = (s1, s2) => s1.Length + s2.Length;
    int total = totalLength ("hello", "world");   // total is 10;

Lambda表达式在C# 3.0中引入。

显式指定Lambda参数类型
~~~~~~~~~~~~~~~~~~~~~~

编译器通常可以推测Lambda表达式参数的类型。当不能推测时，我们必须为每一个参数显式指定类型。考虑下面的表达式：

Func sqr = x => x \* x;

编译器使用类型推测推测x为int。

我们可以显式指定x的类型，如下所示：

Func sqr = (int x) => x \* x;

捕获外部变量（Outer Variables）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lambda表达式可以引用在方法内部所定义的变量与参数。例如：

.. code:: csharp

    static void Main()
    {
      int factor = 2;
      Func<int, int> multiplier = n => n * factor;
      Console.WriteLine (multiplier (3));           // 6
    }

由Lambda表达式所引用的外部变量被称之被捕获的变量。捕获变量的Lambda表达式称之为closure。

被捕获的变量在委托实际被调用时才会进行计算，而不是变量被捕获时计算：

.. code:: csharp

    int factor = 2;
    Func<int, int> multiplier = n => n * factor;
    factor = 10;
    Console.WriteLine (multiplier (3));           // 30

Lambda表达式本身可以更新捕获的变量：

.. code:: csharp

    int seed = 0;
    Func<int> natural = () => seed++;
    Console.WriteLine (natural());           // 0
    Console.WriteLine (natural());           // 1
    Console.WriteLine (seed);                // 2

被捕获变量的生命周期可以扩展到整个委托的生命周期。在下面的示例中，当Natural执行完成时，局部变量seed将会由作用域内消失。但是由于seed已被捕获，其生命周期会被扩展到捕获委托的生命周期，natural：

.. code:: csharp

    static Func<int> Natural()
    {
      int seed = 0;
      return () => seed++;      // Returns a closure
    }
    static void Main()
    {
      Func<int> natural = Natural();
      Console.WriteLine (natural());      // 0
      Console.WriteLine (natural());      // 1
    }

在Lambda表达式内部实例化的局部变量对于委托实例的每次执行都是唯一的。如果我们重构之前的示例在Lambda表达式内部实例化seed，我们就会得到不同的结果：

.. code:: csharp

    static Func<int> Natural()
    {
      return() => { int seed = 0; return seed++; };
    }
    static void Main()
    {
      Func<int> natural = Natural();
      Console.WriteLine (natural());           // 0
      Console.WriteLine (natural());           // 0
    }

**捕获迭代变量**

当我们在for与foreach语句内捕获迭代变量时，C#会将这些迭代变量看作是在循环之外声明的。这意味着相同的变量会在每一次迭代中被捕获。下面的程序会输出333而不是012：

.. code:: csharp

    Action[] actions = new Action[3];
    for (int i = 0; i < 3; i++)
      actions [i] = () => Console.Write (i);
    foreach (Action a in actions) a();     // 333

每一个闭包捕获相同的变量，i。当委托稍后被调用时，每一个委托在执行时所看到的i值是3。我们可以通过将for循环扩展为如下的样子来进行更好的演示：

.. code:: csharp

    Action[] actions = new Action[3];
    int i = 0;
    actions[0] = () => Console.Write (i);
    i = 1;
    actions[1] = () => Console.Write (i);
    i = 2;
    actions[2] = () => Console.Write (i);
    i = 3;
    foreach (Action a in actions) a();    // 333

如果我们希望输出012，则解决方法是将迭代变量赋值给一个循环作用域内的局部变量：

.. code:: csharp

    Action[] actions = new Action[3];
    for (int i = 0; i < 3; i++)
    {
      int loopScopedi = i;
      actions [i] = () => Console.Write (loopScopedi);
    }
    foreach (Action a in actions) a();     // 012

这会使得闭包在每次迭代时捕获不同的变量。

匿名方法
--------

匿名方法是C#2.0特性，但已在很大程度上为C#3.0所包含。匿名方法类似于Lambda表达式，但是缺少下列特性：

-  隐匿类型参数
-  表达式语法（匿名方法必须总是一个语句块）
-  通过赋值给Expression编译为表达式树的能力

要编写匿名方法，我们包含delegate关键字，后跟参数声明，然后是方法体。例如，给定下列委托：

delegate int Transformer (int i);

我们可以像下面这样编写并调用匿名方法：

.. code:: csharp

    Transformer sqr = delegate (int x) {return x * x;};
    Console.WriteLine (sqr(3));                            // 9

第一行在语义上等同于下面的Lambda表达式：

Transformer sqr = (int x) => {return x \* x;};

或是简单的：

Transformer sqr = x => x \* x;

匿名方法的唯一特性就是我们可以忽略整个参数声明-尽管委托需要这些声明。这在使用默认空处理器的声明事件中会很有用：

public event EventHandler Clicked = delegate { };

这避免了在触发事件前的空检测。下面的语句也是合法的：

Clicked += delegate { Console.WriteLine ("clicked"); }; // No parameters

匿名方法使用与Lambda表达式相同的方式来捕获外部变量。

try语句与异常
-------------

try语句指定了以错误处理或清理代码为目的的代码块。try块后必须跟随catch块，finally块，或是两者。catch块会在try块中发生错误时执行。finally块会在执行离开try块时执行（或catch块）来执行清理代码，而无论是否发生错误。

catch块可以访问包含关于错误信息的Exception对象。我们使用catch块或者补偿，或者重新抛出异常。如果我们仅是错词记录问题日志，或是如果我们希望重新抛出一个新的，更高级别的异常类型，我们可以重新抛出异常。

finally块通过任意情况下的确定执行为我们的程序添加了确定性。他对于如关闭网络连接这样的清理任务非常有用。

try语句如下所示：

.. code:: csharp

    try
    {
      ... // exception may get thrown within execution of this block
    }
    catch (ExceptionA ex)
    {
      ... // handle exception of type ExceptionA
    }
    catch (ExceptionB ex)
    {
      ... // handle exception of type ExceptionB
    }
    finally
    {
      ... // cleanup code
    }

考虑下面的程序：

.. code:: csharp

    class Test
    {
      static int Calc (int x) { return 10 / x; }
      static void Main()
      {
        int y = Calc (0);
        Console.WriteLine (y);
      }
    }

因为x为0，运行时会抛出DivideByZeronException，并且程序终止。我们可以通过像下面这样捕获异常来进行避免：

.. code:: csharp

    class Test
    {
      static int Calc (int x) { return 10 / x; }
      static void Main()
      {
        try
        {
          int y = Calc (0);
          Console.WriteLine (y);
        }
        catch (DivideByZeroException ex)
        {
          Console.WriteLine ("x cannot be zero");
        }
        Console.WriteLine ("program completed");
      }
    }

输出结果如下：

.. code:: text

    x cannot be zero
    program completed

当异常被抛出时，CLR会执行测试：

当前try语句内的执行是否可以捕获异常？

-  如果可以，执行会被传递给兼容的catch块。如果catch块成功执行，执行会继续移动到try语句之后的下一条语句上（如果存在finally块，则会首先执行finally块）
-  如果不可以，执行会跳回到函数调用者，并且重复测试（在执行完封装语句的所有finally块之后）

如果没有函数负责处理异常，则会向用户显示一个错误对话框，并且终止程序。

catch子句
~~~~~~~~~

catch子句指定了捕获哪些类型的异常。这必须是System.Exception或是System.Exception的子类。

捕获System.Exception会捕获所有可能的错误。当符合下列条件时会非常有用：

-  我们的程序可以由特定的异常类型中恢复。
-  我们计划重新抛出异常（也许是在日志之后）。
-  我们的错误处理器是终止程序之前的最后尝试。

然而更通常的情况是，为了避免必须处理我们的处理器没有预料到的条件（例如OutOfMemoryException），我们捕获特定的异常类型。

我们可以通过多个catch子句处理多个异常（再一次强调，这个示例可以使用显式的参数检测而不是异常处理进行编写）：

.. code:: csharp

    class Test
    {
      static void Main (string[] args)
      {
        try
        {
          byte b = byte.Parse (args[0]);
          Console.WriteLine (b);
        }
        catch (IndexOutOfRangeException ex)
        {
          Console.WriteLine ("Please provide at least one argument");
        }
        catch (FormatException ex)
        {
          Console.WriteLine ("That's not a number!");
        }
        catch (OverflowException ex)
        {
          Console.WriteLine ("You've given me more than a byte!");
        }
      }
    }

对于指定的异常只会执行一个catch子句。如果我们希望包含一个安全网来捕获更为普通的异常（例如System.Exception），我们必须将最特殊的异常放在前面。

如果我们不希望访问异常的属性，异常可以在没有指定变量的情况下被捕获：

.. code:: csharp

    catch (StackOverflowException)   // no variable
    {
      ...
    }

而且我们可以同时忽略变量与类型（意味着所有的异常将会被捕获）：

catch { ... }

finally块
~~~~~~~~~

finally块总是会执行－无论异常是否被抛出，也无论try块是否运行结束。finally块通常用于清理代码。

finally块的执行或者：

-  在catch块完成之后
-  由于跳转语句（例如return或goto）控制离开try块之后
-  在try块结束之后

finally块有助于为程序添加确定性。在下面的示例中，我们所打开的文件总是会被关闭，而无论：

-  try块是否正常完成
-  是否由于文件为空时的执行返回（EndOfStream）
-  是否在读取文件时抛出IOException

.. code:: csharp

    static void ReadFile()
    {
      StreamReader reader = null;    // In System.IO namespace
      try
      {
        reader = File.OpenText ("file.txt");
        if (reader.EndOfStream) return;
        Console.WriteLine (reader.ReadToEnd());
      }
      finally
      {
        if (reader != null) reader.Dispose();
      }
    }

在这个示例中，我们通过在StreamReader上调用Dispose关闭文件。在finally块内的对象上调用Dispose是贯穿.NET框架的标准约定，并且在C#中通过using语句被显式支持。

**using语句**

许多类封装了非托管资源，例如文件句柄，图形句柄或是数据库连接。这些类实现了System.IDisposable，该接口定义了一个名为Dispose的无参数方法来清理这些资源。using语句为在finally块内的IDisposable对象上调用Dispose提供一种优雅的语法。

下面的语句：

.. code:: csharp

    using (StreamReader reader = File.OpenText ("file.txt"))
    {
      ...
    }

等同于正下面的代码：

.. code:: csharp

    StreamReader reader = File.OpenText ("file.txt");
    try
    {
      ...
    }
    finally
    {
      if (reader != null)
       ((IDisposable)reader).Dispose();
    }

我们会在第12章更详细的讨论销毁模式。

抛出异常
~~~~~~~~

异常可以由运行时或是在用户代码中抛出。在这个示例中，Display抛出System.ArgumentNullException：

.. code:: csharp

    class Test
    {
      static void Display (string name)
      {
        if (name == null)
          throw new ArgumentNullException ("name");
        Console.WriteLine (name);
      }
      static void Main()
      {
        try { Display (null); }
        catch (ArgumentNullException ex)
        {
          Console.WriteLine ("Caught the exception");
        }
      }
    }

**重新抛出异常**

我们可以像下面这样捕获并重新抛出异常：

.. code:: csharp

    try {  ...  }
    catch (Exception ex)
    {
      // Log error
      ...
      throw;          // Rethrow same exception
    }

以这种方式重新抛出可以使得我们记录错误而不处理。也可以让我们收回预期之外异常的处理：

.. code:: csharp

    using System.Net;       // (See Chapter 14)
    ...
    string s = null;
    using (WebClient wc = new WebClient())
      try { s = wc.DownloadString ("http://www.albahari.com/nutshell/");  }
      catch (WebException ex)
      {
        if (ex.Status == WebExceptionStatus.NameResolutionFailure)
          Console.WriteLine ("Bad domain name");
        else
          throw;     // Can't handle other sorts of WebException, so rethrow
      }

另一种更为常见的应用场景是重新抛出更为特殊的异常。例如：

.. code:: csharp

    try
    {
      ... // Parse a DateTime from XML element data
    }
    catch (FormatException ex)
    {
      throw new XmlException ("Invalid DateTime", ex);
    }

重新抛出异常并不会影响异常的StackTrace属性。当重新抛出不同的异常时，我们可以将InnerException设置为原始异常，如果这样有助于调试。几乎所有的异常类型都提供了用于该目的的构造器。

System.Exception的关键属性
~~~~~~~~~~~~~~~~~~~~~~~~~~

System.Exception几个最重要的属性如下：

StackTrace：表示异常源到catch块所调用的所有方法的字符串。
Message：带有错误描述的字符串。
InnerException：引起外层异常的内层异常。该内层异常本身也许还有其他的InnerException。

常见的异常类型
~~~~~~~~~~~~~~

下面的异常类型在CLR与.NET框架之间广泛使用。我们可以亲自抛出这些异常，或是将其用作基类来派生自定义的异常类型：

System.ArgumentException：当函数使用错误的参数调用时抛出。这通常意味着程序bug。

System.ArgumentNullException：ArgumentException的子类，当函数参数为null时抛出。

System.ArgumentOutOfRangeException：ArgumentException的子类，当参数过大或是过小时抛出。例如，当向仅期望正数值作为参数的函数传负数时会抛出该异常。

System.InvalidOperationException：当对象的状态不适合于方法成功执行时抛出，而无论任何特定的参数值。例如读取未打开的文件或是由迭代器获取下一个元素，而底层已在迭代时被修改。

System.NotSupportedException：抛出异常表明特定的功能并不被支持。例如在IsReadOnly返回true的集合上调用Add方法。

System.NotImplementedException：抛出异常表明某个功能还没有被现。

System.ObjectDisposedException：当调用函数所在的对象已被销毁时抛出。

常见模式
~~~~~~~~

**TryXXX方法模式**

当编写方法时，我们可以选择当发生错误时返回某种类型的失败代码或是抛出异常。通常，当错误位于正常的工作流之外时，或是我们认为直接调用时不能处理时，我们抛出异常。然而有时最好是同时向用户提供两种选择。这种模式的一个示例就是int类型，该类型定义了两个Parse方法版本：

.. code:: csharp

    public int Parse     (string input);
    public bool TryParse (string input, out int returnValue);

如果解析失败，Parse抛出异常；TryParse返回false。

我们可以通过使得XXX方法调用TryXXX方法来实现这种模式，如下所示：

.. code:: csharp

    public return-type XXX (input-type input)
    {
      return-type returnValue;
      if (!TryXXX (input, out returnValue))
        throw new YYYException (...)
      return returnValue;
    }

**原子模式**

有些操作的原子性是必须的，或者完全成功，或者失败而不影响状态。当对象由于半完成操作的结果而进入不确定状态时，则该对象是不可用的。finally块可以用来编写原子操作。

在下面的示例中，我们使用Accumulator类，该类有一个Add方法，可以将一个整数数组添加其域Total中。如果Total超出int的最大值，则Add方法会导致OverflowException。Add方法是原子的，或者成功更新Total，或者失败，并保持Total的之前值：

.. code:: csharp

    public return-type XXX (input-type input)
    {
      return-type returnValue;
      if (!TryXXX (input, out returnValue))
        throw new YYYException (...)
      return returnValue;
    }

在Accumulator的实现中，Add方法的执行会影响Total域。然而，如果在方法调用期间出现错误，Total就会恢复到方法开始时的初始值。

.. code:: csharp

    public class Accumulator
    {
      public int Total { get; private set; }
      public void Add (params int[] ints)
      {
        bool success = false;
        int totalSnapshot = Total;
        try
        {
          foreach (int i in ints)
          {
            checked { Total += i; }
          }
          success = true;
        }
        finally
        {
          if (! success)
            Total = totalSnapshot;
        }
      }
    }

**异常的替代**

类似于int.Parse，函数可以通过使用返回类型或参数的向调用函数发送错误代码的方法来通知失败。尽管这可以处理简单与可观测的失败，但是当扩展到所有的错误时就会变得非常麻烦。而且这种方式也不可以扩展到非方法的函数，如操作或是属性。一个替代方法就是将错误代码放在一个共同的位置，从而调用堆栈中的所有函数都可以访问。尽管这种方式要求所有的函数都要参与到笨重的错误传播模式中，具有讽刺意味的是，其本身是倾向于错误的。

枚举与迭代器
------------

枚举
~~~~

枚举器是一系列值上的只读、前向光标。枚举器是一个实现了下列接口之一的对象：

-  System.Collections.IEnumerator
-  System.Collections.Generic.IEnumerator

foreach语句在一个迭代器对象上进行迭代。一个可迭代对象是一个序列的逻辑表示。他本身并不是一个光标，而是在其自身上生成光标的对象。一个可迭代的对象或者：

-  实现了IEnumerable或IEnumerable
-  有一个返回迭代器的名为GetEnumerator的方法

迭代模式如下：

.. code:: csharp

    class Enumerator   // Typically implements IEnumerator or IEnumerator<T>
    {
      public IteratorVariableType Current { get {...} }
      public bool MoveNext() {...}
    }

    class Enumerable   // Typically implements IEnumerable or IEnumerable<T>
    {
      public Enumerator GetEnumerator() {...}
    }

下面是使用foreach语句在单词beer中的字符上执行高级迭代的方式：

.. code:: csharp

    foreach (char c in "beer")
      Console.WriteLine (c);

下面是不使用foreach语句在beer的字符上执行迭代的低级方式：

.. code:: csharp

    using (var enumerator = "beer".GetEnumerator())
      while (enumerator.MoveNext())
      {
        var element = enumerator.Current;
        Console.WriteLine (element);
      }

如果迭代器实现了IDisposable，foreach语句同时扮演了using语句的角色，隐式销毁枚举器对象，就如同前面的例子一样。

集合初始化器
~~~~~~~~~~~~

我们可以一步实例化并装填可枚举对象。例如：

.. code:: csharp

    using System.Collections.Generic;
    ...
    List<int> list = new List<int> {1, 2, 3};

编译器将其翻译为如下代码：

.. code:: csharp

    using System.Collections.Generic;
    ...
    List<int> list = new List<int>();
    list.Add (1);
    list.Add (2);
    list.Add (3);

这要求可枚举对象实现System.Collections.IEnumerable接口，并且拥有一个相应数目的参数用于调用的Add方法。

迭代器
~~~~~~

如果foreach语句是枚举器的消费者，那么迭代器就是枚举器的生产者。在下面的示例中，我们使用一个枚举器来返回一个Fibonacci数字序列：

.. code:: csharp

    using System;
    using System.Collections.Generic;
    class Test
    {
      static void Main()
      {
        foreach (int fib in Fibs(6))
          Console.Write (fib + "  ");
      }
      static IEnumerable<int> Fibs (int fibCount)
      {
        for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
        {
          yield return prevFib;
          int newFib = prevFib+curFib;
          prevFib = curFib;
          curFib = newFib;
        }
      }
    }

输出结果为

1 1 2 3 5 8

其中return语句表示“这是你要求我由该方法返回的值”，yield
return语句表示“这是你要求我由该枚举器获得的下一个元素”。在每次执行yeild语句时，控制权返回给调用者，但是调用的状态依然被维护，所以一旦调用者枚举下一个元素，方法就可以继续执行。状态的生命周期被绑定到枚举器，从而当调用者完成枚举时，状态不可以被释放。

迭代器语义
~~~~~~~~~~

迭代器是一个包含一个或是多个yield语句的方法，属性或索引器。迭代器必须返回下列四个接口之一（否则，编译器会生成错误）：

.. code:: csharp

    // Enumerable interfaces
    System.Collections.IEnumerable
    System.Collections.Generic.IEnumerable<T>
    // Enumerator interfaces
    System.Collections.IEnumerator
    System.Collections.Generic.IEnumerator<T>

依据是否返回一个可枚举的接口还是一个枚举器接口，迭代器具有不同的语义。我们会在第7章进行详细描述。

多个yield语句也是可以的。例如：

.. code:: csharp

    class Test
    {
      static void Main()
      {
        foreach (string s in Foo())
          Console.WriteLine(s);         // Prints "One","Two","Three"
      }
      static IEnumerable<string> Foo()
      {
        yield return "One";
        yield return "Two";
        yield return "Three";
      }
    }

**yield break**

yield
break语句表示迭代器块应尽早结束，而不返回更多的元素。我们可以将Foo进行如下修改进行演示：

.. code:: csharp

    static IEnumerable<string> Foo (bool breakEarly)
    {
      yield return "One";
      yield return "Two";
      if (breakEarly)
        yield break;
      yield return "Three";
    }

注意：在迭代器块中return语句是非法的－我们必须使用yield
break语句进行代替。

**迭代器与try/catch/finally块**

yield return语句不能出现在具有catch子句的try块中：

.. code:: csharp

    IEnumerable<string> Foo()
    {
      try { yield return "One"; }    // Illegal
      catch { ... }
    }

yield
return也不能出现在catch或是finally块中。这些限制是由于编译器必须将迭代器翻译为具有MoveNext，Current与Dispose成员的普通类的事实造成的，而翻译异常处理块将会非常复杂。

然而，我们可以在只有finally块的try块中yield：

.. code:: csharp

    IEnumerable<string> Foo()
    {
      try { yield return "One"; }    // OK
      finally { ... }
    }

当消费枚举器到达序列的结尾或是被销毁时，finally块中的代码会执行。如果我们及早中断，foreach语句会隐式销毁枚举器，这对于消费枚举器是一种安全的方式。当显式处理枚举器时，没有销毁而及早结束枚举器，避开finally块，这是一个陷阱。我们可以通过将枚举器的使用显式包围在using语句中来避免这一风险：

.. code:: csharp

    string firstElement = null;
    var sequence = Foo();
    using (var enumerator = sequence.GetEnumerator())
      if (enumerator.MoveNext())
        firstElement = enumerator.Current;

组合序列
~~~~~~~~

迭代器是高度可组合的。我们可以扩展我们的示例，这一次我们仅输出偶Fibonacci数字：

.. code:: csharp

    using System;
    using System.Collections.Generic;
    class Test
    {
      static void Main()
      {
        foreach (int fib in EvenNumbersOnly (Fibs(6)))
          Console.WriteLine (fib);
      }
      static IEnumerable<int> Fibs (int fibCount)
      {
        for (int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
        {
          yield return prevFib;
          int newFib = prevFib+curFib;
          prevFib = curFib;
          curFib = newFib;
        }
      }
      static IEnumerable<int> EvenNumbersOnly (IEnumerable<int> sequence)
      {
        foreach (int x in sequence)
          if ((x % 2) == 0)
            yield return x;
      }
    }

每个元素直到最后时刻才会进行计算－当被MoveNext()操作请求时。图4－1显示了每次的数据请求与数据输出。

.. figure:: csharp4_4.1.png
   :alt: csharp4_4.1.png

   csharp4\_4.1.png
迭代器的组合性在LINQ非常有用；我们会在第8章再次讨论该主题。

可空类型
--------

引用类型可以通过null引用来表示不存在的值。然而，值类型不能简单的表示空值。例如：

.. code:: csharp

    string s = null;       // OK, Reference Type
    int i = null;          // Compile Error, Value Type cannot be null

要在值类型中表示null，我们必须使用一个被称之为可空类型的特殊构建。可空类型是由值类型后跟？符号来表示的：

.. code:: csharp

    int? i = null;                     // OK, Nullable Type
    Console.WriteLine (i == null);     // True

Nullable Struct
~~~~~~~~~~~~~~~

T?翻译为System.Nullable。Nullable是一个轻量级的不可修改的结构，只有两个域，来表示Value与HasValue。System.Nullable的实质非常简单：

.. code:: csharp

    public struct Nullable<T> where T : struct
    {
      public T Value {get;}
      public bool HasValue {get;}
      public T GetValueOrDefault();
      public T GetValueOrDefault (T defaultValue);
      ...
    }

代码：

.. code:: csharp

    int? i = null;
    Console.WriteLine (i == null);              // True

翻译为：

.. code:: csharp

    Nullable<int> i = new Nullable<int>();
    Console.WriteLine (! i.HasValue);           // True

当HasValue为假时尝试获取Value会抛出InvalidOperationException。如果HasValue为真，GetValueOrDefault()会返回Value；否则，他会返回new
T()或是指定的自定义值。

T?的默认值为null。

隐式与显示的可空转换
~~~~~~~~~~~~~~~~~~~~

T到T?的转换是隐式的，而由T?到T的转换是显示的。例如：

.. code:: csharp

    int? x = 5;        // implicit
    int y = (int)x;    // explicit

显示转换直接等同于调用可空对象的Value属性。所以，如果HasValue为假，则会抛出InvalidOperationException。

装箱与拆箱可空类型
~~~~~~~~~~~~~~~~~~

当T?被装箱时，堆上的已装箱时包含T，而不是T?。这种优化是可行的，因为一个装箱时值已经是一个表示空的引用类型。

C#也许使用as操作的可空类型的拆箱。如果转换失败，结果为null：

.. code:: csharp

    object o = "string";
    int? x = o as int?;
    Console.WriteLine (x.HasValue);   // False

操作符提升
~~~~~~~~~~

Nullable结构并没有定义如<，>，甚至==这样的操作符。尽管如此，下面的代码会正确的编译与运行：

.. code:: csharp

    int? x = 5;
    int? y = 10;
    bool b = x < y;      // true

之所以能够起作用，是因为编译器由底层值类型借或是“提升”了小于操作符。类似的，他前面的比较表达式翻译为：

.. code:: csharp

    bool b = (x.HasValue && y.HasValue) ? (x.Value < y.Value) : false;

换句话说，如果x与y同时拥有值，他会使用int的小于操作符进行比较，否则会返回false。

操作符提升意味着我们可以在T?上使用T的操作符。为了提供特殊目的的空行为，我们可以为T?定义操作符，但是在大多数情况下，最后是依赖编译器自动为我们应用的语义可空逻辑。如下面的示例：

.. code:: csharp

    int? x = 5;
    int? y = null;
    // Equality operator examples
    Console.WriteLine (x == y);    // False
    Console.WriteLine (x == null); // False
    Console.WriteLine (x == 5);    // True
    Console.WriteLine (y == null); // True
    Console.WriteLine (y == 5);    // False
    Console.WriteLine (y != 5);    // True
    // Relational operator examples
    Console.WriteLine (x < 6);     // True
    Console.WriteLine (y < 6);     // False
    Console.WriteLine (y > 6);     // False
    // All other operator examples
    Console.WriteLine (x + 5);     // 10
    Console.WriteLine (x + y);     // null (prints empty line)

编译器会依据操作的类别执行不同的空逻辑。下面的章节会解释这些不同的规则。

**相等操作符（==与!=）**

提升的相等操作符像引用类型那样处理空值。这意味着两个空值是相等的：

.. code:: csharp

    Console.WriteLine (       null ==        null);   // True
    Console.WriteLine ((bool?)null == (bool?)null);   // True

而且：

-  如果一个操作数为null，则两个操作数不相等。
-  如查两个操作均不为null，则其Value会进行比较。

**关系操作符（<,<=,>=,>）**

关系操作符的作用原则是：比较空操作数是无意义的。这意味着将空值与另一个空值或是非空值进行比较都会返回false。

.. code:: csharp

    bool b = x < y;    // Translation:
    bool b = (x.HasValue && y.HasValue) ? (x.Value < y.Value) : false;
    // b is false (assuming x is 5 and y is null)

**所有其他操作符（+,-,\*,/,%,&,\|,^,<<,>>,+,++,--,!,~）**

当任意一个操作数为空时这些操作符都会返回空。这种模式对于SQL用户会比较熟悉：

.. code:: csharp

    int? c = x + y;   // Translation:
    int? c = (x.HasValue && y.HasValue)
             ? (int?) (x.Value + y.Value)
             : null;
    // c is null (assuming x is 5 and y is null)

其中的一个例外就是当在bool?上应用&与\|操作符时，我们会稍后进行讨论。

**混合可空与非可空操作符**

我们可以混合并匹配可空与非可空的类型（之所以如此是因为存在由T到T?的隐式转换）：

.. code:: csharp

    int? a = null;
    int b = 2;
    int? c = a + b;   // c is null - equivalent to a + (int?)b

bool?与&和\|操作符
~~~~~~~~~~~~~~~~~~

当提供bool?类型的操作数时，&与\|操作符会被看作未知值。所以，null \|
true为真，因为：

-  如果未知值为假，则结果为真。
-  如果未知值为真，则结果为真。

类似的，null &
false为假。这一行为对于SQL用户也许会很熟悉。下面的示例枚举了其他的组合：

.. code:: csharp

    bool? n = null;
    bool? f = false;
    bool? t = true;
    Console.WriteLine (n | n);    // (null)
    Console.WriteLine (n | f);    // (null)
    Console.WriteLine (n | t);    // True
    Console.WriteLine (n & n);    // (null)
    Console.WriteLine (n & f);    // False
    Console.WriteLine (n & t);    // (null)

空（Null）接合操作符
~~~~~~~~~~~~~~~~~~~~

??操作符是空接合操作符，而且可以同时用于可空类型与引用类型。他所表达的含义是“如果操作数非空，将其传递给我；否则，传递给我默认值。”例如：

.. code:: csharp

    int? x = null;
    int y = x ?? 5;        // y is 5
    int? a = null, b = 1, c = 2;
    Console.WriteLine (a ?? b ?? c);  // 1 (first non-null value)

??操作符等同于使用显式默认值调用GetValueOrDefault方法，所不同的是如果变量非空，则默认值的表达式就不会进行计算。

可空类型的应用场景
~~~~~~~~~~~~~~~~~~

可空类型最常见的一个应用场景就是表示未知的值。我们经常会在数据库编程中遇到，其中一个类被映射到一个具有可空列的数据表。如果这些列是字符串，则没有问题，因为在CLR中字符串是引用类型，可以为空。然而，大多数其他的SQL列类型映射到CLR结构类型，从而使得当将SQL映射到CLR时可空类型非常有用。例如：

.. code:: csharp

    // Maps to a Customer table in a database
    public class Customer
    {
      ...
      public decimal? AccountBalance;
    }

可空类型也可以用于表示有时被称作环境属性的后端域。环境属性如果为空则会返回其父亲的值。例如：

.. code:: csharp

    public class Row
    {
      ...
      Grid parent;
      Color? color;
      public Color Color
      {
        get { return color ?? parent.Color; }
        set { color = value == parent.Color ? (Color?)null : value; }
      }
    }

可空类型的替代品
~~~~~~~~~~~~~~~~

在可空类型成为C#语言的一部分之前，有许多策略来处理可空的值类型，由于历史原因其中的一些示例依然出现在.NET框架中。其中一个策略是指定一个特定的非空值为空值；例如字符串与数组。String.IndexOf方法会在没有查找字符时返回魔数-1：

.. code:: csharp

    int i = "Pink".IndexOf ('b');
    Console.WriteLine (i);         // ?1

然而，Array.IndexOf方法只有数据以0为起始索引时才会返回-1。更为通用的公式是IndexOf方法会返回比数组的最小边界小1的值。在下面的示例中，如果没有找到元素，则IndexOf方法会返回0：

.. code:: csharp

    Array a = Array.CreateInstance (typeof (string),
                                    new int[] {2}, new int[] {1});
    a.SetValue ("a", 1);
    a.SetValue ("b", 2);
    Console.WriteLine (Array.IndexOf (a, "c"));  // 0

指定一个“魔数”存在一系问题，原因如下：

-  他意味着每一个值类型具有不同的空值表示。相对应的，可空类型为所有的值类型提供了通用的模式。
-  也许并没有合理的特定值。前面示例中的-1也许并不会总适用。对于我们前面表示一个未知帐户的示例同样适用。
-  忘记测试魔数也许会导致不正确的值，而该不正确的值直到稍后运行时才会注意到。忘记测试空值上的HasValue值会抛出InvalidOperationException。
-  值为空的能力并没有在类型中捕获。类型交互程序的意图，允许编译器检测正确性，并且通过编译器强制一致的规则集合。

操作符重载
----------

操作符可以被重载来为自定义类型提供更为自然的语法。操作符重载特殊适用于表示非常基础的数据类型的自定义结构。例如，自定义的数值类型是进行操作符重载的理想选择。

下面的符号操作符可以进行重载：

.. code:: csharp

    + (unary) ? (unary) ! ? ++
    ?? + ? * /
    % & | ^ <<
    >> == != > <
    >= <=      

下列的操作符也可以进行重载：

-  隐式与显式转换（使用implicit与explicit关键字）
-  true与false

下列操作符可以进行间接重载：

-  组合赋值操作符（例如，+=，/=）被重写的非组合
   操作符进行隐式重载（例如，+，/）。
-  条件操作符&&与\|\|被重写的位操作符&与\|进行隐式重载。

操作符函数
~~~~~~~~~~

操作符是通过声明一个操作符函数来进行重载的。操作符函数具有下列规则：

-  函数名是由operator关键字后跟操作符符号来指定的。
-  操作符函数必须被标记为static与public。
-  操作符函数的参数表示操作数。
-  操作符函数的结果表示表达式的结果。
-  至少有一个操作符必须为在其中声明操作符函数的类型。

在下面的示例中，我们定义一个名为Note的结构表示音乐笔记，然后重载+操作符：

.. code:: csharp

    public struct Note
    {
      int value;
      public Note (int semitonesFromA) { value = semitonesFromA; }
      public static Note operator + (Note x, int semitones)
      {
        return new Note (x.value + semitones);
      }
    }

重载可以使得我们将int添加到Note：

.. code:: csharp

    Note B = new Note (2);
    Note CSharp = B + 2;

重载赋值操作符会自动支持相应的结合赋值操作符。在我们的示例中，因为我们重载了+，我们也可以使用+=：

CSharp += 2;

重载相等与比较操作符
~~~~~~~~~~~~~~~~~~~~

相等与比较操作符会在编写结构，而很少在编写类时进行重载。重载相等与比较操作符具有特殊的规则与职责，我们会在第6章中进行解释。

这些规则总结如下：

-  成对：C#编译器强制逻辑对操作符同时被定义。这些操作符是(== !=)，(<
   >)与(<= >=)。
-  Equals与GetHashCode：在大多数情况下，如果我们重载了（==）与（!=）,为了获得有意义的行为，我们将会需要重载定义在object上的Equals与GetHashCode方法。如果我们没有这样做，C#编译器会给出警告。
-  IComparable与IComparable：如果我们重载了（< >）与（<=
   >=），我们应实现IComparable与IComparable。

自定义隐式与显式转换
~~~~~~~~~~~~~~~~~~~~

隐式与显式转换是可重载的操作符。这些转换通常被重载从而使得强相关类型之间的转换（例如数值类型）一致与自然。

要在弱相关类型之间进行转换，下面的策略更为适用：

-  编写一个带有要转换类型作为参数的构造函数。
-  编写ToXXX与（静态）FromXXX方法在类型之间进行转换。

正如在类型讨论中所解释的，隐式转换背后的基本原理是在转换过程中他们可以保证成功且不丢失信息。相对应的，显式转换应要求或者运行确定转换是否成功或者转换过程中信息是否丢失。

在下面的示例中，我们在音乐Note类型与double类型之间定义转换：

.. code:: csharp

    ...
    // Convert to hertz
    public static implicit operator double (Note x)
    {
      return 440 * Math.Pow (2, (double) x.value / 12 );
    }
    // Convert from hertz (accurate to the nearest semitone)
    public static explicit operator Note (double x)
    {
      return new Note ((int) (0.5 + 12 * (Math.Log (x/440) / Math.Log(2) ) ));
    }
    ...
    Note n = (Note)554.37;  // explicit conversion
    double x = n;           // implicit conversion

重载true与false
~~~~~~~~~~~~~~~

true与false操作符仅在实质上为布尔类型，但是并没有到bool转换的情况中。一个示例便是实现三态逻辑的类型：通过重载true与false，这样的类型可以无缝的处理条件语句与操作符-也就是if，do，while，for，&&，\|\|，?:。System.Data.SqlTypes.SqlBoolean结构提供了这种功能。例如：

.. code:: csharp

    SqlBoolean a = SqlBoolean.Null;
    if (a)
      Console.WriteLine ("True");
    else if (!a)
      Console.WriteLine ("False");
    else
      Console.WriteLine ("Null");
    OUTPUT:
    Null

下面的代码是演示true与false操作符所必须的SqlBoolean部分的重新实现：

.. code:: csharp

    public struct SqlBoolean
    {
      public static bool operator true (SqlBoolean x)
      {
        return x.m_value == True.m_value;
      }
      public static bool operator false (SqlBoolean x)
      {
        return x.m_value == False.m_value;
      }
      public static SqlBoolean operator ! (SqlBoolean x)
      {
        if (x.m_value == Null.m_value)  return Null;
        if (x.m_value == False.m_value) return True;
        return False;
      }
      public static readonly SqlBoolean Null =  new SqlBoolean(0);
      public static readonly SqlBoolean False = new SqlBoolean(1);
      public static readonly SqlBoolean True =  new SqlBoolean(2);
      private SqlBoolean (byte value) { m_value = value; }
      private byte m_value;
    }

扩展方法
--------

扩展方法可以使得一个已存在的类型使用新方法进行扩展，而无需修改原始类型的定义。扩展方法就是静态类的静态方法，其中this修饰符用于第一个参数。第一个参数的类型将是要扩展的类型。例如：

.. code:: csharp

    public static class StringHelper
    {
      public static bool IsCapitalized (this string s)
      {
        if (string.IsNullOrEmpty(s)) return false;
        return char.IsUpper (s[0]);
      }
    }

IsCapitialized扩展方法可以像在字符串上调用实例方法一样进行调用，例如：

.. code:: csharp

    Console.WriteLine ("Perth".IsCapitalized());

当编译时，扩展方法将会翻译回普通的静态方法调用：

Console.WriteLine (StringHelper.IsCapitalized ("Perth"));

类似的翻译同样适用于：

.. code:: csharp

    arg0.Method (arg1, arg2, ...);              // Extension method call
    StaticClass.Method (arg0, arg1, arg2, ...); // Static method call

接口也可以进行扩展：

.. code:: csharp

    public static T First<T> (this IEnumerable<T> sequence)
    {
      foreach (T element in sequence)
        return element;
      throw new InvalidOperationException ("No elements!");
    }
    ...
    Console.WriteLine ("Seattle".First());   // S

扩展方法是在C#3.0中被加入的。

扩展方法链
~~~~~~~~~~

类似于实例方法，扩展方法提供了一个简便的方法来形成函数链。考虑下面的两个函数：

.. code:: csharp

    public static class StringHelper
    {
      public static string Pluralize (this string s) {...}
      public static string Capitalize (this string s) {...}
    }

x与y是相同的，且都被计算为"Sausages"，但是x使用扩展方法，而y使用静态方法：

.. code:: csharp

    string x = "sausage".Pluralize().Capitalize();
    string y = StringHelper.Capitalize (StringHelper.Pluralize ("sausage"));

不明确与解析
~~~~~~~~~~~~

**名字空间**

扩展方法只当其类位于作用域中也可以被访问，通常是使用被引入的名字空间。考虑下面示例中的IsCapitialized扩展方法：

.. code:: csharp

    using System;
    namespace Utils
    {
      public static class StringHelper
      {
        public static bool IsCapitalized (this string s)
        {
          if (string.IsNullOrEmpty(s)) return false;
          return char.IsUpper (s[0]);
        }
      }
    }

要使用IsCapitialized，为了避免编译时错误，下面的程序必须引入Utils：

.. code:: csharp

    namespace MyApp
    {
      using Utils;
      class Test
      {
        static void Main()
        {
          Console.WriteLine ("Perth".IsCapitalized());
        }
      }
    }

**扩展方法与实例方法**

与扩展方法相比，任意兼容的实例方法具有较高的优先级。在下面的示例中，Test的Foo方法总是优先调用-即使使用int类型的参数x调用也是如此：

.. code:: csharp

    class Test
    {
      public void Foo (object x) { }    // This method always wins
    }
    static class Extensions
    {
      public static void Foo (this Test t, int x) { }
    }

在这种情况下，调用扩展方法的唯一方法就是通过普通的静态语法；换句话说，也就是Extensions.Foo(...)。

**扩展方法与扩展方法**

如果两个扩展方法具有相同的签名，为了避免方法调用的不确定性，扩展方法必须像普通的静态方法那样进行调用。然而，如果一个扩展方法具有更为特殊的参数，则更为特殊的方法具有较高的优先级。

为了进行演示，考虑下面的两个类：

.. code:: csharp

    static class StringHelper
    {
      public static bool IsCapitalized (this string s) {...}
    }
    static class ObjectHelper
    {
      public static bool IsCapitalized (this object s) {...}
    }

下面的代码调用StringHelper的IsCapitialized方法：

bool test1 = "Perth".IsCapitalized();

要调用ObjectHelper的IsCapitialized方法，我们必须显式指定：

bool test2 = (ObjectHelper.IsCapitalized ("Perth"));

具体类型被认为比接口更为特殊。

接口上的扩展方法
~~~~~~~~~~~~~~~~

扩展方法可以应用于接口：

.. code:: csharp

    using System;
    using System.Collections.Generic;
    static class Test
    {
      static void Main()
      {
        string[] strings = { "a", "b", null, "c"};
        foreach (string s in strings.StripNulls())
          Console.WriteLine (s);
      }
      static IEnumerable<T> StripNulls<T> (this IEnumerable<T> seq)
      {
        foreach (T t in seq)
          if (t != null)
            yield return t;
      }
    }

匿名类型
--------

匿名类型是编译器即时创建来存储值集合的简单类。要创建一个匿名类，使用new关键字后跟对象初始化器，指定类型将要包含的属性与值。例如：

var dude = new { Name = "Bob", Age = 23 };

编译器会将其翻译为如下代码：

.. code:: csharp

    internal class AnonymousGeneratedTypeName
    {
      private string name;  // Actual field name is irrelevant
      private int    age;   // Actual field name is irrelevant
      public AnonymousGeneratedTypeName (string name, int age)
      {
        this.name = name; this.age = age;
      }
      public string  Name { get { return name; } }
      public int     Age  { get { return age;  } }
      // The Equals and GetHashCode methods are overridden (see Chapter 6).
      // The ToString method is also overridden.
    }
    ...
    var dude = new AnonymousGeneratedTypeName ("Bob", 23);

我们必须使用var关键字来引用匿名类型，因为他并没有名字。

匿名类型的属性可以由标签符本身的表达式进行推断。例如：

.. code:: csharp

    int Age = 23;
    var dude = new { Name = "Bob", Age, Age.ToString().Length };

等同于：

var dude = new { Name = "Bob", Age = Age, Length = Age.ToString().Length
};

如果在相同的程序集内部声明的两个匿名类型实例，如果其元素的命名与类型相同，则他们具有相同的底层类型：

.. code:: csharp

    var a1 = new { X = 2, Y = 4 };
    var a2 = new { X = 2, Y = 4 };
    Console.WriteLine (a1.GetType() == a2.GetType());   // True

另外，Equals方法被重载来执行相等比较：

.. code:: csharp

    Console.WriteLine (a1 == a2);         // False
    Console.WriteLine (a1.Equals (a2));   // True

我们可以像下面这样创建匿名类型数组：

.. code:: csharp

    var dudes = new[]
    {
      new { Name = "Bob", Age = 30 },
      new { Name = "Tom", Age = 40 }
    };

匿名类型主要用于LINQ查询中，并且是在C#3.0中加入的。

动态绑定
--------

动态绑定将绑定-解析类型，成员与操作的过程-由编译时推迟到运行时。动态绑定对于对于在编译时我们知道存在特定的函数，成员或操作，但是编译器并不知道的情况十分有用。这通常发生在我们与动态语言（例如IronPython）或COM进行交互或是我们使用反射的场景中。

动态类型是使用环境关键字dynamic进行声明的：

.. code:: csharp

    dynamic d = GetSomeObject();
    d.Quack();

动态类型告诉编译器不要紧张。我们期望d的运行时类型具有一个Quack方法。我们不能静态的证明。因为d是动态的，编译器将Quack绑定到d的过程推迟到运行时。要理解这意味着什么需要在静态绑定与动态绑定之间进行区分。

静态绑定与动态绑定
~~~~~~~~~~~~~~~~~~

规范绑定的示例可以是当编译表达式时将名字映射到特定的函数。要编译下面的表达式，编译器需要找到名为Quack方法的实现：

.. code:: csharp

    d.Quack();

让我们假定d的静态类型是Duck：

.. code:: csharp

    Duck d = ...
    d.Quack();

在最简单的情况下，编译器通过在Duck上查找名为Quack的无参数方法执行绑定。如果查找失败，编译器会将其搜索扩展到带有可选参数的方法，Duck的基类的方法，以及使用Duck作为其第一个参数的扩展方法。如果没有找到匹配的方法，我们就会得到编译时错误。无论最终的方法是什么，底线就是绑定是由编译器完成的，而且绑定最终依赖于静态已知的操作数类型（在这个例子中为d）。这使其成为静态绑定。

现在我们将d的静态类型修改为object：

.. code:: csharp

    object d = ...
    d.Quack();

调用Quack会向我们给出错误错误，尽管在d中存储的值可以包含一个名为Quack的方法，编译器并不知道这一点，因为他所拥有的唯一信息就是变量的类型，在这个例子中为object。但是现在我们将d的静态类型修改为dynamic：

.. code:: csharp

    dynamic d = ...
    d.Quack();

dynamic类型类似于object-他们并没有关于类型的描述。区别在于前者可以使得我们在编译时并不知情的情况下进行使用。动态对象会依据其运行时类型在运行时进行绑定，而是不依赖其编译时类型。当编译器遇到一个动态绑定的表达式时（通常是包含dynamic类型值的表达式），他仅是打包表达式，从而绑定可以在稍后的运行时完成。

在运行时，如果一个动态对象实现了IDynamicMetaObjectProvider，该接口可以用来执行绑定。如果没有，绑定几乎与编译器已知运态对象的运行时类型相同的方式完成。这两种相对的绑定方式就被称为自定义绑定与语言绑定。

自定义绑定
~~~~~~~~~~

当动态对象实现了IDynamicMetaObjectProvider(IDMOP)时会发生自定义绑定。尽管我们可以在使用C#编写的类型上实现IDMOP，而且这样做也非常有用，但是更为通常的情况是我们必须由一个在DLR的.NET中实现的动态语言中获取IDMOP对象，例如IronPython或IronRuby。来自这些语言的对象通过直接控制在这些对象上执行的操作的含义的方式隐式实现IDMOP。

我们将会在第20章中更详细的讨论自定义绑定器，但是现在我们将会编写一个简单的来演示该特性：

.. code:: csharp

    using System;
    using System.Dynamic;
    public class Test
    {
      static void Main()
      {
        dynamic d = new Duck();
        d.Quack();                  // Quack method was called
        d.Waddle();                 // Waddle method was called
      }
    }
    public class Duck : DynamicObject
    {
      public override bool TryInvokeMember (
        InvokeMemberBinder binder, object[] args, out object result)
      {
        Console.WriteLine (binder.Name + " method was called");
        result = null;
        return true;
      }
    }

Duck类实际上并没有Quack方法。相反，他使用自定义绑定来解析所有的方法调用。

语言绑定
~~~~~~~~

语言绑定发生在动态对象并没有实现IDynamicMetaObjectProvider的情况。当处理设计并不完美的类型或是继承.NET类型系统局限性的时候语言绑定十分有用（我们会在第20章探讨详细的应用场景）。当使用数值类型时的一个典型问题是他们并没有共同的接口。我们已了解方法可以动态绑定；对于操作同样如此：

.. code:: csharp

    static dynamic Mean (dynamic x, dynamic y)
    {
      return (x + y) / 2;
    }
    static void Main()
    {
      int x = 3, y = 4;
      Console.WriteLine (Mean (x, y));
    }

这样做的好处很明显-我们并不需要为每一个数值类型处理重复的代码。然而，我们丢失了静态类型的安全性，我们将会遇到运行时异常而不是编译时错误的风险。

通过设计，语言运行时绑定的行为尽可能像静态绑定一样简单，具有在编译时就已知的动态对象的运行时类型。在我们前面的示例中，如果我们硬编码Mean来处理int类型，我们程序的行为依然是相同的。静态与动态绑定之间最值得注意的区别就在于扩展方法。

RuntimeBinderException
~~~~~~~~~~~~~~~~~~~~~~

如果一个方法绑定失败，则会抛出RuntimeBinderException。我们可以将其认为是运行时的编译时错误。

.. code:: csharp

    dynamic d = 5;
    d.Hello();                  // throws RuntimeBinderException

之所以抛出该异常是因为int类型并没有Hello方法。

运行时的动态表示
~~~~~~~~~~~~~~~~

在dynamic与object对象之间存在深度的等同关系。运行时会将下面的表达式认为true：

typeof (dynamic) == typeof (object)

该原则同样适用于构建类型与数组类型：

.. code:: csharp

    typeof (List<dynamic>) == typeof (List<object>)
    typeof (dynamic[]) == typeof (object[])

类似于对象引用，动态引用可以指向任意类型的对象（除了指针类型）：

.. code:: csharp

    dynamic x = "hello";
    Console.WriteLine (x.GetType().Name);  // String
    x = 123;  // No error (despite same variable)
    Console.WriteLine (x.GetType().Name);  // Int32

由结构上来说，在对象引用与动态引用之间并没有区别。动态引用仅是简单的允许其所指对象上的动态操作。我们可以由object转换为dynamic来执行我们所希望的动态操作：

.. code:: csharp

    object o = new System.Text.StringBuilder();
    dynamic d = o;
    d.Append ("hello");
    Console.WriteLine (o);   // hello

动态转换
~~~~~~~~

dynamic可以隐式由其他类型转换或是转换为其他类型：

.. code:: csharp

    int i = 7;
    dynamic d = i;
    long j = d;        // No cast required (implicit conversion)

为了使得转换能够成功，动态类型的运行时类型必须隐式可转换为目标静态类型。前面的示例之所以工作是因为int可以隐式转换为long。

下面的示例会抛出RuntimeBinderException，因为int并不能隐式转换为short：

.. code:: csharp

    int i = 7;
    dynamic d = i;
    short j = d;      // throws RuntimeBinderException

var与dynamic
~~~~~~~~~~~~

var与dynamic类型表面上相似，但是区别十分明显：

var表明“让编译器推测类型”

dynamic表明“让运行时推测类型”

如下所示：

.. code:: csharp

    dynamic x = "hello";  // Static type is dynamic, runtime type is string
    var y = "hello";      // Static type is string, runtime type is string
    int i = x;            // Runtime error
    int j = y;            // Compile-time error

使用var声明的变量的静态类型可以为dynamic：

.. code:: csharp

    dynamic x = "hello";
    var y = x;            // Static type of y is dynamic
    int z = y;            // Runtime error

动态表达式
~~~~~~~~~~

域，属性，方法，事件，构造器，索引器，操作符以及转换都可以被称之为动态的。

尝试使用一个具有void返回类型的动态表达式的结果是被禁止的-就如同静态类型表达式。区别在于错误发生在运行时：

.. code:: csharp

    dynamic list = new List<int>();
    var result = list.Add (5);         // RuntimeBinderException thrown

调用动态操作数的表达式通常本身是动态的，因为缺少类型信息的影响是级联的：

.. code:: csharp

    dynamic x = 2;
    var y = x * 3;       // Static type of y is dynamic

对于该原则有一些明显的例外。首先将一个动态表达式转换为静态类型会导致一个静态表达式：

.. code:: csharp

    dynamic x = 2;
    var y = (int)x;      // Static type of y is int

其次，构造器调用总会得到静态表达式-即使使用动态参数进行调用。在这个示例中，x是静态类型StringBuilder：

.. code:: csharp

    dynamic capacity = 10;
    var x = new System.Text.StringBuilder (capacity);

另外，包含动态参数的表达式是静态的具有一些边界条件，包括向数组以及委托创建表达式传递一个索引。

无动态接收者的动态调用
~~~~~~~~~~~~~~~~~~~~~~

正规的dynamic使用涉及到一个动态接收者。这意味着动态对象是动态函数调用接收者：

.. code:: csharp

    dynamic x = ...;
    x.Foo();          // x is the receiver

然而，我们也可以使用动态参数调用静态已知的函数。这样的调用服从动态重载解析，可以包括：

-  静态方法
-  实例构造器
-  具有静态已知类型接收者上的实例方法。

在下面的示例中，进行动态绑定的特定Foo依赖于动态参数的运行时类型：

.. code:: csharp

    class Program
    {
      static void Foo (int x)    { Console.WriteLine ("1"); }
      static void Foo (string x) { Console.WriteLine ("2"); }
      static void Main()
      {
        dynamic x = 5;
        dynamic y = "watermelon";
        Foo (x);                // 1
        Foo (y);                // 2
      }
    }

因为并没有涉及到动态接收者，编译就会静态执行一个基本测试来确认动态调用是否会成功。他会检测到存在一个带有正确名字与参数数目的函数。如果没有查找到相应的函数，我们就会得到编译时错误。例如：

.. code:: csharp

    class Program
    {
      static void Foo (int x)    { Console.WriteLine ("1"); }
      static void Foo (string x) { Console.WriteLine ("2"); }
      static void Main()
      {
        dynamic x = 5;
        Foo (x, x);          // Compiler error - wrong number of parameters
        Fook (x);            // Compiler error - no such method name
      }
    }

动态表达式中的静态类型
~~~~~~~~~~~~~~~~~~~~~~

很明显，动态类型用在动态绑定中。然而静态类型也会用在-如果可能-动态绑定中则不是这样明显。考虑下面的示例：

.. code:: csharp

    class Program
    {
      static void Foo (object x, object y) { Console.WriteLine ("oo"); }
      static void Foo (object x, string y) { Console.WriteLine ("os"); }
      static void Foo (string x, object y) { Console.WriteLine ("so"); }
      static void Foo (string x, string y) { Console.WriteLine ("ss"); }
      static void Main()
      {
        object o = "hello";
        dynamic d = "goodbye";
        Foo (o, d);               // os
      }
    }

Foo(o,d)调用是动态绑定的，因为其中一个参数d是dynamic。但是因为o是静态已知的，绑定-尽管动态发生-将会使用静态类型。在这个示例中，由于o的静态类型与d的运行时类型，重载解析将会选择Foo的第二个实现。换句话说，编译器是“尽可能静态”。

不可调用的函数
~~~~~~~~~~~~~~

有一些函数是不能动态调用的。我们不能调用：

-  扩展方法（通过扩展方法语法）
-  接口上的成员，如果我们需要转换为该接口
-  由子类所隐藏的基类成员

理解为什么会这样对于理解动态绑定是十分有用的。

动态绑定需要两方面信息：要调用的函数名，以及调用函数所在的对象。然而，三个不可调用场景中的每一个都涉及到只在编译时已知的额外类型。对于C#5.0，并没有动态指定这些额外类型的方法。

当调用扩展方法时，额外类型是隐式的。这个额外类型就是扩展方法定义所在的静态类。在我们的源码中指定using指令，编译器会进行相应的查找。这会使得扩展方法成为仅是编译时概念，因为using指令会在编译时去除（在绑定过程中将单个名字映射为名字空间修饰的名字之后）。

当通过接口调用成员时，我们通过隐式或是显式转换指定额外的类型。我们也许会在两个应用场景下执行这样的操作：当调用显式实现的接口成员以及当调用对于其他程序为interal的类型中的接口成员时。我们可以使用下面两个类型来演示前者：

.. code:: csharp

    interface IFoo   { void Test();        }
    class Foo : IFoo { void IFoo.Test() {} }

要调用Test方法，我们必须转换为IFoo接口。这通过静态类型很容易实现：

.. code:: csharp

    IFoo f = new Foo();   // Implicit cast to interface
    f.Test();

现在考虑动态类型的情况：

.. code:: csharp

    IFoo f = new Foo();
    dynamic d = f;
    d.Test();             // Exception thrown

隐式转换告诉编译器将后续f上的成员调用绑定到IFoo而不是Foo，换句话说，通过IFoo接口的镜头来查看对象。然而，该镜头会在运行时丢失，所以DLR不能完成绑定。如下所示：

.. code:: csharp

    Console.WriteLine (f.GetType().Name);    // Foo

类似的情形也出现在调用隐藏的基类成员时：我们必须通过转换或是base关键字来指定额外的类型-而这些额外的类型会在运行时丢失。

属性（Attributes）
------------------

我们已经了解了带有修改的程序的属性代码元素的概念,例如virtual或ref。这些结构是语言内建的。属性是用于向代码元素（程序集，类型，成员，返回值，参数以及泛型类型参数）添加自定义信息的可扩展机制。这种可扩展性对于与类型系统深度集成的服务十分有用，而无需C#语言中的特殊关键字或结构。

属性的一个良好应用场景就是序列化－将任意对象转换为特定格式或是由特定格式转换为任意对象的过程。在这个应用场景中，域上的属性可以指定C#的域表示与域的格式化表示之间的转换。

属性类
~~~~~~

属性是通过由抽象类System.Attribute继承（直接或间接）的类所定义的。要将属性关联到代码元素，在代码元素之间在方括号中指定属性的类型名。例如，下面的代码将ObsoleteAttribute关联到Foo类：

.. code:: csharp

    [ObsoleteAttribute]
    public class Foo {...}

这个属性会由编译器所识别，并且如果被标记为obsolete的类型或成员被引用时会导致编译器警告。通过约定，所有的属性类型以单词Attribute结尾。C#会识别这一点，并且当关联属性时可以允许我们忽略后缀：

.. code:: csharp

    [Obsolete]
    public class Foo {...}

ObsoleteAttribute是声明在System名字空间中的类型，其声明如下：

public sealed class ObsoleteAttribute : Attribute {...}

C#语言与.NET框架包含大量的预定义属性。我们会在第19章中描述如何编写我们自己的属性。

命名与位置属性参数
~~~~~~~~~~~~~~~~~~

属性可以带有参数。在下面的示例中，我们将XmlElementAttribute应到某个类。这些属性会告诉XML序列化器（位于System.Xml.Serialization中）一个对象如何表示为XML并且接受多个属性参数。下面的属性会将CustomerEntity类映射到名为Customer的XML元素上，属于http://oreilly.com
名字空间：

.. code:: csharp

    [XmlElement ("Customer", Namespace="http://oreilly.com")]
    public class CustomerEntity { ... }

属性参数最终为两类之一：位置或命名。在前面的示例中，第一个参数是参数；第二个是命名参数。位置参数对应于属性类型的公开构造器的参数。命名参数对应于属性类型上的公开域或公开属性。

当指定一个属性时，我们必须包含与属性构造器中的一个相对应的位置参数。命名参数是可选的。

在第19章，我们会描述相应的可用参数类型与规则。

属性目标
~~~~~~~~

隐式的，属性的目标是紧跟属性后面的代码元素，通常是一个类型或类型成员。然而我们也可以将属性关联到程序集。这需要我们显式指定属性的目标。

下面是一个使用CLSCompliant属性来为整个程序集指定CLS兼容的示例：

[assembly:CLSCompliant(true)]

指定多个属性
~~~~~~~~~~~~

可以为单个代码元素指定多个属性。每一个属性可以位于同一个花括号对中（通过逗号分隔），也可以位于单独的花括号对中（或是两者的组合）。下面的三个示例在语义上是相同的：

.. code:: csharp

    [Serializable, Obsolete, CLSCompliant(false)]
    public class Bar {...}
    [Serializable] [Obsolete] [CLSCompliant(false)]
    public class Bar {...}
    [Serializable, Obsolete]
    [CLSCompliant(false)]
    public class Bar {...}

不安全代码与指针
----------------

C#通过标记为unsafe的代码块内的指针并使用/unsafe编译选择支持直接的内在操作。指针类型对于与C
API的交互非常有用，但也可以用于访问托管堆之外的内在或是由于性能原因。

指针基础
~~~~~~~~

对于每一个值类型或是指针类型V，都有一个相对应的指针类型V\*。指针实例存储变量的地址。指针类型可以（不安全的）转换为任意其他的指针类型。主要的指针操作符有：

+----------+---------------------------------------------------------+
| 操作符   | 含义                                                    |
+----------+---------------------------------------------------------+
| &        | 地址操作符返回指向变量地址的指针                        |
+----------+---------------------------------------------------------+
| \*       | 解引用操作符返回指针地址住的变量                        |
+----------+---------------------------------------------------------+
| '->'     | 指向成员操作符是一个语法缩写，也就是x->y等同于(\*x).y   |
+----------+---------------------------------------------------------+

不安全代码
~~~~~~~~~~

通过使用unsafe关键字标记类型，类型成员或是语句块，我们可以使用指针类型并且在作用域内的内存上执行C++风格的操作。下面是一个使用指针来快速处理位图的示例：

.. code:: csharp

    unsafe void BlueFilter (int[,] bitmap)
    {
      int length = bitmap.Length;
      fixed (int* b = bitmap)
      {
        int* p = b;
        for (int i = 0; i < length; i++)
          *p++ &= 0xFF;
      }
    }

不安全代码的运行速度要快于相对应的安全实现。在这个示例中，代码本可以要求一个带有数组索引与边界检测的嵌套循环。不安全的C#方法同时要快于调用外部C函数，因为并没有离开托管执行环境的开销。

fixed语句
~~~~~~~~~

fixed语句用来固定某个托管对象，例如前面示例中的位图。在程序的执行过程中，会在堆上分配与释放多个对象。为了避免不必要的内存碎片，垃圾器会移动对象。如果对象的地址在引用时发生变化，则指向对象则是无用的，所以fixed语句通知垃圾收集器固定某个对象而不要移动。这也许会对运行时的效率产生影响，所以固定块应仅在需要时使用，并且避免在固定块内进行堆分配。

在fixed语句内，我们可以获得一个指向任意值类型，值类型数组或是字符串的指针。在数组与字符串的情况下，指针实际上指向第一个元素，其也是一个值类型。

在内联引用类型内声明的值类型要求引用类型是固定的，如下所示：

.. code:: csharp

    class Test
    {
      int x;
      static void Main()
      {
        Test test = new Test();
        unsafe
        {
           fixed (int* p = &test.x)   // Pins test
           {
             *p = 9;
           }
           System.Console.WriteLine (test.x);
        }
      }
    }

我们会在第25章中进一步讨论fixed语句。

指向成员操作符
~~~~~~~~~~~~~~

除了&与\*操作符，C#同时提供了C++风格的->操作符，该操作符可以用在结构上：

.. code:: csharp

    struct Test
    {
      int x;
      unsafe static void Main()
      {
        Test test = new Test();
        Test* p = &test;
        p->x = 9;
        System.Console.WriteLine (test.x);
      }
    }

数组
~~~~

**stackallow关键字**

我们可以使用stackallow关键字显式在栈上进行内存分配。因为他是在栈上分配的，其生命周期被限制为方法的生命周期，就如同其他的局部变量。块可以使用[]操作符来索引内存：

.. code:: csharp

    int* a = stackalloc int [10];
    for (int i = 0; i < 10; ++i)
       Console.WriteLine (a[i]);   // Print raw memory

**固定尺寸缓冲区**

fixed关键字还有另一个用处，可以在结构内创建固定尺寸的缓冲区：

.. code:: csharp

    unsafe struct UnsafeUnicodeString
    {
      public short Length;
      public fixed byte Buffer[30];   // Allocate block of 30 bytes
    }
    unsafe class UnsafeClass
    {
      UnsafeUnicodeString uus;
      public UnsafeClass (string s)
      {
        uus.Length = (short)s.Length;
        fixed (byte* p = uus.Buffer)
          for (int i = 0; i < s.Length; i++)
            p[i] = (byte) s[i];
      }
    }
    class Test
    {
      static void Main() { new UnsafeClass ("Christian Troy"); }
    }

fixed关键字也可以用在固定包含缓冲区的堆上的对象（为UnsafeClass实例）。所以，fixed意味着两种不同的内容：尺寸固定与位置固定。这两者通常组合使用，因为固定尺寸的缓冲区一定位于固定的位置。

void\*
~~~~~~

void指针（void\*）并没有对底层数据的类型进行任何假定，并且对于处理原始内存非常有用。任意的指针类型都可以隐式转换为void\*。void\*不能被解引用，并且不能在void指针上执行算术操作。

例如：

.. code:: csharp

    class Test
    {
      unsafe static void Main()
      {
        short[ ] a = {1,1,2,3,5,8,13,21,34,55};
          fixed (short* p = a)
          {
            //sizeof returns size of value-type in bytes
            Zap (p, a.Length * sizeof (short));
          }
        foreach (short x in a)
          System.Console.WriteLine (x);   // Prints all zeros
      }
      unsafe static void Zap (void* memory, int byteCount)
      {
        byte* b = (byte*) memory;
          for (int i = 0; i < byteCount; i++)
            *b++ = 0;
      }
    }

指向非托管代码的指针
~~~~~~~~~~~~~~~~~~~~

指针对于访问托管堆外的数据（例如当与C
DLL或是COM交互时），或是处理并没有位于主存中的数据（例如图像内存或是嵌入式设备上的存储介质）也十分有用。

预处理器指令
------------

预处理器指令为编译器提供关于代码区域的额外信息。最常见的预处理器指令是条件指令，条件指令提供了一种方法由编译时包含或是排除代码区域。例如：

.. code:: csharp

    #define DEBUG
    class MyClass
    {
      int x;
      void Foo()
      {
        # if DEBUG
        Console.WriteLine ("Testing: x = {0}", x);
        # endif
      }
      ...
    }

在这个类中，Foo中语句的编译是与DEBUG符号是否存在条件相关的。如果我们移除DEBUG符号，则该语句不会被编译。预处器符号可以在一个源文件中进行定义，并且可以使用/define:symbol命令行选项将其传递给编译器。

类似于#if与#elif指令，我们可以在多个符号上使用\|\|，&&，!操作符来执行或，与以及非操作。下面的指令会指示编译器如果TESTMODE符号被定义且DEBUG符号没有被定义时包含后面的代码：

.. code:: csharp

    #if TESTMODE && !DEBUG
      ...

然而要记住，我们并不是在构建普通的C#表达式，我们操作所依赖的符号与变量－静态或其他－并没有直接的关系。

#error与#warning符号通过指定编译器在提供未需要的编译符号时生成警告或错误的方来避免条件指令的误用。表4－1列出了预处理器指令。

+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| 预处理器指令                           | 动作                                                                                                        |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #define symbol                         | 定义symbol                                                                                                  |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #undef symbol                          | 取消symbol定义                                                                                              |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #if symobl [operator symbol2]...       | 测试操作符符号为==,!=, &&以及                                                                               | ,后跟#else，#elif以及#endif   |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #else                                  | 执行后续代码直到#endif                                                                                      |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #elif symobl [operator symbol2]...     | 组合#else分支与#if测试                                                                                      |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #endif                                 | 结束条件指令                                                                                                |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #warning text                          | 显示在编译输出中的警告文本                                                                                  |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #error text                            | 显示在编译输出中的错误文本                                                                                  |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #pragma warning [disable \| restore]   | 禁止/重新载入编译警告                                                                                       |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #line [number["file"] \| hidden]       | 指定源代中的行号；file是显示在计算机输出中的文件名；hidden指示调试器略过此处直到下一个#line指令之间的代码   |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #region name                           | 标记区域的开头                                                                                              |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+
| #endregion                             | 结束区域                                                                                                    |
+----------------------------------------+-------------------------------------------------------------------------------------------------------------+-------------------------------+

Table: Table 4-1. Preprocessor directives

条件属性
~~~~~~~~

使用Conditional属性进行修饰的属性只在指定的预处理器符号存在时才编译。例如：

.. code:: csharp

    // file1.cs
    #define DEBUG
    using System;
    using System.Diagnostics;
    [Conditional("DEBUG")]
    public class TestAttribute : Attribute {}
    // file2.cs
    #define DEBUG
    [Test]
    class Foo
    {
      [Test]
      string s;
    }

只有当DEBUG符号位于file2.cs作用域内时编译器才会组合[Test]属性。

Pragma警告
~~~~~~~~~~

当编译器在我们的代码中检测到某些看起来并非我们意图的代码时会生成警告。与错误不同，警告通常并不会阻止我们的程序进行编译。

编译器警告在定位Bug时极其有价值。然而这种有用性在我们获得false警告会遭到破坏。在一个大的程序中，如果注意到“real”警告维护一个良好的信嘈比是十分必要的。

正是由于这种影响，编译器允许我们使用#pragma
warning指令来选择性的抑制警告。在这个示例中，我们指示编译器不要警告关于Message域未被使用的情况：

.. code:: csharp

    public class Foo
    {
      static void Main() { }
      #pragma warning disable 414
      static string Message = "Hello";
      #pragma warning restore 414
    }

忽略#pragma warning指令中的数字将会是重新载入所有的警告代码。

如果我们对于使用这种指令十分小心，我们可以使用/warnaserror开关来进行编译－这会告诉编译器将警告看作错误。

XML文档
-------

文档注释是一段标识类型或成员的嵌入XML片段。文档注释出现在类型或是成员声明之，并且以三个斜线开头：

.. code:: csharp

    /// <summary>Cancels a running query.</summary>
    public void Cancel() { ... }

多行注释可以像下面这样编写：

.. code:: csharp

    /// <summary>
    /// Cancels a running query
    /// </summary>
    public void Cancel() { ... }

或者像下面这样（注意起始处的多余星号）：

.. code:: csharp

    /**
        <summary> Cancels a running query. </summary>
    */
    public void Cancel() { ... }

如果我们使用/doc指令进行编译，编译器会抽取并将这些文档注释组合为一个XML文件。这有两个主要用途：

-  如果与已编译的程序集位于相同的目录，Visual
   Studio会自动读取XML文件并使用这些信息来向相同名字的程序集的使用者提供智能成员列表。
-  第三方工具（例如Sandcastle与NDoc）可以将XML文件转换为HTML帮助文件。

标准XML文档标记
~~~~~~~~~~~~~~~

下面是Visual Studio与文档生成器可以识别的标准XML标记：

...

表示InteliSense为成员或类型所显示的工具提示。

...

描述类型或成员的其他文本。文档生成器会进行识别并将其合并到类型或成员的描述中。

...

解释方法中的参数。

...

解释方法的返回值。

...

列出方法也许会抛出的异常（cref指异常类型）。

...

指示为类型或成员生成文档所需要的IPermisson类型。

.. raw:: html

   <example>

.. raw:: html

   <example>

...

.. raw:: html

   </example>

Chapter 5. Framework Overview
=============================

几乎所有的.NET框架的功能都是通过大量的托管类型集合来提供的。这些类型被组织在层次结构名字空间中并且打包在程序集集合中，其与CLR共同构成了.NET平台。

某些.NET类型由CLR直接使用，并且对于托管宿主环境是必须的。这些类型位于名为mscorlib.dll的程序集中并且包含C#的内建类型，以及基本的集合类，用于流处理的类型，序列化，反射，线程以及本地交互性。

在该层之上是构成CLR层功能的其他类型，提供了如XML，网络以及LINQ这样的特性。这些功能位于System.dll，System.Xml.dll以及System.Core.dll中，并且结合mscorlib提供了丰富的编程环境。这个“核心框架”主要定义了本书其余部分的讨论范围。

.NET框架的其余部分由应用API构成，其中的大多数主要覆盖三个功能区域：

-  用户界面技术
-  后台技术
-  分布式系统技术

Chapter 6. Framework Fundamentals
=================================

我们编程时所需要的许多核心功能并不是由C#语言提供的，而由.NET框架中的类型所提供的。在本章中，我们将会探讨框架在基本编程任务所扮演的角色，例如相等比较、顺序比较以及类型转换。同时我们会探讨基本框架类型，例如String，DateTime与Enum。

本节中的类型位于System名字空间中，但以下是例外：

-  StringBuilder定义在System.Text名字空间，与用于文本编码的类型位于相同的名字空间中。
-  CultureInfo与相关联的类型位于System.Globalization名字空间中。
-  XmlConver定义在System.Xml名字空间中。

字符串与文本处理
----------------

字符
~~~~

C#
char表示一个Unicode字符，且是System.Char结构的别名。在第2章中，我们描述了如何表示字符字面量。例如：

.. code:: csharp

    char c = 'A';
    char newLine = '\n';

System.Char为处理字符定义了大量的方法，例如ToUpper，ToLower与IsWhiteSpace。我们可以通过System.Char类型或是其char别名来调用这些方法：

.. code:: csharp

    Console.WriteLine (System.Char.ToUpper ('c'));    // C
    Console.WriteLine (char.IsWhiteSpace ('\t'));     // True

ToUpper与ToLower会考虑到终端用户的Locale，从而会导致一些莫名的Bug。下面的表达式在Turkey中会计算为false：

char.ToUpper ('i') == 'I'

因为在Turkey中，char.ToUpper('i')是'?'。为了避免这些问题，System.Char（与System.String）同时提供了以单词Invariant结尾的ToUpper与ToLower的文件无关版本。这些方法总是应用英语文化规则：

Console.WriteLine (char.ToUpperInvariant ('i')); // I

这是下列语句的简写形式：

Console.WriteLine (char.ToUpper ('i', CultureInfo.InvariantCulture))

char其他静态方法中的大多数与字符分类相关，如表6-1所示。

|csharp\_table\_6\_1.png| |csharp\_table\_6\_1\_2.png|

为了更多粒度的分类，char提供了名为GetUnicodeCategory的静态方法；这会返回一个UnicodeCategory枚举，其成员显示在表6-1的最右一列。

char为16位宽－足够表示Basic Multilingual Plane中的任何Unicode字符。

字符串
~~~~~~

C#
string（System.String）是不可变（不可修改）的字符序列。在第2章中，我们描述了如何表未完字符串字面量，执行相等比较以及连接两个字符串。本节会探讨用于处理字符串的其他函数，这是通过System.String类的静态与实例成员来提供的。

**构造字符串**

构造字符串最简单的方法就是赋值一个字面量，正如我们在第2章中所看到的：

.. code:: csharp

    string s1 = "Hello";
    string s2 = "First Line\r\nSecond Line";
    string s3 = @"\\server\fileshare\helloworld.cs";

要创建一个重复的字符序列，我们可以使用string的构造函数：

Console.Write (new string ('\*', 10)); // \*\*\*\*\*\*\*\*\*\*

我们也可以由char数组构造字符串。ToCharArray方法则执行相反的操作：

.. code:: csharp

    char[] ca = "Hello".ToCharArray();
    string s = new string (ca);              // s = "Hello"

为了由char\*这样的类型构造字符串，string的构造函数也被重载来接受各种（不安全）的指针类型。

**null与空字符串**

空字符串的长度为零。为了创建空字符串，我们可以使用字面量或是静态的string.Empty域；为了测试是否为空字符串，我们可以执行相等或是测试其Length属性：

.. code:: csharp

    string empty = "";
    Console.WriteLine (empty == "");              // True
    Console.WriteLine (empty == string.Empty);    // True
    Console.WriteLine (empty.Length == 0);        // True

由于字符串是引用类型，其也可以为null：

.. code:: csharp

    string nullString = null;
    Console.WriteLine (nullString == null);        // True
    Console.WriteLine (nullString == "");          // False
    Console.WriteLine (nullString.Length == 0);    // NullReferenceException

静态的string.IsNullOrEmpty方法是一个用于测试一个指定的字符串量澡为null或空的非常有用的简短方法。

**访问字符串中的字符**

字符串的索引器返回任意索引入的单个字符。类似于在字符串上操作的所有函数，这是由零开始索引的：

.. code:: csharp

    string str  = "abcde";
    char letter = str[1];        // letter == 'b'

string同时实现了IEnumerable接口，我们可以在其字符上执行foreach操作：

foreach (char c in "123") Console.Write (c + ","); // 1,2,3,

**在字符串内查找**

用于在字符串内查找的最简单的方法是Contains，StartsWidth与EndsWith。这些方法都会返回true或是false：

.. code:: csharp

    Console.WriteLine ("quick brown fox".Contains ("brown"));    // True
    Console.WriteLine ("quick brown fox".EndsWith ("fox"));      // True

IndexOf更为强大：他会返回指定字符或指字子串的第一个位置（如果没有找到则返回-1）：

Console.WriteLine ("abcde".IndexOf ("cd")); // 2

IndexOf还被重载来接受一个startPosition（开始搜索处的索引）与一个StringComparison枚举。后者可以允许我们执行大小写无关的搜索：

.. code:: csharp

    Console.WriteLine ("abcde".IndexOf ("CD",
                       StringComparison.CurrentCultureIgnoreCase));    // 2

LastIndexOf类似于IndexOf，但是对字符串执行后向查找。

IndexOfAny返回字符集合中任意一个匹配的第一个位置：

.. code:: csharp

    Console.Write ("ab,cd ef".IndexOfAny (new char[] {' ', ','} ));       // 2
    Console.Write ("pas5w0rd".IndexOfAny ("0123456789".ToCharArray() ));  // 3

LastIndexOfAny在相反的方向上执行相同的操作。

**操作字符串**

因为String是不可修改的，操作字符串的所有方法都会返回一个新字符串，而不会修改原字符串（当我们重新赋值一个字符串变量也是如此）。

SubString获取字符串的一部分：

.. code:: csharp

    string left3 = "12345".Substring (0, 3);     // left3 = "123";
    string mid3  = "12345".Substring (1, 3);     // mid3 = "234";

如果我们忽略长度，我们就会获得字符串的其余部分：

string end3 = "12345".Substring (2); // end3 = "345";

Insert与Remove会在指定的位置处插入或是删除字符：

.. code:: csharp

    string s1 = "helloworld".Insert (5, ", ");    // s1 = "hello, world"
    string s2 = s1.Remove (5, 2);                 // s2 = "helloworld";

PadLeft与PadRight会使用指定的字符将字符串填充到指定的长度（如果没有指定填充字符则填充为空格）：

.. code:: csharp

    Console.WriteLine ("12345".PadLeft (9, '*'));  // ****12345
    Console.WriteLine ("12345".PadLeft (9));       //     12345

如果输入字符串比填充长度还要长，则会返回未修改的原始字符串。

TrimStart与TrimEnd会由字符串的起始或结束处移除指定的字符；Trim则会同时进行两种操作。默认情况，这些函数会移除空白字符（包括空格、Tab、新行以及这些字符的Unicode形式）：

Console.WriteLine (" abc \\t\\r\\n ".Trim().Length); // 3

Replace可以替换字符串特定的字符或子串：

.. code:: csharp

    Console.WriteLine ("to be done".Replace (" ", " | ") );  // to | be | done
    Console.WriteLine ("to be done".Replace (" ", "")    );  // tobedone

ToUpper与ToLower会返回输入字符串的大写或是小写版本。默认情况下，这些方法会考虑到用户的当前语言设置；ToUpperInvariant与ToLowerInvariant总是应用英语字母规则。

**分割与合并字符串**

Split会将一个字符串分割为单词数组返回：

.. code:: csharp

    string[] words = "The quick brown fox".Split();
    foreach (string word in words)
      Console.Write (word + "|");    // The|quick|brown|fox|

默认情况下，Split使用空格作为分割符；该方法也被重载来接受char或是string的params数组作为分割符。Split也可以接受一个StringSplitOptions枚举，其中有一个选项可以移除空项：这对于单词由一行中的多个分割符分割的情况下十分有用。

静态的Join方法会执行与Split相反的操作。他会接受一个分割符与一个字符串数组：

.. code:: csharp

    string[] words = "The quick brown fox".Split();
    string together = string.Join (" ", words);      // The quick brown fox

静态的Concat方法与Join方法类似，但是只接受一个params字符串数组而没有分割符。Concat实际上与+操作符等同（实际上编译器会将+转换为Concat）：

.. code:: csharp

    string sentence     = string.Concat ("The", " quick", " brown", " fox");
    string sameSentence = "The" + " quick" + " brown" + " fox";

**String.Format与组合格式化字符串**

静态的Format方法提供了一个方便的方法来构建嵌入变量的字符串。嵌入的变量可以为任何类型；Format只是简单的在这些变量上调用ToString方法。

包含嵌入变量的主字符串被称为组合格式字符串。当调用String.Format时，我们提供一个组合字符串其后跟随每一个嵌入变量。例如：

.. code:: csharp

    string composite = "It's {0} degrees in {1} on this {2} morning";
    string s = string.Format (composite, 35, "Perth", DateTime.Now.DayOfWeek);
    // s == "It's 35 degrees in Perth on this Friday morning"

每一个花括号中的数字被称为格式化项。与参数位置所对应的数字其后可以有：

-  逗号与要应用的最小宽度
-  冒号与格式化字符串

最小宽度对于对齐列十分有用。如果值为负的，数据是左对齐的；否则为右对齐。例如：

.. code:: csharp

    string composite = "Name={0,-20} Credit Limit={1,15:C}";
    Console.WriteLine (string.Format (composite, "Mary", 500));
    Console.WriteLine (string.Format (composite, "Elizabeth", 20000));

以下为输出结果：

.. code:: text

    Name=Mary                 Credit Limit=        $500.00
    Name=Elizabeth            Credit Limit=     $20,000.00

不使用string.Format的等价方法如下：

.. code:: csharp

    string s = "Name=" + "Mary".PadRight (20) +
               " Credit Limit=" + 500.ToString ("C").PadLeft (15);

比较字符串
~~~~~~~~~~

当比较两个值时，.NET框架会区别相等比较与顺序比较的概念。相等比较测试两个实体在语义上是否相同；顺序比较测试当以顺序或是逆序排列两个实例时哪个在前。

对于字符串相等比较，我们可以使用==操作符或是string的Equals方法。后一种方法更为强大，因为他可以允许我们指定如大小写敏感这样的选项。

对于字符串顺序比较，我们可以使用CompareTo实体方法或是静态的Compare与CompareOrdinal方法：这些方法会依据第一个值出现在第二值的前面、后面或是相同而返回正数、负数或零。

在深入每一个细节之前，我们需要了解.NET底层字符串比较算法。

**顺序与文化比较**

对于字符串比较有两个基本算法：顺序与文化相关。顺序比较简单的将字符解释为数字（依据其数值Unicode值）；文化相关比较解释字符时会考虑到特定的语言。有两种特殊的文化：基于计算机控制面板设置的“当前文化”以及在所有计算机上都一样的“invariant
culture”。

对于相等比较，顺序与文化特定的算法都很有用。然而对于顺序比较，文化特定的比较几乎总是完美的；要依据字母顺序对字符串进行排序，我们需要一个字母表。顺序排序依赖于数值Unicode点值，其恰好将英语字符以字母顺序排列－但这样也许并不是我们所真正希望的。例如，考虑大小写敏感的排序，考虑“Atom”，“atom”与“Zamia”。invariant
culture会将其排列为下列顺序：

"Atom", "atom", "Zamia"

而顺序排列会得到下列结果：

"Atom", "Zamia", "atom"

这是因为invariant
culture封装了一个字母表，其中大写字母排在其对应小写字母的前面（AaBbCcDd...）。然而顺序算法会首先排列所有的大写字母，然后是所有的小写字母（A..Z,a..z）。这实际了回退到了1960年所发明的ASCII字符集合。

**字符串相等比较**

尽管顺序排序有这些限制，string的==操作符总是执行顺序大小写敏感排序。当调用无参数的string.Equals方法也会执行相同的操作；这为string类型定义了“默认”相等比较。

下列方法会允许culture相关或是大小写敏感比较：

.. code:: csharp

    public bool Equals(string value, StringComparison comparisonType);
    public static bool Equals (string a, string b,
                               StringComparison comparisonType);

静态版本更为高级，因为如果其中的一个或是两个字符串均为null时，该方法仍能工作。StringComparison是一个枚举，其定义如下：

.. code:: csharp

    public enum StringComparison
    {
      CurrentCulture,               // Case-sensitive
      CurrentCultureIgnoreCase,
      InvariantCulture,             // Case-sensitive
      InvariantCultureIgnoreCase,
      Ordinal,                      // Case-sensitive
      OrdinalIgnoreCase
    }

例如：

.. code:: csharp

    Console.WriteLine (string.Equals ("foo", "FOO",
                       StringComparison.OrdinalIgnoreCase));   // True
    Console.WriteLine ("?" == "ǖ");                            // False
    Console.WriteLine (string.Equals ("?", "ǖ",
                       StringComparison.CurrentCulture));      // ?

（最后的比较结果是由当前计算机的语言设置所决定的。）

**字符串顺序比较**

String的CompareTo实例方法会执行culture相关，大小写敏感的顺序比较。不同于==操作符，CompareTo并不使用顺序比较：对于顺序，culture相关的算法更为有用。

该方法定义如下：

public int CompareTo (string strB);

对于其他的比较类型，我们可以调用静态的Compare与CompareOrdinal方法：

.. code:: csharp

    public static int Compare (string strA, string strB,
                               StringComparison comparisonType);
    public static int Compare (string strA, string strB, bool ignoreCase,
                               CultureInfo culture);
    public static int Compare (string strA, string strB, bool ignoreCase);
    public static int CompareOrdinal (string strA, string strB);

后两个方法是前两个方法的简写形式。

所有的顺序比较方法都会第一个值是否位于第二值的后面，前面或是相等而返回一个正数、一个负数或是零：

.. code:: csharp

    Console.WriteLine ("Boston".CompareTo ("Austin"));    // 1
    Console.WriteLine ("Boston".CompareTo ("Boston"));    // 0
    Console.WriteLine ("Boston".CompareTo ("Chicago"));   // ?1
    Console.WriteLine ("?".CompareTo ("ǖ"));              // 0
    Console.WriteLine ("foo".CompareTo ("FOO"));          // ?1

下面的代码会使用当前的文化执行大小写敏感的比较：

Console.WriteLine (string.Compare ("foo", "FOO", true)); // 0

通过提供CultureInfo对象，我们可以插入任意字母：

.. code:: csharp

    CultureInfo german = CultureInfo.GetCultureInfo ("de-DE");
    int i = string.Compare ("Müller", "Muller", false, german);

StringBuilder
~~~~~~~~~~~~~

StringBuilder类（位于System.Text名字空间）表示一个可变的（可修改）字符串。使用StringBuilder，我们可以Append，Insert，Remove以及Replace子字符串而不必替换整个StringBuilder。

StringBuilder的构造函数可以接受一个初始字符串值及其初始容量的尺寸（默认为16个字符）。如果我们超出这个值，StringBuilder会自动调整其内部结构进行适应（会有一点性能损失）直到其最大容量（默认为int.MaxValue）。

StringBuilder的一个通常应用就是通过重复调用Append来构造一个长字符串。这种方法要比重复连接普通的字符串类型要高效得多：

.. code:: csharp

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 50; i++) sb.Append (i + ",");

要获得最终的结果，可以调用ToString()：

.. code:: csharp

    Console.WriteLine (sb.ToString());
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
    27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,

AppendLine会执行一个添加新行序列的Append。AppendFormat接受一个组合格式化字符串，类似于String.Format。

类似于Insert，Remove与Replace方法，StringBuilder定义了一个Length属性以及一个用于获取/设置单个字符的可写索引器。

要清空StringBuilder的内容，或者初始化一个新实例，或者将其Length设置为0。

文本编码与Unicode
~~~~~~~~~~~~~~~~~

字符集是一个字符的分配，每一个具有一个数值编码或是编码点。有两种通常使用的字符集：Unicode与ASCII。Unicode有大约一百万个字符的地址空间，其中已分配的大约有100000个。Unicode覆盖了世界上大多数的语言，以及一个历史语言以及特殊符号。ASCII集合只是Unicode集合中的前127个字符，覆盖了我们在US风格的键盘上所看到的绝大数字符。ASCII早于Unicode大约30年，而由于其简单性与高效性仍然被使用：每一个字符由一个字节表示。

.NET类型系统被设计用来处理Unicode字符集。ASCII通过作为Unicode字符集的子集被隐式支持。

文本编码将字符由其数值编码点映射到二进制表示。在.NET中，当处理文本或是流时，文本编码就会派上用场了。当我们将一个文本文件读取到字符串，文本编码器将文本数据由二进制转换为char与string类型所希望的内部Unicode表示。

在.NET中有两种文本编码类型：

-  将Unicode字符集映射到其他字符集的文本编码
-  使用标准Unicode encoding scheme的文本编码

第一类包含遗留编码，例如IBM的EBCDIC以及在Unicode之前较为流行的带有高128区域扩展的8位字符集。ASCII编码也属于这一类别：他编码前128个字符并且丢弃其他字符。这一类别也包含非遗留的GB18030，这是中文编写程序的主要标准。

第二类别主要有UTF-8，UTF-16与UTF-32（以及废弃的UTF-7）。他们之间的区别在于空间效率。UTF-8对于大多数的文本类型是最节省空间的：他使用一到四个字节来表示一个字符。前128个字符仅需要一个字节，从而与ASCII兼容。UTF-8对于文本文件与流（特别是网络流）是最流行的编码，并且是.NET中流的默认编码（事实上他几乎是所有隐式使用编码的默认编码）。

UTF-16使用一个或是两个16位字来表示一个字符，并且是.NET在内部表示字符与字符串所使用的编码。某些程序也使用UTF-8来编写文件。

UTF-32是最浪费空间的：他将每个代码点直接映射为32位，所以每个字符耗费四个字节。因此，UTF-32几乎很少使用。然而他却使得随机访问非常容易，因为每个字符占用相等的字节数。

获取编码对象
~~~~~~~~~~~~

System.Text中的Encoding类是封装文本编码类的共同基类。他有多个子类－其目的是封装具有类似特性的编码族。实例化一个正确配置的类的最简单的方法是使用标准的IANA名字调用Encoding.GetEncoding：

.. code:: csharp

    Encoding utf8 = Encoding.GetEncoding ("utf-8");
    Encoding chinese = Encoding.GetEncoding ("GB18030");

常见的编码也可以通过Encoding的静态属性获得。

静态的GetEncodings方法会返回所有所支持的编码及其标准IANA名字的列表：

.. code:: csharp

    foreach (EncodingInfo info in Encoding.GetEncodings())
      Console.WriteLine (info.Name);

获取编码的另一个方法是直接实例化编码类。这样可以允许我们通过构造器参数设置多个属性，包括：

-  如果解码时遇到不正确的字节序列是否抛出异常。默认值为false。
-  使用大端还是小端编码/解码UTF16/UTF-32。默认为小端，这是Windows操作系统上的标准。
-  是否发送字节顺序标记（表明端类型的前缀）。

为文件与流I/O编码
~~~~~~~~~~~~~~~~~

Encoding对象最常见的应用是控制文本如何写入或是读取到文件或流。例如，下面的代码会使用UTF-16编码将“Testing...”写入到名为data.txt的文件中：

System.IO.File.WriteAllText ("data.txt", "Testing...",
Encoding.Unicode);

如果我们忽略最后一个参数，WriteAllText则会应用UTF-8编码。

我们会在第14章再回到该主题。

编码字节数组
~~~~~~~~~~~~

我们也可以使用Encoding对象在字节数组之间进行转换。GetBytes方法使用指定的编码将string转换为byte[]；GetSTring由byte[]转换为string：

.. code:: csharp

    byte[] utf8Bytes  = System.Text.Encoding.UTF8.GetBytes    ("0123456789");
    byte[] utf16Bytes = System.Text.Encoding.Unicode.GetBytes ("0123456789");
    byte[] utf32Bytes = System.Text.Encoding.UTF32.GetBytes   ("0123456789");
    Console.WriteLine (utf8Bytes.Length);    // 10
    Console.WriteLine (utf16Bytes.Length);   // 20
    Console.WriteLine (utf32Bytes.Length);   // 40
    string original1 = System.Text.Encoding.UTF8.GetString    (utf8Bytes);
    string original2 = System.Text.Encoding.Unicode.GetString (utf16Bytes);
    string original3 = System.Text.Encoding.UTF32.GetString   (utf32Bytes);
    Console.WriteLine (original1);          // 0123456789
    Console.WriteLine (original2);          // 0123456789
    Console.WriteLine (original3);          // 0123456789

UTF-16与代理对
~~~~~~~~~~~~~~

我们也许还会记起.NET使用UTF-16存储字符与字符串。因为每个字符需要一个或是两个16位字，而一个char仅是16位长度。某些Unicode字符需要2个char进行表示。这会导致两个后果：

-  字符串的Length属性也许会大于实际的字符数
-  单一char并不总是足够表示一个Unicode字符

大多数程序都会忽视这两点，因为几乎所有常见的字符都正好落入所谓的基本多语言区（BMP）Unicode范围内，这在UTF-16中仅需要一个16位字。BMP覆盖了多种世界语言并且包含多于3000个中国字符。除此之外是一些古老语言，音乐符号以及一些不常见的中国字符。

如果我们需要支持两字字符，char中的下列静态方法可以将一个32位代码点转换为两个char的字符，或是相反的操作：

.. code:: csharp

    string ConvertFromUtf32 (int utf32)
    int    ConvertToUtf32   (char highSurrogate, char lowSurrogate)

2字字符被称为代用品。他们很容易被定痊，因为每一个字位于0xD800到0xDFFF之间。我们可以使用char中的下列方法进行辅助操作：

.. code:: csharp

    bool IsSurrogate     (char c)
    bool IsHighSurrogate (char c)
    bool IsLowSurrogate  (char c)
    bool IsSurrogatePair (char highSurrogate, char lowSurrogate)

System.Globalization名字空间中的StringInfo类也提供了一系列方法与属性用于处理两字字符。

BMP之外的字符通常需要特殊的字体并且具有有限的操作系统支持。

日期与时间
----------

System名字空间中有三个不可修改的结构可以完成表示日期与时间的工作：DateTime，DateTimeOffset与TimeSpan。C#并没有定义任何映射到这些类型的特殊关键字。

TimeSpan
~~~~~~~~

TimeSpane表示时间的间隔－或是一天中的时间。在后一种角色中，他仅是简单的“钟表”时间（无日期），其等同于自午夜以来的时间。TimeSpan具有100ns的精度，具有大约一千万天的最大值，并且可以为正，可以为负。

构建TimeSpan有三种方法：

-  通过构造函数
-  通过调用静态的From方法
-  通过两个DateTime的相减

其构造函数如下：

.. code:: csharp

    public TimeSpan (int hours, int minutes, int seconds);
    public TimeSpan (int days, int hours, int minutes, int seconds);
    public TimeSpan (int days, int hours, int minutes, int seconds,
                                                       int milliseconds);
    public TimeSpan (long ticks);   // Each tick = 100ns

如果我们仅希望以单一单位指定间隔，例如分钟，小时等，静态的From方法会更为方便：

.. code:: csharp

    public static TimeSpan FromDays (double value);
    public static TimeSpan FromHours (double value);
    public static TimeSpan FromMinutes (double value);
    public static TimeSpan FromSeconds (double value);
    public static TimeSpan FromMilliseconds (double value);

例如：

.. code:: csharp

    Console.WriteLine (new TimeSpan (2, 30, 0));     // 02:30:00
    Console.WriteLine (TimeSpan.FromHours (2.5));    // 02:30:00
    Console.WriteLine (TimeSpan.FromHours (?2.5));   // ?02:30:00

TimeSpan重载了操作符，以及+与-操作符。下面的表达式会计算得到2.5小时的TimeSpan：

TimeSpan.FromHours(2) + TimeSpan.FromMinutes(30);

下面的语句会计算得到比10天少1秒的TimeSpan：

TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1); // 9.23:59:59

使用该表达式，我们可以演示整数属性Days，Hours，Minutes，Seconds与Milliseconds：

.. code:: csharp

    TimeSpan nearlyTenDays = TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);
    Console.WriteLine (nearlyTenDays.Days);          // 9
    Console.WriteLine (nearlyTenDays.Hours);         // 23
    Console.WriteLine (nearlyTenDays.Minutes);       // 59
    Console.WriteLine (nearlyTenDays.Seconds);       // 59
    Console.WriteLine (nearlyTenDays.Milliseconds);  // 0

相对应的，Total属性会返回表示整个时间间隔的double类型值：

.. code:: csharp

    Console.WriteLine (nearlyTenDays.TotalDays);          // 9.99998842592593
    Console.WriteLine (nearlyTenDays.TotalHours);         // 239.999722222222
    Console.WriteLine (nearlyTenDays.TotalMinutes);       // 14399.9833333333
    Console.WriteLine (nearlyTenDays.TotalSeconds);       // 863999
    Console.WriteLine (nearlyTenDays.TotalMilliseconds);  // 863999000

静态Parse方法与ToString方法正相反，该方法会将字符串转换为TimeSpan。TryParse方法与其类似，但是如果转换失败会返回false而不是抛出异常。XmlConvert类也提供了遵循标准XML格式协议的TimeSpan/字符串转换方法。

TimeSpan的默认值为TimeSpan.Zero。

TimeSpan也可以用来表示一天中的时间（自午夜以来逝去的时间）。要获取一天中的当前时间，调用DateTime.Now.TimeOfDay。

DateTime与DateTimeOffset
~~~~~~~~~~~~~~~~~~~~~~~~

DateTime与DateTimeOffset是用于表示日期与时间的不可修改的结构。他们具有100ns的精度，并且覆盖由0001到9999年的范围。

DateTimeOffset是在框架3.5中加入的，并且功能类似于DateTime。其独特性在于他也可以存储UTC偏移量；当进行跨时区的比较时，这会得到更有意义的结果。

**在DateTime与DateTimeOffst之间进行选择**

DateTime与DateTimeOffset之间的区别在于如何处理时区。DateTime结合三个状态标记来表明DateTime是否相对于：

-  当前计算机的本地时间
-  UTC
-  未指定

DateTimeOffset更为特殊－他将与UTC的偏移量存储为TimeSpan：

July 01 2007 03:00:00 ?06:00

这会影响相等比较，而这也正在DateTime与DateTimeOffset之间进行选择的主要因素。特别是：

-  DateTime在比较时会忽略三状态标记，如果他们具有相同的年，月，日，时，分等，则认为他们是相等的。
-  DateTimeOffset则认为如果两个值指向相同的时间点时才相等。

所以，DateTime会认为下面的两个值不同，而DateTimeOffset则认为他们相同：

.. code:: text

    July 01 2007 09:00:00 +00:00 (GMT)
    July 01 2007 03:00:00 ?06:00 (local time, Central America)

大多数情况下，DateTimeOffset的相等逻辑更为可取。例如，在计算两个国际事件哪一个更近时，DateTimeOffset会隐式的给出正确答案。类似的，进行DDOS攻击的骇客也会考虑DateTimeOffset。使用DateTime完成相同的事情则要求在我们的程序使用统一的时区。这是有问题的，原因有两个：

-  为了终端用户友好，UTC DateTime在格式化之前需要显式转换为本地时间。
-  很容易忘记考虑本地DateTime。

然而，在运行时指定与本地机器的相对值时，DateTime更合适－例如，如果我们希望在下周六，本地时间3
A.M（此时活动最少）调度国际办公室的归档。此时，DateTime更为合适，因为他会考虑到每一个办公室的本地时间。

我们会在稍后更为详细的讨论时区与相等比较。

**构建DateTime**

DateTime定义了接受年，月，日以及可选的时，分，秒以及毫秒整数的构造函数：

.. code:: csharp

    public DateTime (int year, int month, int day);
    public DateTime (int year, int month, int day,
                     int hour, int minute, int second, int millisecond);

如果我们仅指定了日期，则时间会被隐式的设置为午夜（0：00）。

DateTime构造函数也允许我们指定DateTimeKind－一个具有下列值的枚举：

Unspecified, Local, Utc

这相当前前面内容中所描述的三状态标记。Unspecified是默认值，意味着DateTime是时区相关的。Locale意味着相对于当前机器上的本地时区。本地DateTime并没有包含关于其指向的时区的信息，而且也不同于DateTimeOffset，不包含相对UTC偏移量的信息。

DateTime的Kind属性会返回其DateTimeKind。

DateTime的构造函数同时被重载接受Calendar对象－这允许我们使用在System.Globalization中定义的Calendar子类来指定日期：

.. code:: csharp

    DateTime d = new DateTime (5767, 1, 1,
                              new System.Globalization.HebrewCalendar());
    Console.WriteLine (d);    // 12/12/2006 12:00:00 AM

（该示例中的日期格式依赖于我们机器的控制面板的设置。）DateTime总是默认使用罗马日期－这个示例在构建过程中发生了时间转换。要使用其他的日历执行计算，我们必须使用Calendar子类本身的方法。

我们也可以使用long类型的ticks值来构建DateTime，其中ticks是由午夜01/01/0001算起的100ns间隔数。

出于交互性的考虑，DateTime提供了静态的FromFileTime与FromFileTimeUtc方法用于由Windows文件时间（指定为long）转换以及FromOADate用于由OLE自动日期时间（指定为double）转换。

要由字符串构建DateTime，调用静态的Parse或ParseExact方法。两个方法都可以接受标记与格式提供器；ParseExact同时接受一个格式字符串。我们会在稍后进行详细讨论。

**构建DateTimeOffset**

DateTimeOffset具有类似的构造函数集。区别在于我们同时指定一个UTC偏移作为TimeSpan：

.. code:: csharp

    public DateTimeOffset (int year, int month, int day,
                           int hour, int minute, int second,
                           TimeSpan offset);
    public DateTimeOffset (int year, int month, int day,
                           int hour, int minute, int second, int millisecond,
                           TimeSpan offset);

TimeSpan必须为分的整数，否则会抛出异常。

DateTimeOffset同时还有接受Calendar对象，long
ticks值以及接受字符串的静态Parse与ParseExact方法的构造函数。

我们可以使用下列的构造函数由DateTime构造DateTimeOffset：

.. code:: csharp

    public DateTimeOffset (DateTime dateTime);
    public DateTimeOffset (DateTime dateTime, TimeSpan offset);

或是使用隐式转换：

DateTimeOffset dt = new DateTime (2000, 2, 3);

如果我们没有指定偏移，则会使用下列规则由DateTime值进行推测：

-  如果DateTime的DateTimeKind为Utc，则偏移量为0。
-  如果DateTime的DateTimeKind为Local或是Unspecified（默认），则偏移量由当前本地时区计算获得。

要在另一个方向上进行转换，DateTimeOffset提供了三个属性返回DateTime类型的值：

-  UtcDateTime属性返回UTC时间的DateTime。
-  LocalDateTime属性返回当前本地时区的DateTime（如果需要则进行转换）。
-  DateTime属性返回指定时区的DateTime，其Kind为Unspecified。

**当前DateTime/DateTimeOffset**

DateTime与DateTimeOffset都具有一个返回当前日期与时间的Now属性：

.. code:: csharp

    Console.WriteLine (DateTime.Now);         // 11/11/2007 1:23:45 PM
    Console.WriteLine (DateTimeOffset.Now);   // 11/11/2007 1:23:45 PM ?06:00

DateTime同时提供了仅返回日期部分的Today属性：

Console.WriteLine (DateTime.Today); // 11/11/2007 12:00:00 AM

静态的UtcNow属性返回当前的UTC日期与时间：

.. code:: csharp

    Console.WriteLine (DateTime.UtcNow);        // 11/11/2007 7:23:45 AM
    Console.WriteLine (DateTimeOffset.UtcNow);  // 11/11/2007 7:23:45 AM +00:00

所有这些方法的精度依赖于操作系统，并且通常在10－20ms范围内。

**处理日期与时间**

DateTime与DateTimeOffset提供了类似的实例属性集来返回各种日期与时间元素：

.. code:: csharp

    DateTime dt = new DateTime (2000, 2, 3,
                                10, 20, 30);
    Console.WriteLine (dt.Year);         // 2000
    Console.WriteLine (dt.Month);        // 2
    Console.WriteLine (dt.Day);          // 3
    Console.WriteLine (dt.DayOfWeek);    // Thursday
    Console.WriteLine (dt.DayOfYear);    // 34
    Console.WriteLine (dt.Hour);         // 10
    Console.WriteLine (dt.Minute);       // 20
    Console.WriteLine (dt.Second);       // 30
    Console.WriteLine (dt.Millisecond);  // 0
    Console.WriteLine (dt.Ticks);        // 630851700300000000
    Console.WriteLine (dt.TimeOfDay);    // 10:20:30  (returns a TimeSpan)

DateTimeOffst同时提供了一个TimeSpan类型的Offset属性。

两个类型提供了下列的实例方法来执行计算（大多数接受double与int类型的参数）：

.. code:: csharp

    AddYears  AddMonths   AddDays
    AddHours  AddMinutes  AddSeconds  AddMilliseconds  AddTicks

这些方法都会返回一个新的DateTime或DateTimeSpan，并且这些方法考虑到闰年的情况。我们可以传递一个负数进行相减。

Add方法将TimeSpan添加到DateTime或是DateTimeOffset。+操作符被重载完成同样的工作：

.. code:: csharp

    TimeSpan ts = TimeSpan.FromMinutes (90);
    Console.WriteLine (dt.Add (ts));         // 3/02/2000 11:50:30 AM
    Console.WriteLine (dt + ts);             // 3/02/2000 11:50:30 AM

我们也可以由DateTime/DateTimeOffset减去TimeSpan或是由一个DateTime/DateTimeOffset减去另一个。后者会返回给我们一个TimeSpan：

.. code:: csharp

    DateTime thisYear = new DateTime (2007, 1, 1);
    DateTime nextYear = thisYear.AddYears (1);
    TimeSpan oneYear = nextYear - thisYear;

**格式化与解析**

在DateTime上调用ToString会将结果格式化为一个短日期（所有数字）后跟长时间（包括秒）的格式。例如：

13/02/2000 11:50:30 AM

默认情况下，操作系统的控制面板会决定是否先显示日，月还是年，是否使用前缀零，以及是使用12还是24小时。

在DateTimeOffset上调用ToString会得到相同的结果，所不同的是偏移量也会同时返回：

3/02/2000 11:50:30 AM ?06:00

ToShortDateString与ToLongDateString方法会仅返回日期部分。长日期格式也是由控制面板决定的；例如Saturday,
17 February
2007。ToShortTimeString与ToLongTimeString会返回时间部分，例如17:10:10（前者没有秒）。

上面所描述的四个方法实际上是四种不同格式化字符串的缩写形式。ToString被重载来接受格式字符串与提供者，从而允许我们指定一个宽泛的选项范围并且控制如何应用区域设置。

静态的Parse与ParseExact方法与ToString正相反，将一个字符串转换为DateTime或是DateTimeOffest。Parse方法也被重载来接受格式提供者。

**Null DateTime与DateTimeOffset值**

因为DateTime与DateTimeOffset是结构，他们本质上是不可以为空的。当我们需要时，我们可以有两种方法：

-  使用Nullable类型（例如DateTime?或DateTimeOffet?）
-  使用静态域DateTime.MinValue或DateTimeOffset.MinValue（这些类型的默认值）

可空类型通常是最好的方法，因为编译器有助于避免错误。DateTime.MinValue对于向后兼容非常有用。

日期与时区
----------

在本节中，我们将会详细解释时区如何影响DateTime与DateTimeOffset。我们同时会了解TimeZone与TimeZoneInfo类型，提供了关于时区偏移与夏时令信息的类型。

DateTime与时区
~~~~~~~~~~~~~~

Chapter 7. Collections
======================

.NET框架提供了一个用于存储与管理对象集合的标准类集合。这些包括可扩展的列表，链表，有序与无序的字典以及数组等。在这些当中，只有数组形成C#语言的一部分；其他的集合都是我们可以实例化的类。

框架中用于集合的类型可以分为下列几类：

-  定义了标准集合协议的接口
-  已可用的集合类（列表，字典等）

用于编写程序特定集合的基类

本章探讨这些类别，并且具有额外的部分来讨论在确定元素数量与顺序时所用的类型。

集合名字空间如下：

+----------------------------------+------------------------------+
| 名字空间                         | 所包含的内容                 |
+----------------------------------+------------------------------+
| System.Collections               | 非泛型集合类与接口           |
+----------------------------------+------------------------------+
| System.Collections.Specialized   | 强类型非泛型集合类           |
+----------------------------------+------------------------------+
| System.Collections.Generic       | 泛型集合类与接口             |
+----------------------------------+------------------------------+
| System.Collections.ObjectModel   | 用于自定义集合的代理与基类   |
+----------------------------------+------------------------------+
| System.Collections.Concurrent    | 类型安全集合                 |
+----------------------------------+------------------------------+

枚举
----

在计算中，有各种集合类型，由简单的数据结构，例如数组或是链表，到更为复杂的数据结构，例如红黑树与散列表。尽管这些数据的内部实现与外部特性变量很大，遍历这些集合的功能却是共同的需求。框架通过允许不同的数据结构公开一个共同的遍历API的一对接口（IEnumerable，IEnumerator以及对应的泛型接口）来提供这种需求。他们是图7-1所示的更大的集合接口集合的一部分。

.. figure:: csharp_7_1.png
   :alt: csharp_7_1.png

   csharp\_7\_1.png
IEnumerable与IEnumerator
~~~~~~~~~~~~~~~~~~~~~~~~

IEnumerator接口定义了集合中的元素以forward-only方式进行遍历或是枚举所使用的基础底层协议。其声明如下：

.. code:: csharp

    public interface IEnumerator
    {
      bool MoveNext();
      object Current { get; }
      void Reset();
    }

MoveNext将当前元素或是“光标”指向下一个位置，如果在集合中没有更多的元素则返回false。Current返回在当前位置的元素（通常由object转换为更特殊的类型）。在获取每一个元素之前必须调用MoveNext，这是为了适用于空集合。如果实现了Reset方法，则会使得光标回到起始位置，从而再次枚举集合。（通常避免调用Reset方法，因为并不是所有的枚举器都支持这个方法。）

集合并不实现枚举器；相反，他们通过IEnumerable接口提供枚举器：

.. code:: csharp

    public interface IEnumerable
    {
      IEnumerator GetEnumerator();
    }

通过定义一个返回枚举器的方法，IEnumerable提供了灵活性，因为迭代可以移到另一个类中。而且，这就意味着多个消费者可以同时枚举集合，而不会相互干扰。IEnumerable可以被认为是“IEnumeratorProvider”，并且他是集合所实现的最基本接口。

下面的示例演示了IEnumerable与IEnumerator的底层使用：

.. code:: csharp

    string s = "Hello";
    // Because string implements IEnumerable, we can call GetEnumerator():
    IEnumerator rator = s.GetEnumerator();
    while (rator.MoveNext())
    {
      char c = (char) rator.Current;
      Console.Write (c + ".");
    }
    // Output:  H.e.l.l.o.

然而通常并不直接以这种方式在枚举器上调用方法，因为C#提供了一个语法糖：foreach语句。下面是使用foreach重新编写的相同示例：

.. code:: csharp

    string s = "Hello";      // The String class implements IEnumerable
    foreach (char c in s)
      Console.Write (c + ".");

IEnumerable与IEnumerator
~~~~~~~~~~~~~~~~~~~~~~~~

IEnumerator与IEnuerable几乎总是与他们的扩展泛型版本联合实现：

.. code:: csharp

    public interface IEnumerator<T> : IEnumerator, IDisposable
    {
      T Current { get; }
    }
    public interface IEnumerable<T> : IEnumerable
    {
      IEnumerator<T> GetEnumerator();
    }

通过定义Current与GetEnumerator的类型版本，这些接口加强了静态类型安全，避免了使用值类型元素时的装箱负担，并且对于消费者更为方便。数组自动实现了IEnumerable（其中T是数组的成员类型）。

借助于改进的静态类型安全，使用字符数组调用下列方法会产生编译时错误：

.. code:: csharp

    void Test (IEnumerable<int> numbers) { ... }

对于集合类公开IEnumerable，同时通过显式接口实现隐藏非泛型的IEnumerable是一个标准用法。这样当我们直接调用GetEnumerator()时，我们可以获得类型安全的泛型IEnumerator。然而有时会由向后兼容的原因破坏这一规则。一个明显的例子就是数组－数组必须返回非泛型的IEnumerator从而避免破坏以前的代码。为了获得一个泛型的IEnumerator，我们必须转换为公开显式接口：

.. code:: csharp

    int[] data = { 1, 2, 3 };
    var rator = ((IEnumerable <int>)data).GetEnumerator();

幸运的是，借助于foreach语句，我们很少需要编写这种类型的代码。

**IEnumerable与IDisposable**

IEnumerable实现了IDisposable。这可以使得枚举器存储资源引用，例如数据库链接，并且保证当枚举完成时这些资源被释放。foreach语句会识别到这种细节并将：

foreach (var element in somethingEnumerable) { ... }

转换为：

.. code:: csharp

    using (var rator = somethingEnumerable.GetEnumerator())
      while (rator.MoveNext())
      {
        var element = rator.Current;
        ...
      }

using块可以保证销毁。

实现枚举接口
~~~~~~~~~~~~

由于下列原因我们也许会希望实现IEnuerable或是IEnumerable：

-  为了支持foreach语句
-  与期望标准集合的内容交互
-  作为更复杂集合接口的一部分
-  为了支持集合初始化器

为了实现IEnumerable/IEnumerable，我们必须提供一个枚举器。我们可以通过下列方法来实现：

-  如果类“包装”了其他集合，通过返回包装的集合的枚举器实现
-  通过使用yield return的迭代器实现
-  通过实例化我们自己的IEnumerator/IEnumerator实现来实现

返回另一个集合的枚举器实质就是调用内层集合的GetEnumerator方法。然而这只适用于最简单的场景，其中内层集合中的元素正是我们所需要的。一个更为灵活的方法是使用C#的yield
return语句编写一个迭代器。迭代器是辅助编写集合的C#语言特性，与辅助消费集合的foreach语句方式相同。迭代器自动处理IEnumerable与IEnumerator或是他们泛型版本的实现。下面是一个简单的示例：

.. code:: csharp

    public class MyCollection : IEnumerable
    {
      int[] data = { 1, 2, 3 };
      public IEnumerator GetEnumerator()
      {
        foreach (int i in data)
          yield return i;
      }
    }

注意“黑色魔法”：GetEnumerator看起来根本就没有返回枚举器。通过分析yield
return语句，编译器会在幕后编写一个隐藏的嵌入枚举器类，然后重构GetEnumerator来实例化并返回该类。迭代器是非常强大且简单的（并且是LINQ实现的基础）。

使用这一方法，我们也可以实现泛型接口IEnumerable：

.. code:: csharp

    public class MyGenCollection : IEnumerable<int>
    {
      int[] data = { 1, 2, 3 };
      public IEnumerator<int> GetEnumerator()
      {
        foreach (int i in data)
          yield return i;
      }
      IEnumerator IEnumerable.GetEnumerator()     // Explicit implementation
      {                                           // keeps it hidden.
        return GetEnumerator();
      }
    }

因为IEnumerable实现了IEnuerable，我们必须同时实现GetEnumerator的泛型与非泛型版本。为了与标准实践相一致，我们显式实现了非泛型版本。他可以简单的调用泛型的GetEnumerator，因为IEnumerator实现了IEnumerator。

我们刚刚所编写的类可以适用于作为构建复杂集合的基础。然而，如果我们仅是需要一个简单的IEnumerable实现，yield
return语句可以获得简单的变化。除了编写类，我们可以将迭代逻辑移入返回一个泛型IEnumerable的方法中，并且让编译器来处理其他的内容。如下面的示例：

.. code:: csharp

    public class Test
    {
      public static IEnumerable <int> GetSomeIntegers()
      {
        yield return 1;
        yield return 2;
        yield return 3;
      }
    }

下面是我们实际使用的方法：

.. code:: csharp

    foreach (int i in Test.GetSomeIntegers())
      Console.WriteLine (i);
    // Output
    1
    2
    3

编写GetEnumerator的最后一种方法就是编写直接实现IEnumerator的类。这就是编译器在幕后所做的工作。下面的示例定义了一个硬编码包含1，2与3的集合：

.. code:: csharp

    public class MyIntList : IEnumerable
    {
      int[] data = { 1, 2, 3 };
      public IEnumerator GetEnumerator()
      {
        return new Enumerator (this);
      }
      class Enumerator : IEnumerator       // Define an inner class
      {                                    // for the enumerator.
        MyIntList collection;
        int currentIndex = ?1;
        internal Enumerator (MyIntList collection)
        {
          this.collection = collection;
        }
        public object Current
        {
          get
          {
            if (currentIndex == ?1)
              throw new InvalidOperationException ("Enumeration not started!");
            if (currentIndex == collection.data.Length)
              throw new InvalidOperationException ("Past end of list!");
            return collection.data [currentIndex];
          }
        }
        public bool MoveNext()
        {
          if (currentIndex > collection.data.Length) return false;
          return ++currentIndex < collection.data.Length;
        }
        public void Reset() { currentIndex = ?1; }
      }
    }

注意，第一次调用MoveNext方法应将光标移动列表中的第一个元素上。

为了使用迭代器实现相同的功能，我们必须同时实现IEnumerator。下面是为了简单忽略边界检测的示例：

.. code:: csharp

    class MyIntList : IEnumerable<int>
    {
      int[] data = { 1, 2, 3 };
      // The generic enumerator is compatible with both IEnumerable and
      // IEnumerable<T>. We implement the nongeneric GetEnumerator method
      // explicitly to avoid a naming conflict.
      public IEnumerator<int> GetEnumerator() { return new Enumerator(this); }
      IEnumerator IEnumerable.GetEnumerator() { return new Enumerator(this); }
      class Enumerator : IEnumerator<int>
      {
        int currentIndex = ?1;
        MyIntList collection;
        internal Enumerator (MyIntList collection)
        {
          this.collection = collection;
        }
        public int Current { get { return collection.data [currentIndex]; } }
        object IEnumerator.Current { get { return Current; } }
        public bool MoveNext()
        {
          return ++currentIndex < collection.data.Length;
        }
        public void Reset() { currentIndex = ?1; }
        // Given we don't need a Dispose method, it's good practice to
        // implement it explicitly, so it's hidden from the public interface.
        void IDisposable.Dispose() {}
      }
    }

具有泛型的示例会比较，因为IEnumerator.Current不需要由int转换为object，从而避免了装箱的负担。

ICollection与IList接口
----------------------

尽管枚举接口为在集合上的forward-only迭代提供了协议，但是他们并没有提供相应的机制来确定集合的大小，通过索引访问成员，查找或是修改集合。为了提供这些功能，.NET框架定义了ICollection，IList与IDictionary接口。每一个接口都有泛型与非泛型版本；非泛型版本大多数都是因为遗留原因而存在的。

这些接口的继承层次显示在图7-1中。最简单的总结方式如下：

-  IEnumerable（IEnumerable）：提供了最少的功能（仅是枚举）
-  ICollection（ICollection）：提供了中等功能（例如Count属性）
-  IList/IDictionary及非泛型版本：提供了最大功能（包括通过索引/键的“随机”访问）

泛型与非泛型版本的不同在于我们的期望，特别是ICollection的情况。大多数都是历史原因：因为泛型出现较晚，泛型接口的开发都是事后聪明。由于这个原因，ICollection并没有扩展ICollection，IList并没有扩展IList，而IDictionary也没有扩展IDictionay。当然，集合类本身可以自由实现两个接口版本。

本节将会探讨ICollection，IList及其非泛型版本。

ICollection与ICollection
~~~~~~~~~~~~~~~~~~~~~~~~

ICollection是用于可计数的对象集合的标准接口。他提供了确定集合大小（Count)，在集合中是否存在某个元素（Contains），将集合拷贝到数组（ToArray），并且确定是否为只读（IsReadOnly）等功能。对于可写的集合，我们可以由集合中Add，Remove与Clear元素。并且由于他扩展IEnuerable，他也可以通过foreach语句进行遍历：

.. code:: csharp

    public interface ICollection<T> : IEnumerable<T>, IEnumerable
    {
      int Count { get; }
      bool Contains (T item);
      void CopyTo (T[] array, int arrayIndex);
      bool IsReadOnly { get; }
      void Add(T item);
      bool Remove (T item);
      void Clear();
    }

非泛型版本类似于提供了一个可计数的集合，但是并没有提供修改列表或是检测元素成员关系的功能：

.. code:: csharp

    public interface ICollection : IEnumerable
    {
       int Count { get; }
       bool IsSynchronized { get; }
       object SyncRoot { get; }
       void CopyTo (Array array, int index);
    }

非泛型接口同时定义了同步辅助的接口－他们出现在泛型版本中，因为线程安全不再被认为是集合所固有的。

两个接口都是非常直接来实现的。如果实现了只读的ICollection，Add，Remove与Clear方法应抛出NotSupportException。

这些接口通常是与IList或是IDictionary接口联合实现的。

IList与IList
~~~~~~~~~~~~

IList是用于通过位置索引集合的标准接口。除了由ICollection与IEnumerable所继承的功能以外，他提供了通过位置（索引）读取或写元素以及通过位置插入或删除的功能：

.. code:: csharp

    public interface IList<T> : ICollection<T>, IEnumerable<T>, IEnumerable
    {
      T this [int index] { get; set; }
      int IndexOf (T item);
      void Insert (int index, T item);
      void RemoveAt (int index);
    }

IndexOf方法在列表执行线性搜索，如果没有找到指定的元素则返回-1。

IList的非泛型版本具有更多的成员，因为他由ICollection继承得更少：

.. code:: csharp

    public interface IList : ICollection, IEnumerable
    {
      object this [int index] { get; set }
      bool IsFixedSize { get; }
      bool IsReadOnly  { get; }
      int  Add      (object value);
      void Clear();
      bool Contains (object value);
      int  IndexOf  (object value);
      void Insert   (int index, object value);
      void Remove   (object value);
      void RemoveAt (int index);
    }

非泛型的IList接口的Add方法返回一个整数－这是新添加的元素的索引。相对应的，ICollection的Add方法具有void返回类型。

通用目的的List类是IList与IList的精髓实现。C#数组也实现了泛型与非泛型的IList（尽管添加或是删除元素的方法为显式的接口实现所隐藏，并且如果调用时会抛出NotSupportException）。

Array类
-------

Array类是所有一维与多维数组的隐式基类，而是且实现标准集合接口的最基础类型之一。Array类提供了类型一致性，所以通常的方法集合适用于所有数组，而无论其声明或是底层元素类型。

由于数组是如此基础，C#提供了显式语法用于声明与初始化，我们在第2章与第3章中进行了描述。当使用C#语法声明数组时，CLR隐式继承Array类－合成一个适用于数组维度与元素类型的伪类型。这个伪类型实现了类型泛型集合接口，例如IList。

CLR在构建上对数组进行特殊处理，为其分配一个连续的内存空间。这使得数组中的索引非常高效，但是也阻止了以后的尺寸变化。

Array以泛型与非泛型形式实现了IList集合接口。尽管IList本身是被显式实现的来保持Array的公开接口方法的清晰，例如Add或是Remove，他们在确定长度的集合上会抛出异常，例如数组。Array类确实提供了一个Resize方法，尽管他是通过创建一个新数组并拷贝元素来实现的。除了效率低下，程序中其他位置的指向数组的引用仍然指向原始版本。可调整尺寸的集合的更好解决方法就是使用List类。

Array以泛型与非泛型的方式实现了IList集合接口。IList本身被显式实现，来保持Array的公开接口方法的清晰，例如Add或是Remove方法，这两个方法会在确定的长度的集合上抛出异常，例如数组。Array类确实提供了一个静态的Resize方法，但是这个方法是都是创建一个新数组并拷贝元素来实现的。在效率低下的同时，程序中其他位置指向数组的引用也仍然会指向原始的版本。用于可调整尺寸的集合的更好解决方法是使用List类。

数组可以包含值类型或是引用类似。值类型元素直接存储在数组中，所以包含三个长整形（每个占8个字节）的数组将会占用24个字节的连续内存空间。然而，引用类型元素在数组中只占用引用所需的空间（在32位环境下为4个字节，或是64位环境下的8个字节）。图7-2显示了下列程序中数组在内存中的效果：

.. code:: csharp

    StringBuilder[] builders = new StringBuilder [5];
    builders [0] = new StringBuilder ("builder1");
    builders [1] = new StringBuilder ("builder2");
    builders [2] = new StringBuilder ("builder3");
    long[] numbers = new long [3];
    numbers [0] = 12345;
    numbers [1] = 54321;

.. figure:: csharp_7_2.png
   :alt: csharp_7_2.png

   csharp\_7\_2.png
因为Array是一个类，所以总是引用类型，而无论数组元素的类型是什么。这就意味着语句arrayB
=
arrayA将会导致指向同一个数组的两个引用。类似的，两个不同的数组在相等测试中总是失败－除非我们使用了自定义的比较器。框架4.0提供了一种比较数组或是元组中元素的方法，我们可以通过StructuralComparisions类型来访问：

.. code:: csharp

    object[] a1 = { "string", 123, true };
    object[] a2 = { "string", 123, true };
    Console.WriteLine (a1 == a2);                          // False
    Console.WriteLine (a1.Equals (a2));                    // False
    Console.WriteLine (a1.Equals (a2,
     StructuralComparisons.StructuralEqualityComparer));   // True

数组可以使用Clone方法进行复制：arrayB =
arrayA.Clone()。然而这会得到一个影子拷贝，意味着只有数组本身所表示的内存才会被拷贝。如果数组包含值类型对象，值本身会被拷贝；如果数组包含引用类型对象，只有引用会被拷贝（产生两个数组，其成员指向相同的对象）。图7-3显示了在我们的程序中添加下面代码后的结果：

.. code:: csharp

    StringBuilder[] builders2 = builders;
    StringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();

.. figure:: csharp_7_3.png
   :alt: csharp_7_3.png

   csharp\_7\_3.png
要创建深拷贝－引用类型子对象也被拷贝－我们遍历数组并且手动拷贝每一个元素。同样的规则也适用于其他的.NET集合类型。

尽管数组被设计用来通过32位索引器来使用，但是通过一些可以同时接受Int32与Int64参数的方法，也可以对于64位索引器也具有有限的支持（使得数组在理论上编址2^64个元素）。然而这并没有什么实际用下，因为CLR不会允许一个对象－包括数组－超出2GB的尺寸（无论是在32位还是64位环境中）。

构建与索引
~~~~~~~~~~

创建与索引数组最简单的方法是通过C#的语言构造器：

.. code:: csharp

    int[] myArray = { 1, 2, 3 };
    int first = myArray [0];
    int last = myArray [myArray.Length - 1];

或者是我们可以通过调用Array.CreateInstance动态实例化数组。这可以使得我们在运行时指定元素类型与数组维度，同时允许我们通过指定下界来使用非基于零的数组。非基于零的数组并不是CLS兼容的。

静态的GetValue与SetValue方法可以使得我们访问动态创建的数组中的元素（他们也可以应用于普通的数组）：

.. code:: csharp

     // Create a string array 2 elements in length:
     Array a = Array.CreateInstance (typeof(string), 2);
     a.SetValue ("hi", 0);                             //  → a[0] = "hi";
     a.SetValue ("there", 1);                          //  → a[1] = "there";
     string s = (string) a.GetValue (0);               //  → s = a[0];
     // We can also cast to a C# array as follows:
     string[] cSharpArray = (string[]) a;
     string s2 = cSharpArray [0];

动态创建的零索引的数组可以转换为匹配或是兼容类型的C#数组。例如，如果Apple继承于Fruit，Apple[]可以转换为Fruit[]。这就引出了为什么object[]不用作唯一的数组类型而是使用Array类。这是因为object[]并不与多维数组和值类型数组（以及非基于零的数组）兼容。int[]数组不可以转换为ojbect[]。因此我们需要Array类作为完全类型一致。

GetValue与SetValue也适用于编译器所创建的数组，并且当编写处理任意类型与任意维度的数组时，这两个方法十分有用。对于多维数组，他们接受索引器的数组：

.. code:: csharp

    public object GetValue (params int[] indices)
    public void   SetValue (object value, params int[] indices)

下列方法输出了数组的第一个元素，而不论其维度：

.. code:: csharp

     void WriteFirstValue (Array a)
     {
       Console.Write (a.Rank + "-dimensional; ");
       // The indexers array will automatically initialize to all zeros, so
       // passing it into GetValue or SetValue will get/set the zero-based
       // (i.e., first) element in the array.
       int[] indexers = new int[a.Rank];
       Console.WriteLine ("First value is " +  a.GetValue (indexers));
     }
     void Demo()
     {
       int[]  oneD = { 1, 2, 3 };
       int[,] twoD = { {5,6}, {8,9} };
       WriteFirstValue (oneD);   // 1-dimensional; first value is 1
       WriteFirstValue (twoD);   // 2-dimensional; first value is 5
     }

当一个数组被实例化时，无论是通过语言语法还是Array.CreateInstance，其元素是被自动初始化的。对于引用类型元素的数组，这就意味着初始化为null；对于值类型元素的数组，这就意味着调用值类型的默认构造器。Array数组也可以通过Clear方法在需要时提供这一功能：

public static void Clear (Array array, int index, int length);

这个方法并不会影响数组的尺寸。这是与Clear的通常用法相对应的（例如ICollection.Clear），其中集合会被缩小为零元素。

枚举
~~~~

数组可以很容易使用foreach语句进行枚举：

.. code:: csharp

    int[] myArray = { 1, 2, 3};
    foreach (int val in myArray)
      Console.WriteLine (val);

我们也可以使用静态的Array.ForEach方法进行枚举，其定义如下：

public static void ForEach (T[] array, Action action);

该方法使用Action委托，其签名如下：

public delegate void Action (T obj);

下面是使用Array.ForEach重写的示例：

Array.ForEach (new[] { 1, 2, 3 }, Console.WriteLine);

长度与维度
~~~~~~~~~~

Array提供下列方法与属性用于查询长度与维度：

.. code:: csharp

    public int  GetLength      (int dimension);
    public long GetLongLength  (int dimension);
    public int  Length       { get; }
    public long LongLength   { get; }
    public int GetLowerBound (int dimension);
    public int GetUpperBound (int dimension);
    public int Rank { get; }    // Returns number of dimensions in array

GetLength与GetLongLength返回指定维度的长度（0用于一维数组），而Length与LongLength返回数组中元素的总数目－包括所有维度。

GetLowerBound与GetUpperBound对于非零索引的数组十分有用。GetUpperBound所返回的结果与GetLowerBound加上任意指定维度的GetLength的值相同。

搜索
~~~~

Array类提供了下列方法用于在一维数组中查找元素：

.. code:: csharp

    public static int BinarySearch<T> (T[] array,   object value);
    public static int BinarySearch<T> (T[] array,   object value, IComparer<T>
                                                                  comparer);
    public static int BinarySearch    (Array array, object value);
    public static int BinarySearch    (Array array, object value, IComparer
                                                                  comparer);
    public static int IndexOf<T>      (T[] array,   T value);
    public static int IndexOf         (Array array, object value);
    public static int LastIndexOf<T>  (T[] array,   T value);
    public static int LastIndexOf     (Array array, object value);
    // Predicate-based searching:
    public static T    Find<T>        (T[] array, Predicate<T> match);
    public static T    FindLast<T>    (T[] array, Predicate<T> match);
    public static T[]  FindAll<T>     (T[] array, Predicate<T> match);
    public static bool Exists<T>        (T[] array, Predicate<T> match);
    public static bool TrueForAll<T>    (T[] array, Predicate<T> match);
    public static int  FindIndex<T>     (T[] array, Predicate<T> match);
    public static int  FindLastIndex<T> (T[] array, Predicate<T> match);

同时以粗体显示的方法被重载来接受下面的额外参数：

.. code:: csharp

    int index   // starting index at which to begin searching
    int length  // maximum number of elements to search

如果指定的值没有找到，这些方法都不会抛出异常。相反，如果元素没有找到，则方法会返回整数-1（假定是零索引数组），而返回泛型类型的方法会返回类型的默认值。

二分查找方法非常快速，但是该方法只适用于已排序的数组，并且要求元素可以比较顺序，而不是简单的相等。为此，二分查找方法可以接受IComparer或是IComparer对象来确定顺序。这必须与在普通排序数组中所用的任意比较器相一致。如果没有提供比较器，则会应用类型的默认排序算法，基于其IComparable/IComparable实现。

IndexOf与LastIndexOf方法在数组上执行简单的遍历，返回与指定的值匹配的第一个元素（或最后一个）的位置。

基于预测的搜索算法使用一个方法委托或是Lambda表达式来判断一个匹配的元素是否匹配。预测只是一个简单的接受对象的委托，并且返回true或false：

public delegate bool Predicate (T object);

在下面的示例中，我们在数据中查找包含字符a的名字：

.. code:: csharp

    static void Main()
    {
      string[] names = { "Rodney", "Jack", "Jill" };
      string match = Array.Find (names, ContainsA);
      Console.WriteLine (match);     // Jack
    }
    static bool ContainsA (string name) { return name.Contains ("a"); }

下面是使用匿名方法实现的相同代码：

.. code:: csharp

    string[] names = { "Rodney", "Jack", "Jill" };
    string match = Array.Find (names, delegate (string name)
      { return name.Contains ("a"); } );

Lambda表达式可以进一步精简代码：

.. code:: csharp

    string[] names = { "Rodney", "Jack", "Jill" };
    string match = Array.Find (names, n => n.Contains ("a"));     // Jack

FindAll返回一个满足预测的所有元素的数组。事实上，他与System.Linq名字空间中的Enumerable.Where等同，所不同的是FindAll返回一个匹配元素的数组，而不是相同的IEnumerable。

Exists方法会在数组成员满足指定的预测时返回true，并且与System.Linq.Enumerable中的Any等同。

TrueForAll会在所有元素满足预测时返回true，并且与System.Linq.Enumerable中的All等同。

排序
~~~~

Array具有下列内建的排序方法：

.. code:: csharp

    // For sorting a single array:
    public static void Sort<T> (T[] array);
    public static void Sort    (Array array);
    // For sorting a pair of arrays:
    public static void Sort<TKey,TValue> (TKey[] keys, TValue[] items);
    public static void Sort              (Array keys, Array items);

所有这些方法都被重载以接受下列参数：

.. code:: csharp

    int index                 // Starting index at which to begin sorting
    int length                // Number of elements to sort
    IComparer<T> comparer     // Object making ordering decisions
    Comparison<T> comparison  // Delegate making ordering decisions

下列代码演示了Sort的简单用法：

.. code:: csharp

    int[] numbers = { 3, 2, 1 };
    Array.Sort (numbers);                     // Array is now { 1, 2, 3 }

接受一对数组的方法会基于第一个数组的顺序先后重排每个数组中的元素。在下面的示例中，数字与相对应的单词都会以数值顺序进行排序：

.. code:: csharp

    int[] numbers = { 3, 2, 1 };
    string[] words = { "three", "two", "one" };
    Array.Sort (numbers, words);
    // numbers array is now { 1, 2, 3 }
    // words   array is now { "one", "two", "three" }

Array.Sort要求数组中的元素实现IComparable。这就意味着大多数的基础C#类型（例如整数）都可以进行排序。如果元素本身不能比较，或者是我们希望重写默认的排序方法，我们必须提供一个带有报告两个元素相对位置的自定义comparison提供的Sort。有两种方法来实现：

-  通过实现了IComparer/IComparer的助手对象
-  通过Comparison委托：public delegate int Comparison (T x, T y);

Comparison委托遵循与IComparer.CompareTo相同的语义：如果x在y的前面，则会返回一个负数；如果x在y的后面，则会返回一个正数；如果x与y具有相同的排序位置，则返回0。

在下面的示例中，我们对整数数组进行排序，从而使得奇数在前面：

.. code:: csharp

    int[] numbers = { 1, 2, 3, 4, 5 };
    Array.Sort (numbers, (x, y) => x % 2 == y % 2 ? 0 : x % 2 == 1 ? ?1 : 1);
    // numbers array is now { 3, 5, 1, 2, 4 }

反转元素
~~~~~~~~

下面的Array方法反转数组中的全部或是部分元素顺序：

.. code:: csharp

    public static void Reverse (Array array);
    public static void Reverse (Array array, int index, int length);

拷贝，转换与尺寸调整
~~~~~~~~~~~~~~~~~~~~

Array提供了浅拷贝与克隆方法：

.. code:: csharp

    // Instance methods:
    public object Clone();
    public void CopyTo (Array array, int index);
    // Static methods:
    public static void Copy (Array sourceArray,
                             Array destinationArray,
                             int length);
    public static void Copy (Array sourceArray,      int sourceIndex,
                             Array destinationArray, int destinationIndex,
                             int length);
    public static void ConstrainedCopy (
                             Array sourceArray,      int sourceIndex,
                             Array destinationArray, int destinationIndex,
                             int length);
    public static ReadOnlyCollection<T> AsReadOnly<T> (T[] array)
    public static TOutput[] ConvertAll<TInput, TOutput>
      (TInput[] array, Converter<TInput, TOutput> converter)
    public static void Resize<T> (ref T[] array, int newSize);

Copy与CopyTo方法被重载来接受Int64索引参数。

Clone方法返回一个完全新的数组（浅拷贝）。Copy与CopyTo方法拷贝数组中的一个连续子集。拷贝多维矩形数组要求我们将多维索引映射到线性索引。例如，3x3数组的中间块（position[1,1]）被表示为索引4，计算方法为1\*3+1。源与目标范围可以重叠而不会产生问题。

ConstrainedCopy执行原子操作：如果所请求的所有元素不能被成功拷贝（例如由于类型错误），则会回滚操作。

AsReadOnly返回一个阻止元素被重新赋值的包装器。ConvertAll创建并返回一个TOutput类型元素的新数组，调用所提供的Converter委托来拷贝元素。Converter定义如下：

public delegate TOutput Converter (TInput input)

下面的代码将一个浮点数组转换为一个整数数组：

.. code:: csharp

    float[] reals = { 1.3f, 1.5f, 1.8f };
    int[] wholes = Array.ConvertAll (reals, r => Convert.ToInt32 (r));
    // wholes array is { 1, 2, 2 }

Resize方法通过创建一个新数组并拷贝元素来实现，通过索引参数返回一个新数组。然而，其他对象中指向原始数组的引用会保持不变。

列表，队列，栈与集合
--------------------

框架提供了一个实现本章前面所描述的接口的具体集合类的集合。本章关注于列表类集合。正如我们前面所讨论的接口，对于每一个类型我们通常都会有泛型与非泛型版本的选择。考虑到灵活性与性能，泛型类会更胜一筹，保留非泛型版本的原因是为了向后兼容。这与集合接口的情况不同，后者非泛型版本依然有用。

在本节所讨论的这些为中，泛型的List类是最经常使用的。

List与ArrayList
~~~~~~~~~~~~~~~

泛型List与非泛型的ArrayList类提供了尺寸动态变化的对象数组，并且是最经常使用的集合类之一。ArrayList实现了IList，而List同时实现了IList与IList。与数组不同，所有的接口都是公开实现的，并且方法，例如Add与Remove都被公开，并如我们所期望的样子工作。

在内部，List与ArrayList通过维护一个内部对象数组，并且当到达容量极限时使用一个更大的数组替换的方式来实现。添加元素效率较高（因为通常在结尾处总是有空位置），但是插入元素很慢（因为插入位置之后的所有元素都必须移动以空出一个位置）。类似于数组，如果在一个已排序的列表上使用BinarySearch方法，则查找的效率较高，否则效率较低，因为每一个元素都必须进行单独检测。

List与ArrayList提供了接受一个已存在的元素集合的构造器：这些构造器会将已存在集合中的元素拷贝到新的List或是ArrayList中：

.. code:: csharp

    public class List <T> : IList <T>
    {
      public List ();
      public List (IEnumerable<T> collection);
      public List (int capacity);
      // Add+Insert
      public void Add         (T item);
      public void AddRange    (IEnumerable<T> collection);
      public void Insert      (int index, T item);
      public void InsertRange (int index, IEnumerable<T> collection);
      // Remove
      public bool Remove      (T item);
      public void RemoveAt    (int index);
      public void RemoveRange (int index, int count);
      public int  RemoveAll   (Predicate<T> match);
      // Indexing
      public T this [int index] { get; set; }
      public List<T> GetRange (int index, int count);
      public Enumerator<T> GetEnumerator();
      // Exporting, copying and converting:
      public T[] ToArray();
      public void CopyTo (T[] array);
      public void CopyTo (T[] array, int arrayIndex);
      public void CopyTo (int index, T[] array, int arrayIndex, int count);
      public ReadOnlyCollection<T> AsReadOnly();
      public List<TOutput> ConvertAll<TOutput> (Converter <T,TOutput>
                                                converter);
      // Other:
      public void Reverse();            // Reverses order of elements in list.
      public int Capacity { get;set; }  // Forces expansion of internal array.
      public void TrimExcess();         // Trims internal array back to size.
      public void Clear();              // Removes all elements, so Count=0.
    }

    public delegate TOutput Converter <TInput, TOutput> (TInput input);

除了这些成员，List还提供了所有Array的搜索与排序方法的实例版本。

下面的代码演示了List的属性与方法。

.. code:: csharp

    List<string> words = new List<string>();    // New string-typed list
    words.Add ("melon");
    words.Add ("avocado");
    words.AddRange (new[] { "banana", "plum" } );
    words.Insert (0, "lemon");                           // Insert at start
    words.InsertRange (0, new[] { "peach", "nashi" });   // Insert at start
    words.Remove ("melon");
    words.RemoveAt (3);                         // Remove the 4th element
    words.RemoveRange (0, 2);                   // Remove first 2 elements
    // Remove all strings starting in 'n':
    words.RemoveAll (s => s.StartsWith ("n"));
    Console.WriteLine (words [0]);                          // first word
    Console.WriteLine (words [words.Count - 1]);            // last word
    foreach (string s in words) Console.WriteLine (s);      // all words
    List<string> subset = words.GetRange (1, 2);            // 2nd->3rd words
    string[] wordsArray = words.ToArray();    // Creates a new typed array
    // Copy first two elements to the end of an existing array:
    string[] existing = new string [1000];
    words.CopyTo (0, existing, 998, 2);
    List<string> upperCastWords = words.ConvertAll (s => s.ToUpper());
    List<int> lengths = words.ConvertAll (s => s.Length);

非泛型的ArrayList类主要用于与框架1.x的代码兼容，并且需要笨拙的转换，如下面的代码所示：

.. code:: csharp

    ArrayList al = new ArrayList();
    al.Add ("hello");
    string first = (string) al [0];
    string[] strArr = (string[]) al.ToArray (typeof (string));

这些转换并能通过编译器验证；下面的代码可以成功编译但是会在运行时失败：

int first = (int) al [0]; // Runtime exception

如果我们引入System.Linq名字空间，我们可以通过调用Cast与ToList来将ArrayList转换为泛型List：

.. code:: csharp

    ArrayList al = new ArrayList();
    al.AddRange (new[] { 1, 5, 9 } );
    List<int> list = al.Cast<int>().ToList();

Cast与ToList是System.Linq.Enumerable类中的扩展方法，由.NET框架3.5所支持。

LinkedList
~~~~~~~~~~

LinkedList是一个泛型双向链表。双向链表是一个节点链，其中的每一个节点指向前面的节点，后面的节点以及实际的元素。其主要优点在于元素可以被高效的插入到列表中的任意位置，因为他只涉及到创建一个新的节点并且更某些引用。然而，确定在哪里插入节点会非常慢，因为并没有固有的机制来直接索引链表；必须遍历每一个节点，而且二分查找是不可能的。

LinkedList实现了IEnumerable与ICollection（以及他们的非泛型版本），但是没有实现IList，因为通过索引访问并不被支持。列表节点通过下列类实现：

.. code:: csharp

    public sealed class LinkedListNode<T>
    {
      public LinkedList<T> List { get; }
      public LinkedListNode<T> Next { get; }
      public LinkedListNode<T> Previous { get; }
      public T Value { get; set; }
    }

当添加节点时，我们可以相对于其他节点指定位置或是在列表的开头与结束处插入。LinkedList提供了下列方法来插入节点：

.. code:: csharp

    public void AddFirst(LinkedListNode<T> node);
    public LinkedListNode<T> AddFirst (T value);
    public void AddLast (LinkedListNode<T> node);
    public LinkedListNode<T> AddLast (T value);
    public void AddAfter (LinkedListNode<T> node, LinkedListNode<T> newNode);
    public LinkedListNode<T> AddAfter (LinkedListNode<T> node, T value);
    public void AddBefore (LinkedListNode<T> node, LinkedListNode<T> newNode);
    public LinkedListNode<T> AddBefore (LinkedListNode<T> node, T value);

.. figure:: csharp_7_4.png
   :alt: csharp_7_4.png

   csharp\_7\_4.png
类似的方法被提供用来删除元素：

.. code:: csharp

    public void Clear();
    public void RemoveFirst();
    public void RemoveLast();
    public bool Remove (T value);
    public void Remove (LinkedListNode<T> node);

LinkedList具有一个跟踪列表中元素数目以及列表头与列表尾的内部域。他们通过下列的公开属性向外界公开：

.. code:: csharp

    public int Count { get; }                      // Fast
    public LinkedListNode<T> First { get; }        // Fast
    public LinkedListNode<T> Last { get; }         // Fast

LinkedList同时支持下列的搜索方法（每一个方法都要求列表是可枚举的）：

.. code:: csharp

    public bool Contains (T value);
    public LinkedListNode<T> Find (T value);
    public LinkedListNode<T> FindLast (T value);

最后，LinkedList支持拷贝到数组用于索引处理以及获取枚举器来支持foreach语句：

.. code:: csharp

    public void CopyTo (T[] array, int index);
    public Enumerator<T> GetEnumerator();

下面演示了LinkedList的使用：

.. code:: csharp

    var tune = new LinkedList<string>();
    tune.AddFirst ("do");                           // do
    tune.AddLast ("so");                            // do - so
    tune.AddAfter (tune.First, "re");               // do - re - so
    tune.AddAfter (tune.First.Next, "mi");          // do - re - mi - so
    tune.AddBefore (tune.Last, "fa");               // do - re - mi - fa - so
    tune.RemoveFirst();                             // re - mi - fa - so
    tune.RemoveLast();                              // re - mi - fa
    LinkedListNode<string> miNode = tune.Find ("mi");
    tune.Remove (miNode);                           // re - fa
    tune.AddFirst (miNode);                         // mi - re - fa
    foreach (string s in tune) Console.WriteLine (s);

Queue与Queue
~~~~~~~~~~~~

Queue与Queue是先进先出（FIFO）的数据结构，提供了Enqueue（添加一个元素到队列尾）与Dequeue（获取并删除队列头的元素）方法。同时提供了一个Peek方法来返回队列的元素，但是并不删除，以及一个Count属性（用于在删除之前检测所存在的元素）。

尽管队列是可枚举的，他们并没有实现IList/IList，因为成员并不能直接通过索引进行访问。然而提供了一个ToArray方法用于将元素拷贝到一个数组，而后者可以进行随机访问：

.. code:: csharp

    public class Queue<T> : IEnumerable<T>, ICollection, IEnumerable
    {
      public Queue();
      public Queue (IEnumerable<T> collection);   // Copies existing elements
      public Queue (int capacity);                // To lessen auto-resizing
      public void Clear();
      public bool Contains (T item);
      public void CopyTo (T[] array, int arrayIndex);
      public int Count { get; }
      public T Dequeue();
      public void Enqueue (T item);
      public Enumerator<T> GetEnumerator();       // To support foreach
      public T Peek();
      public T[] ToArray();
      public void TrimExcess();
    }

下面的代码是一个使用Queue的示例：

.. code:: csharp

    var q = new Queue<int>();
    q.Enqueue (10);
    q.Enqueue (20);
    int[] data = q.ToArray();         // Exports to an array
    Console.WriteLine (q.Count);      // "2"
    Console.WriteLine (q.Peek());     // "10"
    Console.WriteLine (q.Dequeue());  // "10"
    Console.WriteLine (q.Dequeue());  // "20"
    Console.WriteLine (q.Dequeue());  // throws an exception (queue empty)

队列在内部使用一个尺寸在需要可以调整的数组来实现的，非常类似于泛型List类。队列维护直接指向头元素与尾元素的索引；所以插入队列与删除队列是非常快速的操作（除了内部尺寸需要调整时）。

Stack与Stack
~~~~~~~~~~~~

Stack与Stack是后进先出（LIFO）的数据结构，提供了Push（将元素压入到栈顶）与Pop（由栈顶获取并移除元素）方法。同时提供不具有破坏性的Peek方法以及Count属性与导出数据用于随机访问的ToArray方法：

.. code:: csharp

    public class Stack<T> : IEnumerable<T>, ICollection, IEnumerable
    {
      public Stack();
      public Stack (IEnumerable<T> collection);   // Copies existing elements
      public Stack (int capacity);                // Lessens auto-resizing
      public void Clear();
      public bool Contains (T item);
      public void CopyTo (T[] array, int arrayIndex);
      public int Count { get; }
      public Enumerator<T> GetEnumerator();       // To support foreach
      public T Peek();
      public T Pop();
      public void Push (T item);
      public T[] ToArray();
      public void TrimExcess();
    }

下面的代码演示了Stack的使用示例：

.. code:: csharp

    var s = new Stack<int>();
    s.Push (1);                      //            Stack = 1
    s.Push (2);                      //            Stack = 1,2
    s.Push (3);                      //            Stack = 1,2,3
    Console.WriteLine (s.Count);     // Prints 3
    Console.WriteLine (s.Peek());    // Prints 3,  Stack = 1,2,3
    Console.WriteLine (s.Pop());     // Prints 3,  Stack = 1,2
    Console.WriteLine (s.Pop());     // Prints 2,  Stack = 1
    Console.WriteLine (s.Pop());     // Prints 1,  Stack = <empty>
    Console.WriteLine (s.Pop());     // throws exception

与Queue和List类似，栈在内部使用尺寸在需要可以调整的数组来实现。

BitArray
~~~~~~~~

BitArray是一个紧凑bool值的动态尺寸集合。他要比一个简单的bool数组与一个bool的泛型List更节省内存，因为对于每个值他只有一位来表示，否则每一个bool类型要占一个字节：

.. code:: csharp

    public sealed class BitArray : ICollection, IEnumerable, ICloneable
    {
      // Constructors
      public BitArray (BitArray bits);    // An existing BitArray to copy
      public BitArray (int length);       // Capacity, in bits
      public BitArray (bool[] values);
      public BitArray (byte[] bytes);
      public BitArray (int[] values);
      public BitArray (int length, bool defaultValue);
      // To get/set value
      public bool this [int index] { get; set; }
      public bool Get  (int index);
      public void Set  (int index, bool value);
      public void SetAll (bool value);
      // Bitwise operators
      public BitArray Not();
      public BitArray And (BitArray value);
      public BitArray Or  (BitArray value);
      public BitArray Xor (BitArray value);
      // Copying
      public void CopyTo (Array array, int index);
      public object Clone();
      // Other
      public IEnumerator GetEnumerator();
      public int  Count          { get; }
      public int  Length         { get; set; }
      public bool IsReadOnly     { get; }
      public bool IsSynchronized { get; }
      public object SyncRoot     { get; }
    }

下面的代码是一个BitArray类：

.. code:: csharp

    var bits = new BitArray(2);
    bits[1] = true;
    bits.Xor (bits);               // Bitwise exclusive-OR bits with itself
    Console.WriteLine (bits[1]);   // False

HashSet新SortedSet
~~~~~~~~~~~~~~~~~~

HashSet与SortedSet分别是由.NET框架3.5与4.0所引入的新的泛型集合。他们具有下列特点：

-  他们的Contains方法使用基于散列的查找可以快速执行
-  他们不存储重复元素，并且会静默忽略添加重复元素的请求
-  我们不可以通过位置访问元素

SortedSet顺序保存元素，而HashSet则不会。

HashSet是使用一个只存储键的散列表来实现的；SortedSet是使用红黑树来实现的。

下面是HashSet的定义：

.. code:: csharp

    public class HashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable
    {
      // Constructors
      public HashSet();
      public HashSet (IEnumerable<T> collection);
      public HashSet (IEqualityComparer<T> comparer);
      public HashSet (IEnumerable<T> collection, IEqualityComparer<T> comparer);
      // Testing for membership
      public bool Contains (T item);
      // Adding / removing
      public bool Add    (T item);
      public bool Remove (T item);
      public int RemoveWhere (Predicate<T> match);
      public void Clear();
      // Set operations - destructive
      public void UnionWith           (IEnumerable<T> other);   // Adds
      public void IntersectWith       (IEnumerable<T> other);   // Removes
      public void ExceptWith          (IEnumerable<T> other);   // Removes
      public void SymmetricExceptWith (IEnumerable<T> other);   // Removes
      // Set operations - bool
      public bool IsSubsetOf         (IEnumerable<T> other);
      public bool IsProperSubsetOf   (IEnumerable<T> other);
      public bool IsSupersetOf       (IEnumerable<T> other);
      public bool IsProperSupersetOf (IEnumerable<T> other);
      public bool Overlaps           (IEnumerable<T> other);
      public bool SetEquals          (IEnumerable<T> other);
      // Other
      public int Count { get; }
      public IEqualityComparer<T> Comparer { get; }
      public void CopyTo (T[] array);
      public void CopyTo (T[] array, int arrayIndex);
      public void CopyTo (T[] array, int arrayIndex, int count);
      public void TrimExcess();
      public static IEqualityComparer<HashSet<T>> CreateSetComparer();
    }

SortedSet是提供相同成员集合的基础上，还提供了下列成员：

.. code:: csharp

    public virtual SortedSet<T> GetViewBetween (T lowerValue, T upperValue)
    public IEnumerable<T> Reverse()
    public T Min { get; }
    public T Max { get; }

SortedSet同时在其构造器中接受一个可选的IComparer（并不是相等比较器）。

下面的代码由一个已存在的集合构建一个HashSet，测试其成员关系，并在集合上进行枚举（注意没有重复元素）：

.. code:: csharp

    var letters = new HashSet<char> ("the quick brown fox");
    Console.WriteLine (letters.Contains ('t'));      // true
    Console.WriteLine (letters.Contains ('j'));      // false
    foreach (char c in letters) Console.Write (c);   // the quickbrownfx

（我们可以向HashSet的构造器传递string的原因是因为string实现了IEnumerable）

下面是相同的字符串载入SortedSet中的示例：

.. code:: csharp

    var letters = new SortedSet<char> ("the quick brown fox");
    foreach (char c in letters) Console.Write (c);   //  bcefhiknoqrtuwx

继续这个示例，我们可以获得f与j之间字符，如下所示：

.. code:: csharp

    foreach (char c in letters.GetViewBetween ('f', 'j'))
      Console.Write (c);                                    //  fhk

破坏性的集合操作符修改原始集合。UnionWith将第二个集合中的所有元素添加到原始集合中（排除重复元素）。IntersectsWith移除没有同时存在于两个集合中的元素。在下面的代码中我们由我们的字符集合中移除了所有的元音字符：

.. code:: csharp

    var letters = new HashSet<char> ("the quick brown fox");
    letters.IntersectWith ("aeiou");
    foreach (char c in letters) Console.Write (c);     // euio

ExceptWith由原始集合中移除指定的元素。在这里，我们由集合中去掉所有的元音字符：

.. code:: csharp

    var letters = new HashSet<char> ("the quick brown fox");
    letters.ExceptWith ("aeiou");
    foreach (char c in letters) Console.Write (c);     // th qckbrwnfx

SymmetricExceptWith移除除唯一属于一个集合之外的元素之外的所有元素：

.. code:: csharp

    var letters = new HashSet<char> ("the quick brown fox");
    letters.SymmetricExceptWith ("the lazy brown fox");
    foreach (char c in letters) Console.Write (c);     // quicklazy

因为HashSet与SortedSet实现了IEnumerable，我们可以使用另一个集合作为任意集合操作方法的参数。

字典
----

字典是一个集合，其中每一个元素是一个键值对。字典最经常用于查找与有序列表。

框架通过IDictionary与IDictionary为了字典定义了标准协议，以及一个通用的字典类集合。类之间的区别主要有以下几点：

-  元素是否以有序序列存储
-  元素是否可以通过位置（索引）以及键进行访问
-  是否为泛型
-  当尺寸较大的性能

表7-1总结所有的字典类以及他们在以上几方面的区别。性能以毫秒计数，是在一个1.5GHz的PC上，在一个整数键值的字典上执行50000操作得出的。（在使用相同底层集合结构的泛型与非泛型版本之间的区别是由于装箱造成的，并且只显示了值类型元素。）

.. figure:: csharp_table_7_1.png
   :alt: csharp_table_7_1.png

   csharp\_table\_7\_1.png
以大O的概念来看，按键获取的时间如下：

-  Hashtable，Dictionary以及OrderedDictionary为O(1)
-  SortedDictionary与SortedList为O(logn)
-  ListDictionary（以及非字典类型例如List）为O(n)

其中n为集合中的元素数目。

IDictionary
~~~~~~~~~~~

IDictionary为所有基于键值的集合定义了标准协议。他通过添加了基于任意类型的键访问元素的方法与属性扩展了ICollection：

.. code:: csharp

    public interface IDictionary <TKey, TValue> :
      ICollection <KeyValuePair <TKey, TValue>>, IEnumerable
    {
       bool ContainsKey (TKey key);
       bool TryGetValue (TKey key, out TValue value);
       void Add         (TKey key, TValue value);
       bool Remove      (TKey key);
       TValue this [TKey key]      { get; set; }  // Main indexer - by key
       ICollection <TKey> Keys     { get; }       // Returns just keys
       ICollection <TValue> Values { get; }       // Returns just values
    }

要向字典添加元素，我们可以调用Add方法或是使用索引的set访问器－后者会在键不存在的情况下向字典添加元素（如果存在则更新元素）。在所有的字典实现中，重复键是被禁止的，所以使用相同的键调用两次Add会抛出异常。

要由字典中获取元素，使用索引器或是TryGetValue方法。如果键不存在，索引器会抛出异常，而TryGetValue会返回false。我们可以通过显式调用ContainsKey来测试成员关系；然而，如果我们随后读取元素则会产生两次查询的代价。

直接在IDictionary上枚举会返回一个KeyValuePair结构序列：

.. code:: csharp

    public struct KeyValuePair <TKey, TValue>
    {
      public TKey Key     { get; }
      public TValue Value { get; }
    }

我们可以通过字典的Keys/Values属性只在键或是只在值上枚举。

在下面的内容中我们会使用泛型的Dictionary类来演示这个接口的用法。

IDictionary
~~~~~~~~~~~

除了两个重要的功能不同以外，非泛型的IDictionary在原则上与IDictionary相同。清楚这些不同是很重要的，因为IDictionary出现在遗留代码中（包括.NET框架本身）：

-  通过索引器获取不存在的键会返回null（而不是抛出异常）
-  Contains测试成员关系，而不是ContainsKey

在非泛型的IDictionary上枚举返回一个DictionaryEntry结构序列：

.. code:: csharp

    public struct DictionaryEntry
    {
      public object Key   { get; set; }
      public object Value { get; set; }
    }

Dictionary与Hashtable
~~~~~~~~~~~~~~~~~~~~~

泛型Dictionary类是最经常用到的类之一（与List集合）。他使用散列表数据结构来存储键与值，且其快速高效。

Dictionary同时实现了泛型与非泛型的IDictionary接口，泛型IDictionary向外公开。事实上，Dictionary是泛型IDictionary的“教科书”实现。

下面的代码演示了如何来使用：

.. code:: csharp

    var d = new Dictionary<string, int>();
    d.Add("One", 1);
    d["Two"] = 2;     // adds to dictionary because "two" not already present
    d["Two"] = 22;    // updates dictionary because "two" is now present
    d["Three"] = 3;
    Console.WriteLine (d["Two"]);                // Prints "22"
    Console.WriteLine (d.ContainsKey ("One"));   // true (fast operation)
    Console.WriteLine (d.ContainsValue (3));     // true (slow operation)
    int val = 0;
    if (!d.TryGetValue ("onE", out val))
      Console.WriteLine ("No val");              // "No val" (case sensitive)
    // Three different ways to enumerate the dictionary:
    foreach (KeyValuePair<string, int> kv in d)          //  One ; 1
      Console.WriteLine (kv.Key + "; " + kv.Value);      //  Two ; 22
                                                         //  Three ; 3
    foreach (string s in d.Keys) Console.Write (s);      // OneTwoThree
    Console.WriteLine();
    foreach (int i in d.Values) Console.Write (i);       // 1223

其底层的散列表是通过将每一个元素的键转换为一个整数散列值－一个伪唯一值－然后应该用算法将散列值转换散列键来起作用的。这个散列值用来在内部确定一个对象属性于哪一“桶”。如果该
位置包含多个值，则在该位置上执行线性搜索。散列表通常由1:1的桶与值比率开始（1:1负载因子），意味着每一个位置只包含一个值。然而，随着更多的元素被添加到散列表中，负载因子会以一种精心设计来优化插入与读取性能以及内存需求的方式动态增长。

字典可以处理任意类型的键，只要他能够确定键与相应的散列值的相等关系。默认情况下，通过键的object.Equals方法来确定相等关系，而伪唯一的散列值是通过键的GetHashCode方法来获得的。这种行为可以通过重写这些方法或是通过在构造字典时提供一个IEqualityComparer对象来修改。这种方法的一个应用是当使用字符串键时指定一个大小写不敏感的比较器：

var d = new Dictionary (StringComparer.OrdinalIgnoreCase);

类似于许多其他的集合类型，字典的性能可以通过在构造器中指定所期望的集合尺寸进行改善，从而避免或是减少在内部调整尺寸的操作。

非泛型版本名为HashTable，并且与其泛型版本在功能上类似，所不同的是他阻止公开我们在前面所讨论的非泛型IDictionary接口。

Dictionary与Hashtable的缺点就是其元素并没有被排序。而且元素被添加的原始顺序也没有被保留。与所有的字典类似，重复的键是不允许的。

OrderedDictionary
~~~~~~~~~~~~~~~~~

OrderedDictionary是一个以元素被添加的顺序维度元素的非泛型字典。使用OrderedDictioanry，我们可以通过索引或是键来访问元素。

OrderedDictionary是Hashtable与ArrayList的组合。这就意味着他具有Hashtable的所有功能，同时具有例如RemoveAt以及整数索引器的功能。他同时公开了以其原始顺序返回元素的Keys与Values属性。

这个类是在.NET 2.0中引入的，而且并没有泛型版本。

ListDictionary与HybridDictionary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ListDictionary使用一个链表存储底层数据。他并没有提供排序，但是却保持了元素的原始顺序。ListDictionary对于大列表十分慢。他只声明对于小列表（小于10个元素）的高效。

HybridDictionary是在到达特定的尺寸时自动转换为Hashtable的ListDictionary，从而来解决ListDictionary的性能问题。其思想在字典很小时占用较少的内存，而字典变大时获得较好的性能。然而，在指定转换负载的情况下－而事实上Dictionary在两种场景中并不十分沉重或是慢－由Dictionary开始并非不合理。

两个类都只有非泛型形式。

有序字典
~~~~~~~~

框架提供了两种在内部按键对其内容进行排序的字典类：

-  SortedDictionary
-  SortedList

（在本节中我们会简写为或是<,>）

SortedDictionary<,>使用红黑树：一种被设计用来在元素插入与元素读取场景中保持一致性能的数据结构。

SortedList<,>在内部使用有序数组对实现，提供快速调取（通过二分查找）但是较差的插入性能（因为已存在的值必须移动来为新元素提供空间）。

在随机序列中插入元素方法（特别是大列表），SortedDictionary<,>要快于SortedList<,>。然而，SortedList<,>具有其他的能力：通过索引或是键访问元素。对于有序列表，我们可以直接到达到有序序列中的第n个元素（通过Keys/Values属性上的索引器）。要使用SortedDictionary<,>执行相同的操作，我们必须在n个元素上进行枚举。（或者是我们可以编写一个组合了有序字典与列表类的新类。）

这三个集合都不允许重复键。

下面的示例使用反射将定义在System.Object中的所有方法载入到一个以名字为键的有序列表中，然后在其键与值上进行枚举：

.. code:: csharp

    // MethodInfo is in the System.Reflection namespace

    var sorted = new SortedList <string, MethodInfo>();
    foreach (MethodInfo m in typeof (object).GetMethods())
      sorted [m.Name] = m;
    foreach (string name in sorted.Keys)
      Console.WriteLine (name);
    foreach (MethodInfo m in sorted.Values)
      Console.WriteLine (m.Name + " returns a " + m.ReturnType);

下面是第一次枚举的结果：

.. code:: csharp

    Equals
    GetHashCode
    GetType
    ReferenceEquals
    ToString

下面是第二次枚举的结果：

.. code:: csharp

    Equals returns a System.Boolean
    GetHashCode returns a System.Int32
    GetType returns a System.Type
    ReferenceEquals returns a System.Boolean
    ToString returns a System.String

注意，我们通过索引器来填充字典。如果我们使用Add方法插入，则会抛出异常，因为我们反射的类重载了Equals方法，而我们不能向字典中添加两次相同的键。通过使用索引器，后面的元素会覆盖前面的元素，从而可以避免这种错误。

扩展我们的示例，下面的代码读取键为GetHashCode的MethodInfo，就如同普通的字典：

Console.WriteLine (sorted ["GetHashCode"]); // Int32 GetHashCode()

到目前为止，我们所做的一切都样适用于SortedDictionary<,>。然后下面的两行代码，读取最后的键与值，则只适用于有序列表：

.. code:: csharp

    Console.WriteLine (sorted.Keys  [sorted.Count - 1]);            // ToString
    Console.WriteLine (sorted.Values[sorted.Count - 1].IsVirtual);  // True

自定义集合与代理
----------------

前面几节中所讨论的集合类非常方便，因为他们可以被直接实例化，但是这些类不允许我们来控制当一个元素被添加或是由集合中移除元素时会发生什么。对于程序中的强类型集合，有时我们需要这种控制，例如：

-  当元素被添加或是删除时触发事件
-  由于添加或是删除了元素而进行属性更新
-  检测一个合法的添加或删除操作并抛出异常

.NET框架在System.Collections.ObjectModel名字空间为这种目的提供了相应的集合类。这些类本质上是代码或是实现了IList或是IDictionary<,>的包装器，通过将方法导向到底层的集合来实现。每个Add，Remove或是Clear操作是通过在重写时扮演网关角色的虚方法来实现的。

可以自定义的集合类通常用于公开的集合中；例如在System.Windows.Form类上公开的控件集合。

Collection与CollectionBase
~~~~~~~~~~~~~~~~~~~~~~~~~~

Collection类是List的可自定义的包装器。

除了实现IList与IList，他定义了如下的四个虚方法以及受保护的属性：

.. code:: csharp

    public class Collection<T> :
      IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
    {
       // ...
       protected virtual void ClearItems();
       protected virtual void InsertItem (int index, T item);
       protected virtual void RemoveItem (int index);
       protected virtual void SetItem (int index, T item);
       protected IList<T> Items { get; }
    }

虚方法提供了网关，通过这个网关我们可以进行关联来改变或是加强列表的通常行为。受保护的Items属性允许实现者直接访问内层列表－这用来在内部进行变化而不需要触发虚方法。

虚方法不需要被重写；他们可以保持不变，直到需要修改列表的默认行为。下面是一个演示Collection通常使用的示例：

.. code:: csharp

    public class Animal
    {
      public string Name;
      public int Popularity;
      public Animal (string name, int popularity)
      {
        Name = name; Popularity = popularity;
      }
    }
    public class AnimalCollection : Collection <Animal>
    {
      // AnimalCollection is already a fully functioning list of animals.
      // No extra code is required.
    }
    public class Zoo   // The class that will expose AnimalCollection.
    {                  // This would typically have additional members.
      public readonly AnimalCollection Animals = new AnimalCollection();
    }
    class Program
    {
      static void Main()
      {
        Zoo zoo = new Zoo();
        zoo.Animals.Add (new Animal ("Kangaroo", 10));
        zoo.Animals.Add (new Animal ("Mr Sea Lion", 20));
        foreach (Animal a in zoo.Animals) Console.WriteLine (a.Name);
      }
    }

正如其所表示的，AnimalCollection仅是一个简单的List而没有更多的功能；他的角色就是为未来的扩展提供一个基础。为了演示，我们将会向Animal添加一个Zoo属性，从而可以引用Zoo并重写Collection中的虚方法来自动维护属性：

.. code:: csharp

    public class Animal
    {
      public string Name;
      public int Popularity;
      public Zoo Zoo { get; internal set; }
      public Animal(string name, int popularity)
      {
        Name = name; Popularity = popularity;
      }
    }
    public class AnimalCollection : Collection <Animal>
    {
      Zoo zoo;
      public AnimalCollection (Zoo zoo) { this.zoo = zoo; }
     
      protected override void InsertItem (int index, Animal item)
      {
        base.InsertItem (index, item);
        item.Zoo = zoo;
      }
      protected override void SetItem (int index, Animal item)
      {
        base.SetItem (index, item);
        item.Zoo = zoo;
      }
      protected override void RemoveItem (int index)
      {
        this [index].Zoo = null;
        base.RemoveItem (index);
      }
      protected override void ClearItems()
      {
        foreach (Animal a in this) a.Zoo = null;
        base.ClearItems();
      }
    }
    public class Zoo
    {
      public readonly AnimalCollection Animals;
      public Zoo() { Animals = new AnimalCollection (this); }
    }

Collection同时还有一个接受已存在的IList的构造器。与其他的集合类不同，所提供的列表被代理而不是被拷贝，意味着后续的变化会反映在包装的Collection中（尽管没有触发Collection的虚方法）。相应的，通过Collection所做的变化将会修改底层列表。

**CollectionBase**

CollectionBase是Collection的非泛型版本，在框架1.0中引入。他提供了与Collection相同的大多数特性，但是难于使用。CollectionBase并没有模板方法InsertItem，RemoveItem，SetItem与ClearItem，但是具有下列方法：OnInsert，OnInsertComplete，OnSet，OnSetComplete，OnRemove，OnRemoveComplete，OnClear，OnClearComplete。因为CollectionBase是非泛型的，当继承时我们必须实现类型方法，至少实现类型索引器与Add方法。

KeyedCollection与DictionaryBase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KeyedCollection继承自Collection。他同时添加并减少了功能。所添加的是通过键访问元素的能力，非常类似于字典。所减少的是代码我们自己的内部列表的能力。

Chapter 8. LINQ Queries
=======================

LINQ，或者语言结合查询，是用于在本地对象集合或是远程数据源上结构化类型安全查询的语言与框架特性集合。LINQ是在C#
3.0与框架3.5中引入的。

LINQ使得我们可以查询任意实现了IEnumerable的集合，无论数组，列表或是XML
DOM，以及远程数据源，例如SQL服务中的表。LINQ同时提供了编译时类型检测与动态查询组合的优点。

本章描述了LINQ体系结构以及编写查询的基础。所有的核心类型定义在System.Linq与System.Linq.Expressions名字空间中。

开始
----

LINQ中数据的基本单元是序列（sequence）与元素(element）。一个序列是实现了IEnumerable的任意对象，而元素是序列中的每一项。在下面的示例中，names是序列，而Tom，Dick与Harry是元素：

string[] names = { "Tom", "Dick", "Harry" };

我们将其称之为本地序列，因为他表示位于内存中的一个本地对象集合。

查询操作符是转换序列的一个方法。一个通常的查询操作符接受一个输入序列并输出一个转换的输出序列。在System.Linq中的Enumerable类中，有大约40个查询操作符－所有的都被实现为静态扩展方法。这些被称为标准查询操作符。

查询是使用查询操作符转换序列的表达式。最简单的查询由一个输入序列也一个操作符组成。例如，我们可以在一个简单的数组上应用Where操作符来获取长度至少为4个字符的字符串，如下所示：

.. code:: csharp

    string[] names = { "Tom", "Dick", "Harry" };
    IEnumerable<string> filteredNames = System.Linq.Enumerable.Where
                                        (names, n => n.Length >= 4);
    foreach (string n in filteredNames)
      Console.WriteLine (n);
    Dick
    Harry

因为标准查询操作符被实现为扩展方法，我们可以直接在names上调用Where，尽管他是一个实例方法：

IEnumerable filteredNames = names.Where (n => n.Length >= 4);

为了使其通过编译，我们必须引入System.Linq名字空间。下面是完整的示例：

.. code:: csharp

    using System;
    usign System.Collections.Generic;
    using System.Linq;
    class LinqDemo
    {
      static void Main()
      {
        string[] names = { "Tom", "Dick", "Harry" };
        IEnumerable<string> filteredNames = names.Where (n => n.Length >= 4);
        foreach (string name in filteredNames) Console.WriteLine (name);
      }
    }
    Dick
    Harry

大多数的查询操作符接受一个Lambda表达式作为参数。在我们的示例中，Lambda表达式如下：

.. code:: csharp

    n => n.Length >= 4

输入参数与一个输入元素相对应的。在这种情况下，输入参数n表示数组中的每一个name，并且为string类型。Where操作符要求Lambda表达式返回bool值，如果为true，表示元素应包含在输出序列中。下面是其签名：

.. code:: csharp

    public static IEnumerable<TSource> Where<TSource>
      (this IEnumerable<TSource> source, Func<TSource,bool> predicate)

下面的查询获取所有包含字母a的name：

.. code:: csharp

    IEnumerable<string> filteredNames = names.Where (n => n.Contains ("a"));
    foreach (string name in filteredNames)
      Console.WriteLine (name);             // Harry

至目前为止我们使用扩展方法以及Lambda表达式构建查询。正如我们将会看到的，这种策略是高度可组合的，因为他允许查询操作符链。在本书中，我们将其称之为fluent语法。C#同时提供了编写查询的另一种语法，称之为查询表达式语法。下面使用查询表达式重新实现我们前面的例子：

.. code:: csharp

    IEnumerable<string> filteredNames = from n in names
                                        where n.Contains ("a")
                                        select n;

fluent语法与查询语法是互补的。在下面的两节中，我们会详细探讨每一种方法。

Fluent语法
----------

Fluent语法是最灵活与基础的。在本节中，我们描述如何链接查询操作符来执行更为复杂的查询－并且显示为什么扩展方法对于这一过程如此重要。同时我们还会描述如何格式化用于查询的Lambda表达式并且介绍一些新的查询操作符。

链接查询操作符
~~~~~~~~~~~~~~

在前面的章节中，我们显示了两个简单查询，每一个由单一的查询操作符组成。为了构建更为复杂的查询，我们向表达式添加额外的查询操作符，从而构成一个链。为了演示，下面的查询获取所有包含字符a的字符，按其长度排序，然后将结果转换为大写：

.. code:: csharp

    using System;
    using System.Collections.Generic;
    using System.Linq;
    class LinqDemo
    {
      static void Main()
      {
        string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
        IEnumerable<string> query = names
          .Where   (n => n.Contains ("a"))
          .OrderBy (n => n.Length)
          .Select  (n => n.ToUpper());
        foreach (string name in query) Console.WriteLine (name);
      }
    }
    JAY
    MARY
    HARRY

Where，OrderBy与Select是Enumerable类中解析扩展方法的标准查询操作符。

我们已经介绍了Where操作符，他会输出一个输入序列的过滤版本。OrderBy操作符输出输入序列的一个排序版本；Select方法输出一个序列，其中每一个输入元素被转换或是使用指定的Lambda表达式进行计算（在本例中是n.ToUpper()）。操作符链中的数据流是由左向右流动，所以数据首先被过滤，然后排序，然后计算。

下面是这些扩展方法的签名：

.. code:: csharp

    public static IEnumerable<TSource> Where<TSource>
      (this IEnumerable<TSource> source, Func<TSource,bool> predicate)
    public static IEnumerable<TSource> OrderBy<TSource,TKey>
      (this IEnumerable<TSource> source, Func<TSource,TKey> keySelector)
    public static IEnumerable<TResult> Select<TSource,TResult>
      (this IEnumerable<TSource> source, Func<TSource,TResult> selector)

当查询操作符像本例这样链接在一起时，一个操作符的输出序列是另一个操作符的输入序列。最终的结果形成了一个生产线，如图8-1所示：

.. figure:: csharp_8_1.png
   :alt: csharp_8_1.png

   csharp\_8\_1.png
我们可以分步构建相同的查询，如下所示：

.. code:: csharp

    // You must import the System.Linq namespace for this to compile:
    IEnumerable<string> filtered   = names   .Where   (n => n.Contains ("a"));
    IEnumerable<string> sorted     = filtered.OrderBy (n => n.Length);
    IEnumerable<string> finalQuery = sorted  .Select  (n => n.ToUpper());

finalQuery与我们前面所构建的query完全相同。而且，每一个中间步骤由一个我们可以执行的正确查询组成：

.. code:: csharp

    foreach (string name in filtered)
      Console.Write (name + "|");        // Harry|Mary|Jay|
    Console.WriteLine();
    foreach (string name in sorted)
      Console.Write (name + "|");        // Jay|Mary|Harry|
    Console.WriteLine();
    foreach (string name in finalQuery)
      Console.Write (name + "|");        // JAY|MARY|HARRY|

**为什么扩展方法重要**

除了使用扩展语法方法以外，我们可以使用传统的静态方法语法来调用查询操作符。例如：

.. code:: csharp

    IEnumerable<string> filtered = Enumerable.Where (names,
                                                     n => n.Contains ("a"));
    IEnumerable<string> sorted = Enumerable.OrderBy (filtered, n => n.Length);
    IEnumerable<string> finalQuery = Enumerable.Select (sorted,
                                                        n => n.ToUpper());

实际上这是编译器转换扩展方法调用的方式。然而如果我们希望像前面那样使用一条语句编写查询时，避免扩展方法会带来性能开销。让我们重新审视单语句查询－首先使用扩展方法语法：

.. code:: csharp

    IEnumerable<string> query = names.Where   (n => n.Contains ("a"))
                                     .OrderBy (n => n.Length)
                                     .Select  (n => n.ToUpper());

其自然线性形式反应了由左到右的数据流，并且将Lambda表达式与其查询操作符关联在一起。如果不使用扩展方法，查询就会丢失其灵活性：

.. code:: csharp

    IEnumerable<string> query =
      Enumerable.Select (
        Enumerable.OrderBy (
          Enumerable.Where (
            names, n => n.Contains ("a")
          ), n => n.Length
        ), n => n.ToUpper()
      );

组合Lambda表达式
~~~~~~~~~~~~~~~~

在前面的示例中，我们向Where操作提供了下列的Lambda表达式：

n => n.Contains ("a") // Input type=string, return type=bool.

Lambda表达式的目的依赖于特定的查询操作符。对于Where操作符，他表明了一个元素是否应被包含在输出序列中。在OrderBy操作符的例子中，Lambda表达式将输入序列中的每一个元素映射到其有序键。对于Select操作符，Lambda表达确定了在提供给输出序列之前输入序列的每一个元素应进行怎样的转换。

查询操作符依据我们的需要计算Lambda表达式－通常是为输入序列中的每一个元素计算一次。Lambda表达式允许我们向查询操作符提供我们自己的逻辑。这使得查询操作符十分灵活－同时又保持了简单。下面是Enumerable.Where的完整实现：

.. code:: csharp

    public static IEnumerable<TSource> Where<TSource>
      (this IEnumerable<TSource> source, Func<TSource,bool> predicate)
    {
      foreach (TSource element in source)
        if (predicate (element))
          yield return element;
    }

**Lambda表达式与Func签名**

标签查询操作符利用泛型Func委托。Func是定义在System.Linq中的通用目的泛型委托族，定义了下列意图：

Func中的类型参数所出现的顺序与他们在Lambda表达式中出现的顺序相同。

所以，Func匹配TSource=>bool
Lambda表达式：接受TSource参数并且返回bool值。

类似的，Func匹配TSource=>TResult Lambda表达式。

**Lambda表达式与元素类型**

标准查询操作符使用下列的泛型类型名字：

+--------------+-------------------------------------------+
| 泛型类型名   | 含义                                      |
+--------------+-------------------------------------------+
| TSource      | 输入序列的元素类型                        |
+--------------+-------------------------------------------+
| TResult      | 输出序列的元素类型－如果不同于TSource     |
+--------------+-------------------------------------------+
| TKey         | 排序，组合或是联合中所用的key的元素类型   |
+--------------+-------------------------------------------+

TSource由输入序列确定。TResult与TKey由我们的Lambda表达式推测得出。

例如，考虑Select查询操作符的签名：

.. code:: csharp

    public static IEnumerable<TResult> Select<TSource,TResult>
      (this IEnumerable<TSource> source, Func<TSource,TResult> selector)

Func匹配TSource=>TResult
Lambda表达式：将输入元素映射到输出元素。TSource与TResult是不同的类型，所以Lambda表达式可以修改每一个元素的类型。而且，Lambda表达式确定了输入序列类型。下面的查询使用Select将字符串类型元素转换为整数类型元素：

.. code:: csharp

    string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
    IEnumerable<int> query = names.Select (n => n.Length);
    foreach (int length in query)
      Console.Write (length + "|");    // 3|4|5|4|3|

编译器由Lambda表达式的返回值推测TResult的类型。在这种情况下，TResult被推测为int类型。

Where查询操作符更为简单，并且不需要为输出推测类型，因为输入与输出元素是相同的类型。这是有道理的，因为操作仅过滤元素而不进行转换：

.. code:: csharp

    public static IEnumerable<TSource> Where<TSource>
      (this IEnumerable<TSource> source, Func<TSource,bool> predicate)

最后，考虑OrderBy操作符的签名：

.. code:: csharp

    // Slightly simplified:
    public static IEnumerable<TSource> OrderBy<TSource,TKey>
      (this IEnumerable<TSource> source, Func<TSource,TKey> keySelector)

Func将输入元素映射到有序键。TKey由我们的Lambda表达式推测得出并且独立于输入与输出元素类型。例如，我们可以选择通过长度（int键）或是字符（string键）来排序名字列表：

.. code:: csharp

    string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
    IEnumerable<string> sortedByLength, sortedAlphabetically;
    sortedByLength       = names.OrderBy (n => n.Length);   // int key
    sortedAlphabetically = names.OrderBy (n => n);          // string key

自然顺序
~~~~~~~~

在LINQ中，输入序列的原始顺序是十分重要的。一些查询操作符依据这种行为，例如Take，Skip与Reverse。

Take操作符输出前x个元素，舍弃其他的元素：

.. code:: csharp

    int[] numbers  = { 10, 9, 8, 7, 6 };
    IEnumerable<int> firstThree = numbers.Take (3);     // { 10, 9, 8 }

Skip操作符忽略前x个元素并输出其余的元素：

IEnumerable lastTwo = numbers.Skip (3); // { 7, 6 }

Reverse执行其所表述的操作：

IEnumerable reversed = numbers.Reverse(); // { 6, 7, 8, 9, 10 }

如Where与Select这样的操作符会保留输入序列的原始顺序。LINQ会在可能时保留输入序列中元素的顺序。

其他操作符
~~~~~~~~~~

并不是所有的查询操作符都返回一个序列。元素操作符由输入序列中获取一个元素；例如First，Last与ElementAt：

.. code:: csharp

    int[] numbers    = { 10, 9, 8, 7, 6 };
    int firstNumber  = numbers.First();                     // 10
    int lastNumber   = numbers.Last();                      // 6
    int secondNumber = numbers.ElementAt(1);                // 9
    int lowestNumber = numbers.OrderBy (n => n).First();    // 6

聚合操作符（aggregation）返回一个标题值；通常是数值类型：

.. code:: csharp

    int count = numbers.Count();          // 5;
    int min = numbers.Min();              // 6;

quantifiers返回一个bool值：

.. code:: csharp

    bool hasTheNumberNine = numbers.Contains (9);          // true
    bool hasMoreThanZeroElements = numbers.Any();          // true
    bool hasAnOddElement = numbers.Any (n => n % 2 == 1);  // true

因为这些操作符并不返回集合，我们并不能在这些结果上调用其他的查询操作符。换句话说，他们必须作为查询中的最后一个操作符出现。

有些查询操作符接受两个输入序列。例如Concat，他会将一个序列添加到另一个序列，以及Union，他会执行相同的操作，但是删除重复的元素：

.. code:: csharp

    int[] seq1 = { 1, 2, 3 };
    int[] seq2 = { 3, 4, 5 };
    IEnumerable<int> concat = seq1.Concat (seq2);    //  { 1, 2, 3, 3, 4, 5 }
    IEnumerable<int> union  = seq1.Union (seq2);     //  { 1, 2, 3, 4, 5 }

查询表达式
----------

C#提供了一个用于编写LINQ查询的语法糖，称之为查询表达式。与通常的思想相对应的，查询表达式并不是基于SQL，而是基于函数式程序语言，例如LISP与Haskell中的列表概念。

在前面的内容中，我们编写了一个fluent语法查询来获取包含字符a的字符串，按其长度排序并且转换为大写。下面是使用查询语法的相同操作：

.. code:: csharp

    using System;
    using System.Collections.Generic;
    using System.Linq;
    class LinqDemo
    {
      static void Main()
      {
        string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
        IEnumerable<string> query =
          from    n in names
          where   n.Contains ("a")     // Filter elements
          orderby n.Length             // Sort elements
          select  n.ToUpper();         // Translate each element (project)
        foreach (string name in query) Console.WriteLine (name);
      }
    }
    JAY
    MARY
    HARRY

查询表达式总是由from子句开始，并以select或是group子句结束。from子句声明了一个范围变量（range
variable）（在本例中为n），我们可以将其看作在输入序列中遍历－类似于foreach。图8-2显示了复杂的语法路线图。

.. figure:: chsarp_8_2.png
   :alt: chsarp_8_2.png

   chsarp\_8\_2.png
编译器通过将其转换为fluent语法来处理查询表达式。他以一种非常机械的方式来实现－类似于将foreach语句转换调用GetEnumerator与MoveNext。这就意味着我们使用查询语法编写的任何内容同样也可以使用fluent语法来编写。编译器（初始时）将我们的示例查询转换下面代码：

.. code:: csharp

    IEnumerable<string> query = names.Where   (n => n.Contains ("a"))
                                     .OrderBy (n => n.Length)
                                     .Select  (n => n.ToUpper());

Where，OrderBy与Select操作符会使用以fluent语法编写查询时所适用的相同规则。在这种情况下，他们绑定到Enumerable类中的扩展方法，因为System.Linq名字空间已经被引入并且names实现了IEnumerable。然而，当转换查询表达式时，编译器并不是特别喜欢Enumerable类。我们可以想像，编译器机械的将单词Where，OrderBy与Select插入到语句中，然后进行编译，就如同我们自己输入方法名一样。这在他们解析的方式上提供了灵活性。例如，我们在稍后内容编写的数据库查询中的操作符将会绑定到Queryable中的扩展方法。

Range Variables
~~~~~~~~~~~~~~~

紧随在from关键字之后的标识符被称之为范围变量。范围变量指向当前序列中在其上执行操作的当前元素。

在我们的示例中，范围变量n出现在查询中的每一个子句中。而且，对于每一个子句，变量实际上在不同的序列上遍历：

.. code:: csharp

    from    n in names           // n is our range variable
    where   n.Contains ("a")     // n = directly from the array
    orderby n.Length             // n = subsequent to being filtered
    select  n.ToUpper()          // n = subsequent to being sorted

当我们检测编译到fluent语法的机械式转换时就会变得更为清楚：

.. code:: csharp

    names.Where   (n => n.Contains ("a"))      // Privately scoped n
         .OrderBy (n => n.Length)              // Privately scoped n
         .Select  (n => n.ToUpper())           // Privately scoped n

正如我们所看到的，每一个n的实例的作用范围被局限在其自己的Lambda表达式之内。

查询表达式允许我们通过下列子句引入新的范围变量：

-  let
-  into
-  额外的from子句

查询语法与SQL语法
~~~~~~~~~~~~~~~~~

查询语法看上去很像SQL，然而两者是不同的。LINQ查询向下转换为C#表达式，因而遵循标准的C#规则。例如，对于LINQ，我们不能在变量声明之前使用变量。在SQL，我们可以在FROM子句中定义表别名之前在SELECT子句中使用表的别名。

LINQ中的子查只是另一个C#表达式，从而不需要特殊的语法。SQL中的子查询需要特殊的规则。

对于LINQ，在查询中，数据在逻辑上由左向右流动。对于SQL，
考虑到数据流，顺序缺少良好的结构。

LINQ查询由接受与输出有序序列的传送带或是管道组成。SQL查询由几乎适用于无序集合的网络子句组成。

查询语法与Fluent语法
~~~~~~~~~~~~~~~~~~~~

查询语法与Fluent语法各有优点。

当查询涉及到下列情况下，查询语法更为简单：

-  用于在范围变量旁边引入新变量的let语句
-  为一个变层范围变量引用跟随的SelectMany，Join或是GroupJoin

中间层是涉及到Where，OrderBy与Select简单使用的查询。每一个语法都可以工作得很好；选择很大程度上是各人的喜好。

对于由单个操作符所构成的查询，Fluent语法更为简短。

最后，有许多在查询语法中没有关键字的操作符。这些要求我们使用Fluent语法－至少部分上如此。这意味着在下列操作符之外：

.. code:: csharp

    Where, Select, SelectMany
    OrderBy, ThenBy, OrderByDescending, ThenByDescending
    GroupBy, Join, GroupJoin

混合语法查询
~~~~~~~~~~~~

如果一个查询操作符没有查询语法的支持，我们可以混合查询语法与Fluent语法。唯一的限制就是每一个查询语法组件必须是完整的。

假定下面的数据声明：

string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };

下面的代示例会计算包含字符“a”的名字的个数：

.. code:: csharp

    int matches = (from n in names where n.Contains ("a") select n).Count();
    // 3

下面的查询会获取以字母顺序中的第一个名字：

string first = (from n in names orderby n select n).First(); // Dick

混合语法方法在某些情况下更适合于复杂的查询。然而，对于这个简单的示例，我们也可以使用Fluent语法：

.. code:: csharp

    int matches = names.Where (n => n.Contains ("a")).Count();   // 3
    string first = names.OrderBy (n => n).First();               // Dick

本章的其余部分将会显示Fluent语法与查询语法中的关键概念。

延迟执行
--------

大多数查询操作符的一个重要特性就是查询并不是在构建时立即执行，而是当枚举时执行（换句话说，当在枚举器上调用MoveNext时执行）。考虑下面的查询：

.. code:: csharp

    var numbers = new List<int>();
    numbers.Add (1);
    IEnumerable<int> query = numbers.Select (n => n * 10);    // Build query
    numbers.Add (2);                    // Sneak in an extra element
    foreach (int n in query)
      Console.Write (n + "|");          // 10|20|

我们在构建查询之后插入到列表中的额外数字也会包含在结果中，因为直到foreach语句运行时，过滤或是排序查询操作才会执行。这被称之为延迟（deffered或lazy）执行。所有的标准查询操作符都提供延迟执行，但是下列例外：

-  返回单个元素或是标题值的操作符，例如First或Count
-  下列的转换操作符：ToArray，ToList，ToDictionary，ToLookup

这些操作符会导致立即的查询执行，因为他们的结果类型并没有提供延迟执行的机制。例如，Count方法返回一个简单的整数，因而不能进行枚举。下面的查询是立即执行的：

.. code:: csharp

    int matches = numbers.Where (n => n < 2).Count();    // 1

延迟执行是很重要的，因为他将查询构建与查询执行相分离。这可以使得我们通过多个步骤构建查询，并且使得数据库查询成为可能。

重新计算
~~~~~~~~

延迟执行还有另一个影响：延迟执行会在重新枚举时重新计算：

.. code:: csharp

    var numbers = new List<int>() { 1, 2 };
    IEnumerable<int> query = numbers.Select (n => n * 10);
    foreach (int n in query) Console.Write (n + "|");   // 10|20|
    numbers.Clear();
    foreach (int n in query) Console.Write (n + "|");   // <nothing>

下列一些原因解释了为什么有时重新计算是有缺点的：

-  有时我们希望在某一个时间点上“冻住”或是缓存结果
-  有时查询的计算开稍很大（或是查询远程数据库），所以我们不希望进行没有必要的重复

我们可以通过调用转换操作符，例如ToArray或是ToList来禁止重新计算。ToArray将查询的结果拷贝到一个数组；ToList拷贝到一个泛型List<>中：

.. code:: csharp

    var numbers = new List<int>() { 1, 2 };
    List<int> timesTen = numbers
      .Select (n => n * 10)
      .ToList();                // Executes immediately into a List<int>
    numbers.Clear();
    Console.WriteLine (timesTen.Count);      // Still 2

捕获变量
~~~~~~~~

延迟执行还有另一个副作用。如果我们查询的Lambda表达式引用局部变量，这些变量就具有捕获变量的语义。这就意味着如果我们稍后修改变量的值，查询也会发生变化：

.. code:: csharp

    int[] numbers = { 1, 2 };
    int factor = 10;
    IEnumerable<int> query = numbers.Select (n => n * factor);
    factor = 20;
    foreach (int n in query) Console.Write (n + "|");   // 20|40|

当在一个foreach循环中构建查询时，这会是一个陷井。例如，假定我们要由字符串移除所有的元音。下面的代码尽管效率很低，但是会给出正确的结果：

.. code:: csharp

    query = query.Where (c => c != 'a');
    query = query.Where (c => c != 'e');
    query = query.Where (c => c != 'i');
    query = query.Where (c => c != 'o');
    query = query.Where (c => c != 'u');
    foreach (char c in query) Console.Write (c);  // Nt wht y mght xpct

现在观察一下当我们使用foreach循环重构时会发生什么：

.. code:: csharp

    IEnumerable<char> query = "Not what you might expect";
    foreach (char vowel in "aeiou")
      query = query.Where (c => c != vowel);
    foreach (char c in query) Console.Write (c);   // Not what yo might expect

只有'u'被去掉了！正如我们在第4章所了解到的，这是因为，编译器会将foreach循环中的迭代变量的作用域看作如同在循环之外声明的一样：

.. code:: csharp

    IEnumerable<char> vowels = "aeiou";
    using (IEnumerator<char> rator = vowels.GetEnumerator())
    {
      char vowel;
      while (rator.MoveNext())
      {
        vowel = rator.Current;
        query = query.Where (c => c != vowel);
      }
    }

因为vowel是在循环之外声明的，相同的变量会被重复更新，所以每一个Lambda表达式会捕获相同的vowel。当我们稍后枚举查询时，所有的Lambda表达式会引用变量的当前值，也就是u。为了解决这一问题，我们必须将循环变量赋值给在语句块中声明的另一个变量：

.. code:: csharp

    foreach (char vowel in "aeiou")
    {
     char temp = vowel;
     query = query.Where (c => c != temp);
    }

这会强制在每次循环迭代时使用新变量。

延迟执行如何工作
~~~~~~~~~~~~~~~~

查询操作符是通过返回装饰器序列来提供延迟执行的。

与传统的集合类例如数据或是链表不同，装饰器序列并没有其自己的后端结构来存储元素。相反，他封装我们在运行时所提供的另一个序列，从而维护一个持久的依赖。当我们由装饰器请求数据时，他必须依次向所封装的输入序列请求数据。

调用Where仅是构建了一个装饰器包装器序列，存储到输入序列的引用，Lambda表达式，以及所提供的其他参数。只有当装饰器被枚举时输入序列才会被枚举。

图8-3显示了下列查询的组成：

IEnumerable lessThanTen = new int[] { 5, 12, 3 }.Where (n => n < 10);

.. figure:: csharp_8_3.png
   :alt: csharp_8_3.png

   csharp\_8\_3.png
当我们枚举lessThanTen时，事实上我们是通过Where装饰器来查询数组。

好消息就是，如果我们希望编写我们自己的查询操作符，使用C#迭代器实现一个装饰器序列是很容易的。下面是显示我们如何编写我们自己的Select方法：

.. code:: csharp

    public static IEnumerable<TResult> Select<TSource,TResult>
      (this IEnumerable<TSource> source, Func<TSource,TResult> selector)
    {
      foreach (TSource element in source)
        yield return selector (element);
    }

这个方法是利用yield
return语句的一个迭代器。在功能上，他是下列代码的简写：

.. code:: csharp

    public static IEnumerable<TResult> Select<TSource,TResult>
      (this IEnumerable<TSource> source, Func<TSource,TResult> selector)
    {
      return new SelectSequence (source, selector);
    }

其中SelectSequence是一个类，其枚举器在迭代方法中封装了逻辑。

所以，当我们调用操作符，例如Select或是Where时，我们所做的仅是实例化装饰输入序列的可枚举类。

链接装饰器
~~~~~~~~~~

链接装饰器会创建一个装饰器层。考虑下面的查询：

.. code:: csharp

    IEnumerable<int> query = new int[] { 5, 12, 3 }.Where   (n => n < 10)
                                                   .OrderBy (n => n)
                                                   .Select  (n => n * 10);

每一个查询操作符实例化一个封装前一个序列的新装饰器。这个查询的对象模型显示在图8-4中。注意，这个对象模型是在枚举之前构建的。

.. figure:: csharp_8_4.png
   :alt: csharp_8_4.png

   csharp\_8\_4.png
当我们枚举query时，我们是在查询原始的数组，通过一个装饰器层或是装饰器链进行转换。

图8-5显示以UML语法表示的相同的对象组合。Select装饰器引用OrderBy装饰器，而后者又引用Where装饰器，而后者引用数组。延迟执行的一个特性就是如果我们分步组合查询，我们就可以构建相同的对象模型：

.. code:: csharp

    IEnumerable<int>
      source    = new int[] { 5, 12, 3 },
      filtered  = source   .Where   (n => n < 10),
      sorted    = filtered .OrderBy (n => n),
      query     = sorted   .Select  (n => n * 10);

查询如何执行
~~~~~~~~~~~~

下面是枚举前面查询的结果：

.. code:: csharp

    foreach (int n in query) Console.WriteLine (n);
    30
    50

在幕后，foreach在Select装饰器上调用GetEnumerator。结果是一个结构化映射装饰器序列链的枚举器链。图8-6显示枚举处理时的执行流程。

.. figure:: csharp_8_6.png
   :alt: csharp_8_6.png

   csharp\_8\_6.png
在本章的第一节中，我们将查询比作一条生产线。扩展这个比喻，我们可以说LINQ查询是一个延迟的生产线，其中传送带会按需传送元素。构建查询就是构建一个生产线，所有的元素各在其位，但是没有元素传送。然后当消费者请求元素时，最右边的传送带被激活；并依次触发其他的传送带。LINQ遵循需求驱动的pull模式，而不是提供驱动的push模式。这一点是很重要的。

子查询
------

子查询是包含在另一个查询Lambda表达式中的查询。下面的示例使用子查询按音乐家的最后一个名字进行排序：

.. code:: csharp

    string[] musos = { "David Gilmour", "Roger Waters", "Rick Wright" };
    IEnumerable<string> query = musos.OrderBy (m => m.Split().Last());

m.Split将每一个字符串转换为单词集合，然后在其基础上我们调用Last查询操作符。m.Split().Last是子查询；query指向外层查询。

之所以可以进行子查询是因为我们可以在Lambda表达式的右侧放置任意的正确的C#表达式。子查询只是一个简单的另一个C#表达式。这就意味着子查询的规则同时遵循Lambda表达式的规则。

子查询的作用范围被限制在所包含的表达式之中，并且可以引用外层的Lambda参数（或者是查询表达式中的范围变量）。

m.Split().Last是一个非常简单的子查询。下面的查询获取数组中字符串长度与最短字符串匹配的所有字符串：

.. code:: csharp

    string[] names = { "Tom", "Dick", "Harry", "Mary", "Jay" };
    IEnumerable<string> outerQuery = names
      .Where (n => n.Length == names.OrderBy (n2 => n2.Length)
                                    .Select  (n2 => n2.Length).First());
    Tom, Jay

下面是可以实现相同效果的查询表达式：

.. code:: csharp

    IEnumerable<string> outerQuery =
      from   n in names
      where  n.Length ==
               (from n2 in names orderby n2.Length select n2.Length).First()
      select n;

因为外层的范围变量（n）在子查询的作用域内可见，我们不能重用n作为子查询的范围变量。

当所包含的Lambda表达式进行计算机时子查询就会被执行。这就意味着子查询是依据外层查询的需要而执行的。我们也可以说是由外向里执行的。本地查询精确的遵循这种模型；解释查询（例如，数据库查询）在概念上遵循这种模型。

子查询执行会在需要的时候向外层查询提反馈。在我们的示例中，子查询为每一个外层循环执行一次。如图8-7与8-8所示。

我们可以以如下的方式来表达前面的子查询：

.. code:: csharp

    IEnumerable<string> query =
      from   n in names
      where  n.Length == names.OrderBy (n2 => n2.Length).First().Length
      select n;

使用Min聚合函数，我们可以进行进一步的简化：

.. code:: csharp

    IEnumerable<string> query =
      from   n in names
      where  n.Length == names.Min (n2 => n2.Length)
      select n;

.. figure:: csharp_8_7.png
   :alt: csharp_8_7.png

   csharp\_8\_7.png
.. figure:: csharp_8_8.png
   :alt: csharp_8_8.png

   csharp\_8\_8.png
在后面的部分中，我们将会描述如SQL表这样的源如何进行行查询。我们的示例将会执行一个完美的数据库查询，因为他将作为一个单元处理，只需要一次到数据库往复过程。然而，这个查询对于本地集合效率不高，因为子查询会为每一次处层循环迭代进行计算。我们可以通过单独运行子查询来避免这种低效：

.. code:: csharp

    int shortest = names.Min (n => n.Length);
    IEnumerable<string> query = from   n in names
                                where  n.Length == shortest
                                select n;

**子查询与延迟查询**

子查询中的元素或是聚合操作符，例如First或是Count，不会强制外层查询立即执行－延迟查询对于外层查询仍然适用。这是因为子查询是间接调用的－在本地查询时通过委托，或者在解释查询中通过表达式树。

当我们在Select表达式中包含子查询时会出现一个有趣的情况。在本地查询的情况下，我们实际上是在组合一个查询序列－每一个查询本身都会延迟查询。效果通常是透明的，而其进一步改善了效率。

组合策略
--------

在本节中，我们将会描述用于构建更为复杂查询的三种策略：

-  渐近查询构建（Progressive query construction）
-  使用into关键字（Using the into keyword）
-  封装查询（Wrapping queries）

三者都是链式策略并生成相同的运行查询。

渐近查询构建
~~~~~~~~~~~~

作为本章的开始，我们演示了如何渐近式的构建一个Fluent查询：

.. code:: csharp

    var filtered   = names    .Where   (n => n.Contains ("a"));
    var sorted     = filtered .OrderBy (n => n);
    var query      = sorted   .Select  (n => n.ToUpper());

由于每一个涉及其中的查询操作符都返回一个装饰器序列，所得到的结果查询与我们由单表达式查询中所获得的链或是装饰器层相同。然而，渐近式构建查询有如下的一些优点：

-  查询很容易编写
-  我们可以有条件的添加查询操作符

例如：

if (includeFilter) query = query.Where (...)

这要比下面的写法更高效：

query = query.Where (n => !includeFilter \|\| )

因为他避免了如果includeFilter为假时添加额外的查询操作符的可能。

渐近式方法在查询理解方法也很有用。为了进行演示，假定我们要移除名字列表中的所有元音，并且对仍多于两个字符长度的名字以字母顺序显示。在Fluent语法中，在过滤之前通过组合我们可以使用单表达式编写如下的查询：

.. code:: csharp

    IEnumerable<string> query = names
      .Select  (n => n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                      .Replace ("o", "").Replace ("u", ""))
      .Where   (n => n.Length > 2)
      .OrderBy (n => n);
    RESULT: { "Dck", "Hrry", "Mry" }

将上面的查询直接翻译为查询表达式比较麻烦，因为select子句必须位于where与orderby子句之后。如果我们重新安排查询将select放在最后，则所得到的结果会不同：

.. code:: csharp

    IEnumerable<string> query =
      from    n in names
      where   n.Length > 2
      orderby n
      select  n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
               .Replace ("o", "").Replace ("u", "");
    RESULT: { "Dck", "Hrry", "Jy", "Mry", "Tm" }

幸运的是，以查询语法的形式有多种方法可以获得原始的结果。第一种是通过渐近式查询：

.. code:: csharp

    IEnumerable<string> query =
      from   n in names
      select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
              .Replace ("o", "").Replace ("u", "");
    query = from n in query where n.Length > 2 orderby n select n;
    RESULT: { "Dck", "Hrry", "Mry" }

into关键字
~~~~~~~~~~

into关键字可以使得我们在构建之后继续查询，他是渐近式查询的一种简写。使用inot，我们可以重写前面的查询如下：

.. code:: csharp

    IEnumerable<string> query =
      from   n in names
      select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
              .Replace ("o", "").Replace ("u", "")
      into noVowel
        where noVowel.Length > 2 orderby noVowel select noVowel;

我们可以使用into的唯一位置就是select或是group子句之后。into会重启查询，从而使得我们引入新的where，orderby与select子句。

Fluent语法中与into等同的是一个更长的操作符链。

**作用域规则**

into关键字之后的所有查询变量都超出了其作用范围。下面的查询不会通过编译：

.. code:: csharp

    var query =
      from n1 in names
      select n1.ToUpper()
      into n2                              // Only n2 is visible from here on.
        where n1.Contains ("x")            // Illegal: n1 is not in scope.
        select n2;

要了解为什么，考虑上面的查询如何映射到Fluent语法：

.. code:: csharp

    var query = names
      .Select (n1 => n1.ToUpper())
      .Where  (n2 => n1.Contains ("x"));     // Error: n1 no longer in scope

在Where过滤器运行时原始名字（n1）已经丢失。Where的输入序列只包含大写名字，从而不能基于n1进行过滤。

封装查询
~~~~~~~~

渐近式构建的查询可以通过在一个查询的周围封装另一个查询来形成一条语句。通常的查询：

.. code:: csharp

    var tempQuery = tempQueryExpr
    var finalQuery = from ... in tempQuery ...

可以格式化为：

var finalQuery = from ... in (tempQueryExpr)

封装在语义上与渐近式查询构建或是使用into关键字的形式相同。所有情况下的最终结果是一个查询操作符的线性链。例如，考虑下面的查询：

.. code:: csharp

    IEnumerable<string> query =
      from   n in names
      select n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
              .Replace ("o", "").Replace ("u", "");
    query = from n in query where n.Length > 2 orderby n select n;

重新格式化为封装形式如下：

.. code:: csharp

    IEnumerable<string> query =
      from n1 in
      (
        from   n2 in names
        select n2.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                 .Replace ("o", "").Replace ("u", "")
      )
      where n1.Length > 2 orderby n1 select n1;

当转换为Fluent语法时，结果是与前面的示例相同的操作符的线性链。

.. code:: csharp

    IEnumerable<string> query = names
      .Select  (n => n.Replace ("a", "").Replace ("e", "").Replace ("i", "")
                      .Replace ("o", "").Replace ("u", ""))
      .Where   (n => n.Length > 2)
      .OrderBy (n => n);

封装的查询会让人感到疑惑，因为他类似于我们前面所编写的子查询。两者都有内层与外层查询的概念。然而，当转换为Fluent语法时，我们就会看到封装只是一个简单的顺序链操作符。最终的结果与子查询没有相似之处，而后者是将内层查询嵌入到另一个查询的Lambda表达式中。

回到前面的相似点：封装的内层查询加在前一个传送带上。相对应的，子查询位于传送带上并且通过传送带的Lambda工作器按需激活。

构建策略
--------

Chapter 9. LINQ Operators
=========================

Chapter 10. LINQ to XML
=======================

Chapter 11. Other XML Technologies
==================================

System.Xml名字空间由下面的名字空间以及核心类组成：

System.Xml.\*

-  XmlReader与XmlWriter：用于读取或是写入XML流的高性能、前向光标
-  XmlDocument:以W3C风格DOM表示的XML文档

System.Xml.XPath：用于XPath的基础结构与API(XPathNavigator)，一种用于查询XML的基于字符串的语言

System.Xml.XmlSchema：用于（W3C）XSD Scheme的基础结构与API

System.Xml.Xsl：用于执行XML的XSLT转换的基础结构与API(XslCompiledTransform)

System.Xml.Serialization：支持向或是由XML类的序列化

System.Xml.XLinq：现代、简化的XmlDocument的LINQ版本

W3C是World Wide Web Consortium的缩写，在其中定义了XML标准。

用于分析或是格式化XML字符串的XmlConvert静态类在第6章中进行了讨论。

XmlReader
---------

XmlReader是一个以底层前向方式读取XML流的高性能类。

考虑下面的XML文件：

.. code:: xml

    <?xml version="1.0" encoding="utf-8" standalone="yes"?>
    <customer id="123" status="archived">
      <firstname>Jim</firstname>
      <lastname>Bo</lastname>
    </customer>

要实例化XmlReader，我们调用静态的XmlReader.Create方法，并向其中传递一个Stream，一个TextReader或是一个URI字符串。例如：

using (XmlReader reader = XmlReader.Create ("customer.xml"))

`` ...``

要创建一个由字符串进行读取的XmlReader：

.. code:: csharp

    XmlReader reader = XmlReader.Create (
      new System.IO.StringReader (myString));

我们也可以传递一个XmlReaderSettings对象来控制分析与验证选项。XmlReaderSettings上的下列三个选项对于略过多余的内容特别有用：

.. code:: csharp

    bool IgnoreComments                  // Skip over comment nodes?
    bool IgnoreProcessingInstructions    // Skip over processing instructions?
    bool IgnoreWhitespace                // Skip over whitespace?

在下面的示例中，我们指示读取器不要读取空白，在通常的应用场景中这通常是令人分心的事情：

.. code:: csharp

    XmlReaderSettings settings = new XmlReaderSettings();
    settings.IgnoreWhitespace = true;
    using (XmlReader reader = XmlReader.Create ("customer.xml", settings))
      ...

XmlReaderSettings中另一个比较有用的属性是ConformanceLevel。Document的默认值指示读取器假定正确的XML文档只有一个根节点。如果我们只是希望读取XML中包含多个节点的其中一部分则会出现问题：

.. code:: xml

    <firstname>Jim</firstname>
    <lastname>Bo</lastname>

要读取这段内容而不抛出异常，我们必须将ConformanceLevel设置为Fragment。

XmlReaderSettings同时有一个名为CloseInput的属性，该属性用来指示当读取器关闭时是否关闭底层流（在XmlWriterSettings上有一个类似的CloseOutput）。CloseInput与CloseOutput的默认值为true。

读取节点
~~~~~~~~

XML流的组成单位是XML节点。读取器以文本顺序（尝试优先）遍历流。读取器的Depth属性返回光标的当前深度。

由XmlReader读取的最基本方法就是调用Read。他会前进到XML流中的下一个节点，非常类似于IEnumerator中的MoveNext。Read方法的第一次调用会将光标指向第一个节点。当Read返回false时，则意味着光标已经经过最后一个节点，此时XmlReader应该被关闭。

在这个示例中，我们读取XML流中的每一个节点，同时输出每一个节点类型：

.. code:: csharp

    XmlReaderSettings settings = new XmlReaderSettings();
    settings.IgnoreWhitespace = true;
    using (XmlReader reader = XmlReader.Create ("customer.xml", settings))
      while (reader.Read())
      {
        Console.Write (new string (' ',reader.Depth*2));  // Write indentation
        Console.WriteLine (reader.NodeType);
      }

输出结果如下：

.. code:: csharp

    XmlDeclaration
    Element
      Element
        Text
      EndElement
      Element
        Text
      EndElement
    EndElement

NodeType是XmlNodeType类型，他是下列成员的一个枚举：

.. code:: csharp

    None    Comment    Document
    XmlDeclaration    Entity    DocumentType
    Element    EndEntity    DocumentFragment
    EndElement    EntityReference    Notation
    Text    ProcessingInstruction    Whitespace
    Attribute    CDATA    SignificantWhitespace

XmlReader上的两个string属性提供了对节点内容的访问：Name与Value。依据节点类型，或者Name，或者Value（或同时）会被填充：

.. code:: csharp

    XmlReaderSettings settings = new XmlReaderSettings();
    settings.IgnoreWhitespace = true;
    settings.ProhibitDtd = false;      // Must set this to read DTDs
    using (XmlReader r = XmlReader.Create ("customer.xml", settings))
      while (r.Read())
      {
        Console.Write (r.NodeType.ToString().PadRight (17, '-'));
        Console.Write ("> ".PadRight (r.Depth * 3));
        switch (r.NodeType)
        {
          case XmlNodeType.Element:
          case XmlNodeType.EndElement:
            Console.WriteLine (r.Name); break;
          case XmlNodeType.Text:
          case XmlNodeType.CDATA:
          case XmlNodeType.Comment:
          case XmlNodeType.XmlDeclaration:
            Console.WriteLine (r.Value); break;
          case XmlNodeType.DocumentType:
            Console.WriteLine (r.Name + " - " + r.Value); break;
          default: break;
        }
      }

为了演示，我们扩展我们的XML文件来包含一个文档类型，实体，CDATA以及注释：

.. code:: xml

    <?xml version="1.0" encoding="utf-8" ?>
    <!DOCTYPE customer [ <!ENTITY tc "Top Customer"> ]>
    <customer id="123" status="archived">
      <firstname>Jim</firstname>
      <lastname>Bo</lastname>
      <quote><![CDATA[C#'s operators include: < > &]]></quote>
      <notes>Jim Bo is a &tc;</notes>
      <!--  That wasn't so bad! -->
    </customer>

实体类似于宏；CDATA类似于C#中的原始字符串（@"..."）。下面是输出结果：

.. code:: xml

    XmlDeclaration---> version="1.0" encoding="utf-8"
    DocumentType-----> customer -  <!ENTITY tc "Top Customer">
    Element----------> customer
    Element---------->  firstname
    Text------------->     Jim
    EndElement------->  firstname
    Element---------->  lastname
    Text------------->     Bo
    EndElement------->  lastname
    Element---------->  quote
    CDATA------------>     C#'s operators include: < > &
    EndElement------->  quote
    Element---------->  notes
    Text------------->     Jim Bo is a Top Customer
    EndElement------->  notes
    Comment---------->    That wasn't so bad!
    EndElement------->  customer

XmlReader会自动解析实体，所以在我们的示例中，实体引用&tc;扩展为Top
Customer。

读取元素
~~~~~~~~

通常，我们已经知道我们正在读取的XML文档的结构。有鉴于此，XmlReader提供了一系列的假定特定结构的读取方法。这简化了我们的代码，同时可以执行某些验证。

ReadStartElement验证当前的NodeType为StartElement，然后调用Read。如果我们指定一个名字，他会验证其与当前元素相匹配。

ReadEndElement验证当前的NodeType为EndElement，然后调用Read。

例如要读取下面的XML文档：

.. code:: xml

    <firstname>Jim</firstname>

我们可以使用下面的代码：

.. code:: csharp

    reader.ReadStartElement ("firstname");
    Console.WriteLine (reader.Value);
    reader.ReadEndElement();

ReadElementContentAsString方法一次完成所有的工作。他会读取一个开始元素，一个文本节点以及一个结束元素，并将内容作为字符串返回：

string firstName = reader.ReadElementContentAsString ("firstname", "");

第二个参数涉及名字空间，在这个示例中为空。同时这个方法还有其他的版本类型，例如ReadElementContentAsInt，该方法会分析结果。回到我们原始的XML文档：

| `` ``\ \ ``Jim``\ 
| `` ``\ \ ``Bo``\ 
| `` ``\ \ ``500.00``\ \ ``    ``

我们可以使用下面的代码进行读取：

.. code:: csharp

    XmlReaderSettings settings = new XmlReaderSettings();
    settings.IgnoreWhitespace = true;
    using (XmlReader r = XmlReader.Create ("customer.xml", settings))
    {
      r.MoveToContent();                // Skip over the XML declaration
      r.ReadStartElement ("customer");
      string firstName    = r.ReadElementContentAsString ("firstname", "");
      string lastName     = r.ReadElementContentAsString ("lastname", "");
      decimal creditLimit = r.ReadElementContentAsDecimal ("creditlimit", "");
      r.MoveToContent();      // Skip over that pesky comment
      r.ReadEndElement();     // Read the closing customer tag
    }

**可选元素**

在前面的示例中，假定是可选的。其解决方案非常直接：

.. code:: csharp

    r.ReadStartElement ("customer");
    string firstName    = r. ReadElementContentAsString ("firstname", "");
    string lastName     = r.Name == "lastname"
                          ? r.ReadElementContentAsString() : null;
    decimal creditLimit = r.ReadElementContentAsDecimal ("creditlimit", "");

**随机元素顺序**

本节中的示例依赖XML文件中的元素以确定顺序出现。如果我们需要处理任意顺序的元素，最简单的解决方案就是将XML部分读取到一个X-DOM中。我们会在稍后探讨如何实现。

**空元素**

XmlReader处理空元素的方式存在一个可怕的陷阱。考虑下面的元素：

在XML中，这与下面的写法相同：

然而，XmlReader会对其区别对待。在前一种情况下，下面的代码会按照预期的样子工作：

.. code:: csharp

    reader.ReadStartElement ("customerList");
    reader.ReadEndElement();

在第二种情况下，ReadEndElement会抛出异常，因为并没有XmlReader所关注的单独的结束元素。解决方法就是检测空元素，如下所示：

.. code:: csharp

    bool isEmpty = reader.IsEmptyElement;
    reader.ReadStartElement ("customerList");
    if (!isEmpty) reader.ReadEndElement();

实际上，这只会出现在当元素也许会包含子元素时的情况。对于包含简单的文本的元素，我们可以通过调用如ReadElementContentAsString这样的方法来避免这些问题。ReadElementXXX方法会正确处理两种空元素类型。

**其他的ReadXXX方法**

表11-1总结了XmlReader中的所有ReadXXX方法。这些方法中的大多数被设计用来处理元素。以粗体显示的示例XML片段是由所描述的方法来读取的。

.. figure:: csharp_table_11.png
   :alt: csharp_table_11.png

   csharp\_table\_11.png
ReadContentAsXXX方法将文本分析为XXX类型。在内部，XmlConver类执行字符串到类型的转换。文本节点可以位于元素或是一个属性中。

ReadElementContentAsXXX方法是相应的ReadContentAsXXX方法的封装器。这些方法应用在元素节点上，而不是元素所包含的文本节点上。

ReadInnerXml通常应用到元素，读取并返回元素及其子节点。当应到属性上时，他会返回属性的值。

ReadOuterXml类似于ReadInnerXml，所不同的是，他会包含而不是排除光标位置处的元素。

ReadSubtree返回一个提供当前元素（及其子元素）视图的代理读取器。在原始的读取器可以被安全的读取之前，代理读取器必须被关闭。当代理读取器被关闭时，原始读取器的光标位置会移动到子树的结束处。

ReadToDescendent将光标移动到具有指定名字/名字空间的第一个子节点的起始处。

ReadToFollwing将光标移动到具有指定名字/名字空间的第一个节点的起始处－无论深度。

ReadToNextSibling将光标移动到具有指定名字/名字空间的第一个兄弟节点的起始处。

ReadString与ReadElementString的行为类似于ReadContentAsString与ReadElementContentAsString，所不同的是，如果在元素内有多个文本节点时前者会抛出异常。通常，应避免使用这些方法，因为如果一个元素包含有注释时这些方法会抛出异常。

读取属性
~~~~~~~~

XmlReader为我们提供了通过名字或是位置直接访问元素属性的索引器。使用索引器与调用GetAttribute方法等同。

给定下面的XML片段：

我们可以使用下面的代码读取其属性：

.. code:: csharp

    Console.WriteLine (reader ["id"]);              // 123
    Console.WriteLine (reader ["status"]);          // archived
    Console.WriteLine (reader ["bogus"] == null);   // True

尽管属性顺序在语义是无关的，我们可以通过其顺序位置来访问属性。我们可以使用下面的代码来重写前面的示例：

.. code:: csharp

    Console.WriteLine (reader [0]);            // 123
    Console.WriteLine (reader [1]);            // archived

索引器也可以允许我们指定属性的名字空间－如果有。

AttributeCount返回当前节点的属性数目。

**属性节点**

要显式的遍历属性节点，我们必须由仅是调用Read的普通路径进行转换。这样做的一个原因就在于如果我们要将属性值分析为其他类型，使用ReadContentAsXXX方法。

转换必须由起始元素开始。要使得处理更容易，前向规则在属性遍历中得到舒缓：我们可以通过调用MoveToAttribute跳到任意的属性处。

回到我们前面的示例：

我们可以使用下面的代码进行操作：

.. code:: csharp

    reader.MoveToAttribute ("status");
    string status = ReadContentAsString();
    reader.MoveToAttribute ("id");
    int id = ReadContentAsInt();

如果指定的属性不存在，MoveToAttribute会返回false。

我们也可以通过调用MoveToFirstAttribute然后调用MoveToNextAttribute方法顺序遍历所有属性：

.. code:: csharp

    if (reader.MoveToFirstAttribute())
      do
      {
        Console.WriteLine (reader.Name + "=" + reader.Value);
      }
      while (reader.MoveToNextAttribute());
    // OUTPUT:
    id=123
    status=archived

名字空间与前缀
~~~~~~~~~~~~~~

XmlReader为引用元素与属性名字提供了两个并行系统：

-  Name
-  NamespaceURI与LocalName

当我们读取元素的Name属性或是调用接受单个name参数的方法时，我们正在使用第一个系统。如果没有名字空间或是前缀时，这会工作得很好；否则就变成了一种较笨的方式。名字空间会被忽略，而前缀会按其所书写的样子被包含进来。例如：

.. code:: text

    Sample fragment             Name
    <customer ...>              customer
    <customer xmlns='blah' ...> customer
    <x:customer ...>            x:customer

下面的代码处理前两种情况：

reader.ReadStartElement ("customer");

要处理第三种情况则需要下面的代码：

reader.ReadStartElement ("x:customer");

第二个系统通过两个名字空间相关的属性进行工作：NamespaceURI与LocalName。这些属性考虑了前缀以及父元素所定义的默认名字空间。前缀被自动扩展。这意味着Namespace总是为当前的元素反映语义上正确的名字空间，而LocalName总是与前缀无关。

当我们向如ReadStartElement这样的方法传递两个命名参数时，则我们在使用相同的系统。例如，考虑下面的XML：

.. code:: csharp

    <customer xmlns="DefaultNamespace" xmlns:other="OtherNamespace">
      <address>
        <other:city>
        ...

我们可以使用下面的代码进行读取：

.. code:: csharp

    reader.ReadStartElement ("customer", "DefaultNamespace");
    reader.ReadStartElement ("address",  "DefaultNamespace");
    reader.ReadStartElement ("city",     "OtherNamespace");

如果需要，我们可以通过Prefix属性来查看我们所使用的前缀并通过调用LookupNamespace将其转换为名字空间。

XmlWriter
---------

Chapter 12. Disposal and Garbage Collection
===========================================

Chapter 13. Diagnostics and Code Contracts
==========================================

Chapter 14. Streams and I/O
===========================

本章探讨在.NET中用于输入输出的基础类型，着重强调以下主题：

-  .NET流体系结构以及他如何为跨越种种IO类型的读取提供了一致的编程接口
-  操作磁盘上的文件与目录
-  独立存储及其在隔离程序与用户数据中的角色

本章关注System.IO包中的类型，底层IO功能的大本营。.NET框架同时以各种形式提供了高层的IO功能，例如SQL连接与命令，LINQ到SQL以及LINQ到XML，WCF，Web
Services以及远程等。

流体系结构
----------

.NET流体系结构由三个概念组成：后端存储，装饰器以及适配器，如图14-1所示：

后端存储（backing
store）是使得输入输出有用的端点，例如文件或是网络连接。更确切的说，他是下列中的一个或同时是两个：

-  从中可以顺序读取字节的源
-  字节可以顺序写入的目标

后端存储是没有用的，除非向程序员公开。Stream是用该目的的标准.NET类；他公开了一个用于读取，写入与定位的标准方法集合。与数组不同，其后端存储只在内存中存在一次，流序化处理数据－一次一个字节或是可管理尺寸的块。所以，流可以使用较小的内存，而不论其后端存储的尺寸。

.. figure:: csharp_14_1.png
   :alt: csharp_14_1.png

   csharp\_14\_1.png
流分为两类：

-  后端存储流：这是与某种后端存储类型直接相关的，例如FileStream或NetworkStream
-  装饰流：这是由另一个流中获取的流，以某种方式转换数据，例如DeflateStream或CryptoStream。

装饰流具有下列的体系结构优点：

-  这将后端流由需要自己实现例如压缩或是加密这样的特性中解放出来
-  当被装饰后，流不再忍受接口变化的痛苦
-  我们在运行时连接到装饰器
-  我们可以将装饰器链接在一起

后端存储与装饰器流只以字节方式进行处理。尽管这比较灵活与高效，但是程序通常在更高的层次上进行处理，例如文本或是XML。适配器通过将流封装一个具有特殊方法来处理特定格式的类中来弥补这一缺陷。例如，一个文本读取器公开了一个ReadLine方法；一个XML写入器公开了WriteAttributes方法。

总结起来就是，后端存储流提供了原始数据；装饰器流提供了透明的二进制转换，例如加密；适配器提供了类型方法来以高级类型形式处理数据，例如字符串与XML。图14-1显示他们之间的关系。要形成一个链，我们只需要简单的将一个对象传递给另一个的构造器。

使用流
------

抽象的Stream类是所有流的基类。他为三个基础操作定义了方法与属性：读取，写入与定位，以及管理任务例如关闭，输出缓冲以及配置超时（如表14-1所示）。

.. figure:: csharp_table_14_1.png
   :alt: csharp_table_14_1.png

   csharp\_table\_14\_1.png
在下面的示例中，我们使用一个文件流来读取，写入并定位：

.. code:: csharp

    using System;
    using System.IO;
    class Program
    {
      static void Main()
      {
        // Create a file called test.txt in the current directory:
        using (Stream s = new FileStream ("test.txt", FileMode.Create))
        {
          Console.WriteLine (s.CanRead);       // True
          Console.WriteLine (s.CanWrite);      // True
          Console.WriteLine (s.CanSeek);       // True
          s.WriteByte (101);
          s.WriteByte (102);
          byte[] block = { 1, 2, 3, 4, 5 };
          s.Write (block, 0, block.Length);     // Write block of 5 bytes
          Console.WriteLine (s.Length);         // 7
          Console.WriteLine (s.Position);       // 7
          s.Position = 0;                       // Move back to the start
          Console.WriteLine (s.ReadByte());     // 101
          Console.WriteLine (s.ReadByte());     // 102
          // Read from the stream back into the block array:
          Console.WriteLine (s.Read (block, 0, block.Length));   // 5
          // Assuming the last Read returned 5, we'll be at
          // the end of the file, so Read will now return 0:
          Console.WriteLine (s.Read (block, 0, block.Length));   // 0
        }
      }
    }

读取与写入
~~~~~~~~~~

一个流也许支持读取，写入或是两者。如果CanWrite返回false，则流是只读的；如果CanRead返回false，则流是只写的。

Read由流中读取一个数据块并存入一个数组。他返回所读取的字节数，返回值总是小于或是等于count参数。如果返回值小于count，则意味着或者是到达了流的结尾，或者是流以更小的块向我们提供数据（在网络流中经常如此）。在任何一种情况下，数组中余下的字节都会保持不可写，从而保存他们以前的值。

下面是读取1000个字节流的正确方式：

.. code:: csharp

    byte[] data = new byte [1000];
    // bytesRead will always end up at 1000, unless the stream is
    // itself smaller in length:
    int bytesRead = 0;
    int chunkSize = 1;
    while (bytesRead < data.Length && chunkSize > 0)
      bytesRead +=
        chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);

ReadBye方法更为简单：他仅读取一个字节，返回-1表示到达了流的结尾。ReadByte实际上返回int而不是byte，因为后者不能返回-1。

Write与WriteByte方法向流输出数据。如果他们不能输出指定的字节数，则会抛出异常。

注意，在Read与Write方法中，offset参数指读取或写在buffer数组中开始的索引，而不是流中的位置。

流也可以通过BeginRead与BeginWrite方法支持异步读取与写入。异步方法本意是用于高吞吐量的服务器程序，我们会在第23章中进行描述。

定位
~~~~

如果CanSeek方法返回true，则流是可定位的。对于可定位的流（例如文件流），我们可以查询或是修改其Length（通过调用SetLenght），并且在任何时刻修改我们正在读取或是写入的Position。Position属性是相对于流的起始处的；然而，Seek方法可以使得我们相对于当前位置或是文件的结束处进行移动。

注意，在FileStream上改变Position通常会花费几毫秒的时间。如果我们在一个循环中执行几百万次，框架4.0中新的MemoryMappedFile类是比FileStream更好的选择。

对于不可定位的流（例如加密流），确定其长度的唯一方法就是完全读取。而且，如果我们需要重新读取前面的一部分，我们必须关闭流并重新读取。

关闭与输出缓冲
~~~~~~~~~~~~~~

流在使用之后必须销毁来释放底层资源，例如文件或是套接字句柄。保证关闭流的最简单方法是在using块中实例化流。通常，流遵循标准的销毁语义：

-  Dispose与Close在功能上是相同的
-  重复销毁或是关闭流不会引起错误

关闭一个装饰器流会同时关闭装饰器以及其后端存储流。对于一个装饰器链，关闭最外层的装饰器（位于链的头部）会关闭整个装饰器链。

某些流在内部会缓冲要写入后端存储的数据或是由后端存储读取的数据来减少读取的来回次数从而改进性能（文件流就是一个好例子）。这意味着我们要写入流的数据也许并没有立即写入后端存储；写入会被延迟直到缓冲区被填满。Flush方法会强制在内部缓冲的数据被立即写入。Flush方法在流被关闭时自动调用的，所以我们不需要执行下面的语句：

s.Flush(); s.Close();

超时
~~~~

如果CanTimeout返回true，则流支持读写超时。网络支持超时；文件流与内存流则不支持。对于支持超时的流，ReadTimeout与WriteTimeout属性决定了所需要的超时时间，以毫秒计，0则为不超时。Read与Write方法通过抛出异常来表明发生了超时。

线程安全
~~~~~~~~

作为一条规则，流不是线程安全的，意味着两个线程不能同时读取或是写入相同的流，以避免错误。Stream类通过静态的Synchronized方法提供了一个简单的解决办法。这个方法接受一个任意类型的流并返回一个线程安全的包装器。包装器通过获取读取，写入或是定位上的一个排他锁来进行工作，从而保证在任意时刻只有一个线程可以执行这样的操作。实践中，这会使得多个线程同时向相同的流中添加数据－其他的活动（例如并行读取）需要额外的锁来保证每一个线程访问流的确定部分。我们将会在第21章中探讨线程安全。

后端存储流
~~~~~~~~~~

图14-2显示了.NET框架所提供的关键后端存储流。同时还有一个“空流”，是通过Stream的静态Null域来提供的。

在下面的部分中，我们描述FileStream与MemoryStream；在本章的最后一部分，我们描述IsolatedStorageStream。在第15章中，我们探讨NetworkStream。

.. figure:: csharp_14_2.png
   :alt: csharp_14_2.png

   csharp\_14\_2.png
FileStream
~~~~~~~~~~

在本章前面的内容中，我们演示了使用FileStream来读取与写入数据字节的基本用法。接下来我们将会探讨这个类的特性。

**构建FileStream**

实例化一个FileStream的最简单方法就是使用下面File类的静态方法中的一个：

.. code:: csharp

    FileStream fs1 = File.OpenRead  ("readme.bin");            // Read-only
    FileStream fs2 = File.OpenWrite (@"c:\temp\writeme.tmp");  // Write-only
    FileStream fs3 = File.Create    (@"c:\temp\writeme.tmp");  // Read/write

如果文件已经存在，则OpenWrite与Create的行为会有所不同。Create会清除已存在内容；OpenWrite会完整的保留已存在的内容并将流定位在起始处。如果我们写入的字节小于文件中已存在的字节数，则OpenWrite会留给我们一个新旧内容的混合体。

我们也可以直接初始化一个FileStream。其构造器提供了到其每一个特性的访问，使得我们可以指定文件名或是底层文件句柄，文件创建与访问模式，以及共享，缓冲，安全等选项。下面的代码打开一个已存在的文件用于读写访问而不覆盖：

var fs = new FileStream ("readwrite.tmp", FileMode.Open); // Read/write

稍后我们会探讨FileMode的更多内容。

**指定文件名**

文件名可以是绝对路径或是相对于当前目录的相对路径。我们可以通过静态的Environment.CurrentDirectory属性来修改当前目录。

AppDomain.CurrentDomain.BaseDirectory返回程序基目录，通常情况下是包含可执行程序的目录。要指定一个相对于该目录的文件名，我们可以调用Path.Combine方法：

.. code:: csharp

    string baseFolder = AppDomain.CurrentDomain.BaseDirectory;
    string logoPath = Path.Combine (baseFolder, "logo.jpg");
    Console.WriteLine (File.Exists (logoPath));

我们可以通过UNC路径来进行跨网络的读写，例如
\\\\JoesPC\\PicShare\\pic.jpg or \\\\10.1.1.2\\PicShare\\pic.jpg。

**指定FileMode**

所有接受文件名的FileStream构造器同时也需要一个FileMode枚举参数。图14-3显示了如何选择FileMode，以及选择所产生的类似于在File类上调用静态方法的结果。

.. figure:: csharp_14_3.png
   :alt: csharp_14_3.png

   csharp\_14\_3.png
仅使用文件名或是FileMode构造FileStream会为我们构建一个可读或写的流。如果我们同时提供FileAccess参数，我们就可以进一步请求相应的访问模式：

.. code:: csharp

    [Flags]
    public enum FileAccess { Read = 1, Write = 2, ReadWrite = 3 }

下面的代码会返回一个只读流，与调用File.OpenRead等同：

using (var fs = new FileStream ("x.bin", FileMode.Open,
FileAccess.Read))

FileModel.Append是一个奇怪的访问模式，使用这个模式我们可以获得一个只写的流。要添加读写支持，我们必须使用FileMode.Open或是FileMode.OpenOrCreate，然后定位到流的结尾：

.. code:: csharp

    using (var fs = new FileStream ("myFile.bin", FileMode.Open))
    {
      fs.Seek (0, SeekOrigin.End);
      ...

**高级FileStream特性**

下面是当我们构建FileStream时我们可以包含的其他参数：

-  FileShare枚举，描述了在我们完成之前向深入相同文件的其他进程授予多个权限（None，Read（默认），ReadWrite或是Write）。
-  以字节表示的内部缓冲区的大小（当前默认值为4KB）
-  表明是否推迟操作系统异步IO的标记
-  FileSecurity对象，描述了向新文件赋值哪种用户与角色权限
-  请求操作系统加密（Encrypted）的FileOptions标记，他会在临时文件关闭时自动删除（DeleteOnClose）以及优化建议（RandomAccess与SequentialScan）。同时有一个请求操作系统禁止write-behind缓存的WriteThrough标记；这用于相互影响的文件或是日志。

使用FileShare.ReadWrite打开文件会使得其他进程或是用户同时读写相同的文件。为了避免混乱，我们可以使用下面的方法在读写之前锁定文件的特定部分：

.. code:: csharp

    // Defined on the FileStream class:
    public virtual void Lock   (long position, long length);
    public virtual void Unlock (long position, long length);

如果所请求的文件部分已经被锁定了，Lock则抛出异常。这为系统用于基于文件的数据库，例如Access与FoxPro。

MemoryStream
~~~~~~~~~~~~

MemoryStream使用数组作为后端存储。这在某种程度上破坏了拥有流的目的，因为整个的后端存储只在内存中存在一次。然而，MemoryStream依然有用；当我们需要随机访问一个不可定位的流时就是一个好例子。如果我们知道源流将是可管理尺寸的，那么我们就可以将其拷贝到MemoryStream中，如下所示：

.. code:: csharp

    static MemoryStream ToMemoryStream (this Stream input, bool closeInput)
    {
      try
      {                                         // Read and write in
        byte[] block = new byte [0×1000];       // blocks of 4K.
        MemoryStream ms = new MemoryStream();
        while (true)
        {
          int bytesRead = input.Read (block, 0, block.Length);
          if (bytesRead == 0) return ms;
          ms.Write (block, 0, bytesRead);
        }
      }
      finally { if (closeInput) input.Close (); }
    }

closeInput输入参数的目的就是为了避免方法作者以及消费者认为对方关闭流的情况。

我们可以通过调用ToArray将一个MemoryStream转换为一个字节数组。GetBuffer方法通过直接引用底层存储数组可以高效的完成相同的工作；不幸的是，这个数组通常要长于流的实际长度。

我们可以在本章稍后的部分中看到更多MemoryStream的例子。

PipeStream
~~~~~~~~~~

PipeStream是在框架3.5中引入的。他提供了一个简单的方法，通过这个方法一个进程可以通过Windows管道协议与另一个进程进行交互。有两种管道类型：

-  匿名管道：允许在相同的计算机上的父子进程之间的单向通信
-  命名管道：允许在相同的计算机上或是跨Windows网络的不同计算机上的任意进程之间的双向通信

管道适于单个计算机上的进程间通信（IPC）：他并不依赖于网络传输，从而可以获得良好的性能并且没有防火墙的问题。

PipeStream是一个具有四个具体子类的抽象类。其中两个用于匿名管道，而另两个用于命名管道：

-  匿名管道：AnonymousPipeServerStream与AnonymousPipeClientStream
-  命名管道：NamedPipeServerStream与NamedPipeClientStream

命名管道更易于使用，我们会首先进行描述。

**命名管道**

使用命名管道，参与者可以通过相同名字的管道进行通信。协议定义了两个不同的角色：客户端与服务器。客户端与服务器之间的通信如下：

-  服务器实例化NamedPipeServerStream然后调用WaitForConnection。
-  客户端实例化NamedPipeClientStream然后调用Connect（具有可选的超时时间）。

然后两个参与者读取与写入流进行通信。

下面的示例演示了发送一个字节（100）并等待接收一个字节的服务器：

.. code:: csharp

    using (var s = new NamedPipeServerStream ("pipedream"))
    {
      s.WaitForConnection();
      s.WriteByte (100);
      Console.WriteLine (s.ReadByte());
    }

下面是相应的客户端代码：

.. code:: csharp

    using (var s = new NamedPipeClientStream ("pipedream"))
    {
      s.Connect();
      Console.WriteLine (s.ReadByte());
      s.WriteByte (200);                 // Send the value 200 back.
    }

默认情况下，命名管道流是双向的，所以任意一个参与者都可以读取或是写入流。这意味着客户端与服务器必须遵循相同的协议来协调他们的动作，从而两个参与者不会同时发送或是接收数据。

同时还需要在每次传输的长度上达到一致。我们的示例就是具有这样的考虑，因为在每个方向上我们限定为只有一个字节。为了处理多于一个字节的消息
，管道提供了消息传输模式。如果允许了这种模式，调用Read的参与者可以通过检测IsMessageComplete属性来确定消息是否已经完成。为了进行演示，我们编写了一个助手方法，这个方法会由打开消息模式的PipeStream中读取完整的消息－－换句话说，读取直到IsMessageComplete为真：

.. code:: csharp

    static byte[] ReadMessage (PipeStream s)
    {
      MemoryStream ms = new MemoryStream();
      byte[] buffer = new byte [0×1000];      // Read in 4 KB blocks
      do    { ms.Write (buffer, 0, s.Read (buffer, 0, buffer.Length)); }
      while (!s.IsMessageComplete);
      return ms.ToArray();
    }

现在我们可以激活消息传输模式。在服务器端，这是通过在构建流时指定PipeTransmissionMode.Message来实现的：

.. code:: csharp

    using (var s = new NamedPipeServerStream ("pipedream", PipeDirection.InOut,
                                              1, PipeTransmissionMode.Message))
    {
      s.WaitForConnection();
      byte[] msg = Encoding.UTF8.GetBytes ("Hello");
      s.Write (msg, 0, msg.Length);
      Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));
    }

在客户端，我们通过在调用Connect之后设置ReadMode来激活消息传输模式：

.. code:: csharp

    using (var s = new NamedPipeClientStream ("pipedream"))
    {
      s.Connect();
      s.ReadMode = PipeTransmissionMode.Message;
      Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));
      byte[] msg = Encoding.UTF8.GetBytes ("Hello right back!");
      s.Write (msg, 0, msg.Length);
    }

**匿名管道**

匿名管道在父子进程之间提供了单向通信。匿名管道并不使用系统的名字，而是通过私有句柄实现。

类似于命名管道，匿名管道也有客户端与服务器的角色。然而，通信系统略为不同，并且处理过程如下：

#. 服务器端实例化AnonymousPipeServerStream，将PipeDirection设置为In或是Out。
#. 服务器调用GetClientHandleAsString来获得一个管道的标记符，然后将其传递给客户端（通常在启动子进程时作为参数）。
#. 子进程实例化AnonymousPipeClientStream，指定相反的PipeDirection。
#. 服务器通过调用DisposeLocalCopyOfClientHandle来释放在第2步生成的局部句柄。
#. 父进程与子进程通过读取/写入流来进行通信。

因为匿名管道是单向的，要实现双向通信，服务器必须创建两个管道。下面演示了一个向子进程发送一个字节并由子进程接受一个字节的服务器：

.. code:: csharp

    string clientExe = @"d:\PipeDemo\ClientDemo.exe";
    HandleInheritability inherit = HandleInheritability.Inheritable;
    using (var tx = new AnonymousPipeServerStream (PipeDirection.Out, inherit))
    using (var rx = new AnonymousPipeServerStream (PipeDirection.In, inherit))
    {
      string txID = tx.GetClientHandleAsString();
      string rxID = rx.GetClientHandleAsString();
      var startInfo = new ProcessStartInfo (clientExe, txID + " " + rxID);
      startInfo.UseShellExecute = false;      // Required for child process
      Process p = Process.Start (startInfo);
      tx.DisposeLocalCopyOfClientHandle();    // Release unmanaged
      rx.DisposeLocalCopyOfClientHandle();    // handle resources.
      tx.WriteByte (100);
      Console.WriteLine ("Server received: " + rx.ReadByte());
      p.WaitForExit();
    }

下面是编译为d:\\PipeDemo\\Cli-entDemo.exe的相对应的客户端代码：

.. code:: csharp

    string rxID = args[0];    // Note we're reversing the
    string txID = args[1];    // receive and transmit roles.
    using (var rx = new AnonymousPipeClientStream (PipeDirection.In, rxID))
    using (var tx = new AnonymousPipeClientStream (PipeDirection.Out, txID))
    {
      Console.WriteLine ("Client received: " + rx.ReadByte());
      tx.WriteByte (200);
    }

与命名管道类似，客户端与服务器必须协调他们的发送与接收以及每一个次传输的数据长度。不幸的是，匿名管道不支持消息模式，所以我们必须为消息长度约定实现我们自己的协议。一个解决方法就是在每一次传输之前发送四个字节，作为定义其后消息长度的整数值。BitConverter类提供了用于在整数与四字节数组之间进行转换的方法。

BufferedStream
~~~~~~~~~~~~~~

BufferedStream装饰或是包装另一个流使其具有缓冲功能，而他是.NET框架中大量的装饰器流类型中的一个，如图14-4所示：

.. figure:: csharp_14_4.png
   :alt: csharp_14_4.png

   csharp\_14\_4.png
缓冲通过减少与后端存储的交互而改善性能。下面显示了我们如何将一个FileStream包装为一个20KB的BufferedStream：

.. code:: csharp

    // Write 100K to a file:
    File.WriteAllBytes ("myFile.bin", new byte [100000]);
    using (FileStream fs = File.OpenRead ("myFile.bin"))
    using (BufferedStream bs = new BufferedStream (fs, 20000))  //20K buffer
    {
      bs.ReadByte();
      Console.WriteLine (fs.Position);         // 20000
    }

在这个示例中，由于读取缓冲，底层流在仅读取1个字节之后读取了20000个字节。我们可以在与FileStream再次交互之前调用ReadByte
19999次。

类似于这个示例，将BufferedStream与FileStream组合并没有太大我价值，因为FileStream已经具有内建的缓冲。他唯一的用处也许就是在已经构建的FileStream上增大缓冲。

关闭BufferedStream会自动关闭底层的后端存储流。

流适配器
--------

Stream只能以字节方式进行处理；要读取或是写入例如字符串，整数或是XML元素这样的数据类型，我们必须借助于适配器。下面是框架所提供的适配：

-  文本适配器（用于字符串与字符数据）：TextReader，TextWriter，StreamReader，StreamWriter，StringReader，StringWriter
-  二进制适配器（用于基础数据类型，例如int，bool，string与float）：BinaryReader，BinaryWriter
-  XML适配器：XmlReader，XmlWriter

这些类型之间的关系如图14-5所示：

.. figure:: csharp_14_5.png
   :alt: csharp_14_5.png

   csharp\_14\_5.png
文本适配器
~~~~~~~~~~

TextReader与TextWriter是用于处理字符与字符串的适配器的抽象基类。在框架中，每一个都有两个通用目的的实现：

-  StreamReader/StreamWriter：使用Stream作为原始的数据源，将流字节转换为字符或是字符串
-  StringReader/StringWriter：使用内存字符串实现了TextReader/TextWriter

表14-2分类列表了TextReader的成员。Peek返回流中的下一个字符，而不会改变位置。如果到达流的末尾，Peek与Read的零参数版本都会返回-1；否则，他们返回一个可以直接转换为char的整数。接受char[]缓冲的重载Read方法在功能上与ReadBlock方法相同。ReadLine读取直到遇到CR（字符13）或是LF（字符10）或是CR+LF对。然后他会返回一个字符串，丢弃CR/LF字符。

.. figure:: csharp_table_14_2.png
   :alt: csharp_table_14_2.png

   csharp\_table\_14\_2.png
TextWriter具有用于写入的相似方法，如表14-3所示。Write与WriteLine方法都被重载来失道寡助任意的基本类型，以及object类型。这些方法会在所传递进来的对象上调用ToString方法（或者是通过在调用方法或是构建TextWriter时指定的IFormatProvider）。

.. figure:: csharp_table_14_3.png
   :alt: csharp_table_14_3.png

   csharp\_table\_14\_3.png
WriteLine会简单的为所指定的文本添加CR+LF。我们可以通过NewLine属性来修改（这对于Unix文件格式交互时十分有用）。

**StreamReader与StreamWriter**

在下面的示例中，StreamWriter向文件写入两行许可证，然后StreamReader读取这个文件：

.. code:: csharp

    using (FileStream fs = File.Create ("test.txt"))
    using (TextWriter writer = new StreamWriter (fs))
    {
      writer.WriteLine ("Line1");
      writer.WriteLine ("Line2");
    }
    using (FileStream fs = File.OpenRead ("test.txt"))
    using (TextReader reader = new StreamReader (fs))
    {
      Console.WriteLine (reader.ReadLine());       // Line1
      Console.WriteLine (reader.ReadLine());       // Line2
    }

因为文本适配器经常与文件进行交互，File提供了静态的CreateText，AppendText以及OpenText来简化处理：

.. code:: csharp

    using (TextWriter writer = File.CreateText ("test.txt"))
    {
      writer.WriteLine ("Line1");
      writer.WriteLine ("Line2");
    }
    using (TextWriter writer = File.AppendText ("test.txt"))
      writer.WriteLine ("Line3");
    using (TextReader reader = File.OpenText ("test.txt"))
      while (reader.Peek() > ?1)
        Console.WriteLine (reader.ReadLine());     // Line1
                                                   // Line2
                                                   // Line3

这同时演示了如何测试文件的结尾（通过reader.Peek()）。另一种方法就是一直读取直到reader.ReadLine返回null。

我们也可以读取或是写入其他的类型，例如整数，但是因为TextWriter在我们的类型上调用ToString方法，当我们重新读取时必须分析字符串：

.. code:: csharp

    using (TextWriter w = File.CreateText ("data.txt"))
    {
      w.WriteLine (123);          // Writes "123"
      w.WriteLine (true);         // Writes the word "true"
    }
    using (TextReader r = File.OpenText ("data.txt"))
    {
      int myInt = int.Parse (r.ReadLine());     // myInt == 123
      bool yes = bool.Parse (r.ReadLine());     // yes == true
    }

**字符编码**

TextReader与TextWriter仅是不具有到流或是后端存储连接的抽象类。然而，StreamReader与StreamWriter类型则连接到底层面向字节的流，所以他们必须在字符与字节之间进行转换。他们是通过System.Text名字空间听
Encoding类来完成的，我们可以在构建StreamReader或是StreamWriter时选择。如果我们没有选择，则使用默认的UTF-8编码。

最简单的编码是ASCII编码，因为每一个字符由一个字节表示。ASCII编码将Unicode集合中的前127个字符映射为单个字节，转换我们在US风格的键盘上所看到的字符。大多数其他的字符，包括特殊符号以及非英语字符不能被表示，并被转换为□字符。默认的UTF-8编码可以映射所有的Unicode字符，但是他更为复杂。为了与ASCII兼容，前127个字符被编码为单个字节；其余的字符被编码为变化的字节数（通常是两个或是三个）。例如：

.. code:: csharp

    using (TextWriter w = File.CreateText ("but.txt"))    // Use default UTF-8
      w.WriteLine ("but-");                               // encoding.
    using (Stream s = File.OpenRead ("but.txt"))
      for (int b; (b = s.ReadByte()) > ?1;)
        Console.WriteLine (b);

单词“but”之后并不是一个标准的连字符，而是一个更长的em
dash字符(—)，U+2014。这不会使得我们的书本编辑器遇到麻烦。让我们看一下其输出：

.. code:: csharp

    98     // b
    117    // u
    116    // t
    226    // em dash byte 1       Note that the byte values
    128    // em dash byte 2       are >= 128 for each part
    148    // em dash byte 3       of the multibyte sequence.
    13     // <CR>
    10     // <LF>

由于em
dash位于Unicode集合中前127个字符之外，他要求更多个的字节来进行UTF-8编码（在这个示例中为三个）。UTF-8足够表示西方字符，因为大多数字符仅需要一个字节。通过简单的忽略127以上的字符，他可以很容易的转换为ASCII字符。其缺点是在流中定位比较麻烦，因为一个字符的位置并不与流中其字节位置相对应。另一种方法是UTF-16。下面是我们使用UTF-16编写相同的字符串：

.. code:: csharp

    using (Stream s = File.Create ("but.txt"))
    using (TextWriter w = new StreamWriter (s, Encoding.Unicode))
      w.WriteLine ("but-");
    foreach (byte b in File.ReadAllBytes ("but.txt"))
      Console.WriteLine (b);

其输出如下：

.. code:: csharp

    255    // Byte-order mark 1
    254    // Byte-order mark 2
    98     // 'b' byte 1
    0      // 'b' byte 2
    117    // 'u' byte 1
    0      // 'u' byte 2
    116    // 't' byte 1
    0      // 't' byte 2
    20     // '--' byte 1
    32     // '--' byte 2
    13     // <CR> byte 1
    0      // <CR> byte 2
    10     // <LF> byte 1
    0      // <LF> byte 2

由技术上来说，UTF-16为每个字符使用两个或是四个字节（（有近100万个Unicode字符或是保留的，所以2个字节有时并不够）。然而，因为C#
char类型本身是16位宽，UTF-16编码为每一个.NET
char使用两个字节。这使得在流中很容易定位到一个特定的字符索引。

UTF-16使用两个字节前缀来表示字节对是以“小端”顺序还是“大端”顺序来编写。对于基于Windows的系统则为小端顺序。

**StringReader与StringWriter**

StringReader与StringWriter并没有封装流；相反，他们使用字符串或是StringBuilder作为底层数据存储。这就意味着并不需要字节转换－事实上，除了我们使用字符串或是StringBuilder结合索引变量很容易实现的事情以外，这个类并不能做其他事情。他们的优点是与StreamReader/StringWriter共享相同的基类。例如，假设我们有一个包含XML的字符串，并且希望使用XmlReader进行分析。XmlReader.Create可以接受下列中的一个：

-  URI
-  Stream
-  TextReader

那么我们如何使用XML分析我们的字符串？因为StringReader是TextReader的一个子类，则我们可以实例化并传递一个StringReader，如下所示：

XmlReader r = XmlReader.Create (new StringReader (myString));

二进制适配器
~~~~~~~~~~~~

BinaryReader与BinaryWriter可以读取与写入本地数据类型：bool，byte，char，decimal，float，double，short，int，long，sbyte，ushort，unit与ulong，以及string和基础数据类型的数组。

与StreamReader和StreamWriter不同，二进制适配器可以高效的存储基础数据类型，因为他们在内存中表示。所以，一个int使用四个字节；一个double使用八个字节。字符串通过文本编码进行输出（类似于StreamReader与StreamWriter），但却是固定长度的，为了再次读取一系列的字符串而不需要特殊的分隔符。

假定我们有一个简单的类型，定义如下：

.. code:: csharp

    public class Person
    {
      public string Name;
      public int    Age;
      public double Height;
    }

我们可以为Person添加下面的方法来使用二进制适配器将数据保存到流中或是由流中载入数据：

.. code:: csharp

    public void SaveData (Stream s)
    {
      var w = new BinaryWriter (s);
      w.Write (Name);
      w.Write (Age);
      w.Write (Height);
      w.Flush();         // Ensure the BinaryWriter buffer is cleared.
                         // We won't dispose/close it, so more data
    }                    // can be written to the stream.
    public void LoadData (Stream s)
    {
      var r = new BinaryReader (s);
      Name   = r.ReadString();
      Age    = r.ReadInt32();
      Height = r.ReadDouble();
    }

BinaryReader也可以读取到字符数组中。下面的代码读取整个可定位流的内容：

byte[] data = new BinaryReader (s).ReadBytes ((int) s.Length);

这要比直接由流中读取更为方便，因为他不需要循环来保证已读取全部的数据。

关闭与销毁流适配器
~~~~~~~~~~~~~~~~~~

关闭流适配器时我们下列四个选择：

#. 仅关闭适配器
#. 关闭适配器，然后关闭流
#. （对于写入）冲刷适配器（输出缓冲），然后关闭流
#. （对于读取）仅关闭流

选项1与2在语义是上相同的，因为关闭适配器会自动关闭底层流。当我们嵌入using语句时，我们隐式的选择了选项2：

.. code:: csharp

    using (FileStream fs = File.Create ("test.txt"))
    using (TextWriter writer = new StreamWriter (fs))
      writer.WriteLine ("Line");

由于嵌入语句是由里向外销毁，所以适配器被首先关闭，然后是流。而且，如果在适配器的构造器中抛出异常，流仍然关闭。嵌入的using语句很难遇到错误。

选项3与选项4之所以工作是由于适配器属于可销毁的对象类别。一个使用示例就是当我们已完成适配器的使用时，我们也许会选择不销毁适配器，而保持底层流打开以用于后续使用：

.. code:: csharp

    using (FileStream fs = new FileStream ("test.txt", FileMode.Create))
    {
      StreamWriter writer = new StreamWriter (fs);
      writer.WriteLine ("Hello");
      writer.Flush();
      fs.Position = 0;
      Console.WriteLine (fs.ReadByte());
    }

在这里我们写入文件，重新定位流，并且在关闭流之前读取第一个字节。如果我们销毁StreamWriter，他也会关闭底层的FileStream，从而例程后续的读取操作失败。这样做的限制则是我们调用Flush来保证StreamWriter的缓冲被写入底层流中。

文件与目录操作
--------------

System.IO名字空间提供了一个执行文件与目录操作的类型集合，例如拷贝与移动，创建目录，以及设置文件的属性与权限等。对于大多数特性，我们可以在两个类之间进行选择，一个提供了静态方法而另一个提供了实例化方法：

-  静态类：File与Directory
-  实例方法类（使用文件或是目录名构建）：FileInfo与DirectoryInfo

另外，还有一个名为Path的静态类。这个类对于文件或是目录并没有什么；相反，他为文件名与目录路径提供了字符串处理的方法。Path同时辅助临时文件处理。

File类
~~~~~~

File是一个静态类，其方法接受文件名。文件名可以相对于当前目录或是具有目录的绝对路径。该类所具有的方法如下：

.. code:: csharp

    bool Exists (string path);      // Returns true if the file is present
    void Delete  (string path);
    void Copy    (string sourceFileName, string destFileName);
    void Move    (string sourceFileName, string destFileName);
    void Replace (string sourceFileName, string destinationFileName,
                                         string destinationBackupFileName);
    FileAttributes GetAttributes (string path);
    void SetAttributes           (string path, FileAttributes fileAttributes);
    void Decrypt (string path);
    void Encrypt (string path);
    DateTime GetCreationTime   (string path);      // UTC versions are
    DateTime GetLastAccessTime (string path);      // also provided.
    DateTime GetLastWriteTime  (string path);
    void SetCreationTime   (string path, DateTime creationTime);
    void SetLastAccessTime (string path, DateTime lastAccessTime);
    void SetLastWriteTime  (string path, DateTime lastWriteTime);
    FileSecurity GetAccessControl (string path);
    FileSecurity GetAccessControl (string path,
                                   AccessControlSections includeSections);
    void SetAccessControl (string path, FileSecurity fileSecurity);

如果目标文件已经存在，则Move会抛出异常；Replace则不会。两个方法都允许文件被重命名以及移动到另一个目录中。

如果文件被标记为只读，则会抛出UnauthorizedAccessException；如果我们通过调用GetAttributes来识别属性。下面是GetAttributes返回的FileAttribute枚举成员：

.. code:: csharp

    Archive, Compressed, Device, Directory, Encrypted,
    Hidden, Normal, NotContentIndexed, Offline, ReadOnly,
    ReparsePoint, SparseFile, System, Temporary

这个枚举中的成员是可组合的。下面显示如何修改文件的一个属性而不影响其他的属性：

.. code:: csharp

    string filePath = @"c:\temp\test.txt";
    FileAttributes fa = File.GetAttributes (filePath);
    if ((fa & FileAttributes.ReadOnly) > 0)
    {
        fa ^= FileAttributes.ReadOnly;
        File.SetAttributes (filePath, fa);
    }
    // Now we can delete the file, for instance:
    File.Delete (filePath);

**压缩与加密属性**

Compressed与Encrypted文件属性对应于Windows文件管理器中文件或是目录属性对话框中的压缩与加密复选框。这种压缩与加密类型是透明的，因为操作系统会在幕后完成所有的工作，使得我们可以读取与写入普通数据。

我们不能使用SetAttributes来修改文件的Compressed或是Encrypted属性－如果我们这样做则会静默失败。在后一种情况中工作过程很简单：我们调用File类中的Encypt()与Decrypt()方法。对于压缩，他则更为复杂；一种解决方法就是使用System.Management中的Windows管理工具（WMI）。下面的代码压缩一个目录，如果成功则返回0（或者是失败时返回一个WMI代码）：

.. code:: csharp

    static uint CompressFolder (string folder, bool recursive)
    {
      string path = "Win32_Directory.Name='" + folder + "'";
      using (ManagementObject dir = new ManagementObject (path))
      using (ManagementBaseObject p = dir.GetMethodParameters ("CompressEx"))
      {
        p ["Recursive"] = recursive;
        using (ManagementBaseObject result = dir.InvokeMethod ("CompressEx",
                                                                 p, null))
          return (uint) result.Properties ["ReturnValue"].Value;
      }
    }

要解压，将CompressEx替换为UncompressEx。

透明加密依赖于由登陆用户的密码生成的键。系统对于验证用户所做的密码修改是健壮的，但是如果密码被管理员重置，加密文件中的数据则不可恢复。

我们可以使用Win32交互是确定一个卷是否支持压缩与加密：

.. code:: csharp

    using System;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;
    class SupportsCompressionEncryption
    {
      const int SupportsCompression = 0×10;
      const int SupportsEncryption = 0×20000;
      [DllImport ("Kernel32.dll", SetLastError = true)]
      extern static bool GetVolumeInformation (string vol, StringBuilder name,
        int nameSize, out uint serialNum, out uint maxNameLen, out uint flags,
        StringBuilder fileSysName, int fileSysNameSize);
      static void Main()
      {
        uint serialNum, maxNameLen, flags;
        bool ok = GetVolumeInformation (@"C:\", null, 0, out serialNum,
                                        out maxNameLen, out flags, null, 0);
        if (!ok)
          throw new Win32Exception();
        bool canCompress = (flags & SupportsCompression) > 0;
        bool canEncrypt = (flags & SupportsEncryption) > 0;
      }
    }

**文件安全**

GetAccessControl与SetAccessControl方法可以使得我们查询并修改通过FileSecurity对象（System.Security.AccessControl名字空间）赋给用户与角色的操作系统权限。我们也可以在创建新文件时向FileStream的构造器传递FileSecurity来指定权限。

在这个示例中，我们列出文件已存在的权限，然后向“Users”赋予执行权限：

.. code:: csharp

    using System;
    using System.IO;
    using System.Security.AccessControl;
    using System.Security.Principal;
    ...
    FileSecurity sec = File.GetAccessControl (@"c:\temp\test.txt");
    AuthorizationRuleCollection rules = sec.GetAccessRules (true, true,
                                                         typeof (NTAccount));
    foreach (FileSystemAccessRule rule in rules)
    {
      Console.WriteLine (rule.AccessControlType);         // Allow or Deny
      Console.WriteLine (rule.FileSystemRights);          // e.g., FullControl
      Console.WriteLine (rule.IdentityReference.Value);   // e.g., MyDomain/Joe
    }
    FileSystemAccessRule newRule = new FileSystemAccessRule
      ("Users", FileSystemRights.ExecuteFile, AccessControlType.Allow);
    sec.AddAccessRule (newRule);
    File.SetAccessControl (@"c:\temp\test.txt", sec);

Directory类
~~~~~~~~~~~

静态Directory类提供了与File类中的方法类似的方法集合－用于检测目录是否存在（Exists），移动目录（Move），删除目录（Delete），读取/设置创建或是上次访问的时间，以及读取/设置安全权限。而且，Diretory提供了下列静态方法：

.. code:: csharp

    string GetCurrentDirectory ();
    void   SetCurrentDirectory (string path);
    DirectoryInfo CreateDirectory  (string path);
    DirectoryInfo GetParent        (string path);
    string        GetDirectoryRoot (string path);
    string[] GetLogicalDrives();
    // The following methods all return full paths:
    string[] GetFiles             (string path);
    string[] GetDirectories       (string path);
    string[] GetFileSystemEntries (string path);
    IEnumerable<string> EnumerateFiles             (string path);
    IEnumerable<string> EnumerateDirectories       (string path);
    IEnumerable<string> EnumerateFileSystemEntries (string path);

Enumerate\*与Get\*方法被重载同时接受searchPaatern（字符串）与searchOption（枚举）参数。如果我们指定了SearchOption.SearchAllSubDirecotries，则会执行递归的子目录搜索。\*FileSystemEntries方法组合了\*Files与\*Directories的结果。

下面的代码演示了如果目录不存在如何创建目录的例子：

.. code:: csharp

    if (!Directory.Exists (@"c:\temp"))
      Directory.CreateDirectory (@"c:\temp");

FileInfo与DirectoryInfo
~~~~~~~~~~~~~~~~~~~~~~~

File与Directory的静态方法对于执行单个的文件或是目录操作十分方便。如果我们希望调用一个方法序列，FileInfo与DirectoryInfo类提供了一个对象模式，使得这一工作更为简单。

FileInfo以实例形式提供了File静态方法中的大多数，同时还有其他的属性，例如Extension，Length，IsReadOnly以及用于返回DirectoryInfo对象的Directory。例如：

.. code:: csharp

    FileInfo fi = new FileInfo (@"c:\temp\FileInfo.txt");
    Console.WriteLine (fi.Exists);         // false
    using (TextWriter w = fi.CreateText())
      w.Write ("Some text");
    Console.WriteLine (fi.Exists);         // false (still)
    fi.Refresh();
    Console.WriteLine (fi.Exists);         // true
    Console.WriteLine (fi.Name);           // FileInfo.txt
    Console.WriteLine (fi.FullName);       // c:\temp\FileInfo.txt
    Console.WriteLine (fi.DirectoryName);  // c:\temp
    Console.WriteLine (fi.Directory.Name); // temp
    Console.WriteLine (fi.Extension);      // .txt
    Console.WriteLine (fi.Length);         // 9
    fi.Encrypt();
    fi.Attributes ^= FileAttributes.Hidden;   // (Toggle hidden flag)
    fi.IsReadOnly = true;
    Console.WriteLine (fi.Attributes);    // ReadOnly,Archive,Hidden,Encrypted
    Console.WriteLine (fi.CreationTime);
    fi.MoveTo (@"c:\temp\FileInfoX.txt");
    DirectoryInfo di = fi.Directory;
    Console.WriteLine (di.Name);             // temp
    Console.WriteLine (di.FullName);         // c:\temp
    Console.WriteLine (di.Parent.FullName);  // c:\
    di.CreateSubdirectory ("SubFolder");

下面的代码演示了如何使用DirectoryInfo来枚举文件与子目录：

.. code:: csharp

    DirectoryInfo di = new DirectoryInfo (@"e:\photos");
    foreach (FileInfo fi in di.GetFiles ("*.jpg"))
      Console.WriteLine (fi.Name);
    foreach (DirectoryInfo subDir in di.GetDirectories())
      Console.WriteLine (subDir.FullName);

Path
~~~~

静态Path类为处理路径与文件名定义了方法与域。假定下面的设置代码：

.. code:: csharp

    string dir  = @"c:\mydir";
    string file = "myfile.txt";
    string path = @"c:\mydir\myfile.txt";
    Directory.SetCurrentDirectory (@"k:\demo");

我们可以使用下面的表达式来演示Path的方法与域：

.. figure:: csharp_path.png
   :alt: csharp_path.png

   csharp\_path.png
Combine特别有用：他使得我们可以组合目录与文件名或是两个目录，而不是需要检测第一个目录名是否有结尾的斜线。

GetFullPath将相对于当前目录的路径转换为绝对路径。他接受类似于"..\\..\\file.txt"这样的值。

GetRandomFileName返回一个8.3字符的文件名，而不会实创建文件。GetTempFileName会使用一个在65000文件上重复的自增计数器来生成一个临时文件名，然后在本地临时目录中创建这个这个名字的空文件。

特殊目录
~~~~~~~~

Path与Directory中缺少一种定位例如My Documnts，Program Files，Application
Data这样的目录的方法。这是由System.Environment类中的GetFolderPath方法提供的：

.. code:: csharp

    string myDocPath = Environment.GetFolderPath
      (Environment.SpecialFolder.MyDocuments);

Environment.SpecialFolder是一个枚举，其中包含了Windows中的所有特殊目录：

.. figure:: csharp_specialfolder.png
   :alt: csharp_specialfolder.png

   csharp\_specialfolder.png
其中的一个特殊值就是ApplicationData：这是存储随用户跨网络移动的设置的地方（如果在网络域上允许了漫游配置）LocalApplicationData用于非漫游数据；CommonApplicationData为该计算机上的所有用户共享。比起使用Windows注册表，将程序数据写入这些目录被认为是更好的方式。在大多数情况下，更好的解决方法仍然是使用独立存储（我们会在本章的最后部分进行描述）。

下面的代码返回.NET框架的目录：

System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()

查询卷信息
~~~~~~~~~~

我们可以使用DriveInfo类查询计算机上的驱动器信息：

.. code:: csharp

    DriveInfo c = new DriveInfo ("C");       // Query the C: drive.
    long totalSize = c.TotalSize;            // Size in bytes.
    long freeBytes = c.TotalFreeSpace;       // Ignores disk quotas.
    long freeToMe  = c.AvailableFreeSpace;   // Takes quotas into account.
    foreach (DriveInfo d in DriveInfo.GetDrives())    // All defined drives.
    {
      Console.WriteLine (d.Name);             // C:\
      Console.WriteLine (d.DriveType);        // Fixed
      Console.WriteLine (d.RootDirectory);    // C:\
      if (d.IsReady)   // If the drive is not ready, the following two
                       // properties will throw exceptions:
      {
        Console.WriteLine (d.VolumeLabel);    // The Sea Drive
        Console.WriteLine (d.DriveFormat);    // NTFS
      }
    }

静态的GetDrives方法返回所有映射的文件，包括CD-ROM，存储卡以及网络连接。DriveType是一个枚举，其值如下：

Unknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram

捕获文件系统事件
~~~~~~~~~~~~~~~~

FileSystemWatcher类可以使得我们监视目录（子目录）的活动。FileSystemWatcher类具有当文件或是子目录被创建，修改，重命名，删除，以及他们的属性发生变化时可以触发的事件。这些事件被触发而无论执行引起该变化的用户或进程。如下面的示例：

.. code:: csharp

    static void Main() { Watch (@"c:\temp", "*.txt", true); }
    static void Watch (string path, string filter, bool includeSubDirs)
    {
      using (var watcher = new FileSystemWatcher (path, filter))
      {
        watcher.Created += FileCreatedChangedDeleted;
        watcher.Changed += FileCreatedChangedDeleted;
        watcher.Deleted += FileCreatedChangedDeleted;
        watcher.Renamed += FileRenamed;
        watcher.Error   += FileError;
        watcher.IncludeSubdirectories = includeSubDirs;
        watcher.EnableRaisingEvents = true;
        Console.WriteLine ("Listening for events - press <enter> to end");
        Console.ReadLine();
      }
      // Disposing the FileSystemWatcher stops further events from firing.
    }
    static void FileCreatedChangedDeleted (object o, FileSystemEventArgs e)
    {
      Console.WriteLine ("File {0} has been {1}", e.FullPath, e.ChangeType);
    }
    static void FileRenamed (object o, RenamedEventArgs e)
    {
      Console.WriteLine ("Renamed: {0}->{1}", e.OldFullPath, e.FullPath);
    }
    static void FileError (object o, ErrorEventArgs e)
    {
      Console.WriteLine ("Error: " + e.GetException().Message);
    }

Error事件并不会通知我们文件系统的错误；相反，他表明FileSystemWatcher的事件缓冲区溢出，因为他被Changed，Created，Deleted或是Renamed事件所填满。我们可以通过InternalBufferSize属性来修改缓冲区的尺寸。

IncludeSubdirectories会递归应用。所以如果我们在C:\\上创建一个FileSystemWatcher并且IncludeSubdirectories为true，从而当磁盘上任意位置的文件或是目录发生变化时，其事件都会被触发。

内存映射文件（Memory-Mapped Files）
-----------------------------------

内存映射文件是由框架4.0新引入的。他们提供了两个关键特性：

-  对于文件数据的高效随机访问
-  在相同计算不同进程之间共享内存的能力

内存映射文件的类型位于Systme.IO.MemoryMappedFiles名字空间中。在内部，他们是通过封装用于内存映射文件的Win32
API来工作的。

内存映射文件与随机文件IO
~~~~~~~~~~~~~~~~~~~~~~~~

尽管普通的FileStream允许随机文件IO（通过设置流的Position属性），他却为顺序IO进行了优化。基本原则如下：

-  对于顺序IO，FileStream要10倍于内存映射文件
-  对于随机IO，内存映射文件要10倍于FileStream

改变FileStream的Position属性需要花费几毫秒的时间－在循环中会进行累加。FileStream也不适用于多线程访问－因为在读取或是写入时其位置会发生变化。

要创建内存映射文件，我们可以：

#. 像通常那样获取获取FileStream。
#. 传递文件流，实例化MemoryMappedFile。
#. 在内存映射文件对象上调用CreateViewAccessor。

最后一步会为我们返回一个MemoryMappedViewAccessor对象，他提供了随机读写简单类型，结构，与数组的方法。

下面的代码创建了一个一百万字节的文件，然后使用内存映射API进行读取并在位500000处写入一个字节：

.. code:: csharp

    File.WriteAllBytes ("long.bin", new byte [1000000]);
    using (MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile ("long.bin"))
    using (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor())
    {
      accessor.Write (500000, (byte) 77);
      Console.WriteLine (accessor.ReadByte (500000));   // 77
    }

我们也可以在调用CreateFromFile时指定映射名与容量。指定一个非空的映射名可以使得内存块为其他的进程所共享；指定容量会自动将文件扩展到该容量值。下面的代码创建了一个1000字节的文件：

.. code:: csharp

    using (var mmf = MemoryMappedFile.CreateFromFile
                     ("long.bin", FileMode.Create, null, 1000))
      ...

内存映射文件与共享内存
~~~~~~~~~~~~~~~~~~~~~~

我们可以将内存映射文件用作相同计算机上进程之间共享内存的一种方法。一个进程通过调用MemoryMappedFile.CreateNew来创建一个共享的内存块，而其他的进程通过相同的名字来调用MemoryMappedFile.OpenExisting方法来订阅相同的内存块。尽管他仍然作为内存映射文件来引用，但是他完全存在于内存之中，并不占用磁盘。

下面的代码创建了一个500字节的共享内存映射文件，并且在位置0处写入整数12345：

.. code:: csharp

    using (MemoryMappedFile mmFile = MemoryMappedFile.CreateNew ("Demo", 500))
    using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())
    {
      accessor.Write (0, 12345);
      Console.ReadLine();   // Keep shared memory alive until user hits Enter.
    }

而下面的代码打开相同的内存映射文件并且读取该整数：

.. code:: csharp

    // This can run in a separate EXE:
    using (MemoryMappedFile mmFile = MemoryMappedFile.OpenExisting ("Demo"))
    using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())
      Console.WriteLine (accessor.ReadInt32 (0));   // 12345

使用视力访问器
~~~~~~~~~~~~~~

在MemoryMappedFile上调用CreateViewAccessor方法会为我们返回一个可以在随机位置读写值的视力访问器。

Read\*/Write\*方法接受数值类型，bool，char，以及包含值类型元素或是域的数组与结构。引用类型以及包含引用类型的数组与结构是被禁止的，因为他们不能映射到未托管的内存中。如果我们要写入一个字符串，我们必须将其编码为一个字节数组：

.. code:: csharp

    byte[] data = Encoding.UTF8.GetBytes ("This is a test");
    accessor.Write (0, data.Length);
    accessor.WriteArray (4, data, 0, data.Length);

注意，我们首先写入长度。这意味着我们稍后要读取多个字节：

.. code:: csharp

    byte[] data = new byte [accessor.ReadInt32 (0)];
    accessor.ReadArray (4, data, 0, data.Length);
    Console.WriteLine (Encoding.UTF8.GetString (data));   // This is a test

下面是读写结构的示例：

.. code:: csharp

    struct Data { public int X, Y; }
    ...
    var data = new Data { X = 123, Y = 456 };
    accessor.Write (0, ref data);
    accessor.Read (0, out data);
    Console.WriteLine (data.X + " " + data.Y);   // 123 456

我们也可以通过指针来直接访问底层非托管内存。如下面的示例所示：

.. code:: csharp

    unsafe
    {
      byte* pointer = null;
      accessor.SafeMemoryMappedViewHandle.AcquirePointer (ref pointer);
      int* intPointer = (int*) pointer;
      Console.WriteLine (*intPointer);               // 123
    }

指针在处理大结构时很有优势：可以使得我们直接处理原始数据而不是使用Read/Write来在托管与非托管内存之间拷贝数据。我们会在第25章中进一步探讨。

压缩
----

两个通用目的的压缩流是在System.IO.Compression名字空间中提供的：DeflateStream与GZipStream。两者都使用类似于ZIP格式的流行压缩算法。他们之间的不同之处在于GZipStream会在起始与结束处添加额外的协议，包括用于错误检测的CRC。GZipStream同时遵循其他软件可以识别的标准。

两个流都允许读取与写入，但有下面的限制：

-  当压缩时我们总是写入流
-  当解压时我们总是读取流

DeflateStream与GZipStream是装饰器；他们压缩或是解压我们在构建时所提供的其他流中的数据。在下面的示例中，我们压缩并解压一系列字节，使用FileStream作为后端存储：

.. code:: csharp

    using (Stream s = File.Create ("compressed.bin"))
    using (Stream ds = new DeflateStream (s, CompressionMode.Compress))
      for (byte i = 0; i < 100; i++)
        ds.WriteByte (i);
    using (Stream s = File.OpenRead ("compressed.bin"))
    using (Stream ds = new DeflateStream (s, CompressionMode.Decompress))
      for (byte i = 0; i < 100; i++)
        Console.WriteLine (ds.ReadByte());     // Writes 0 to 99

即使是两个算法中较小的一个，压缩后的文件也有241字节长：是原始数据的2倍多。压缩对于“密集”的非重复的二进制文件处理效果较差。他对于大多数的文本文件处理效果都较好。在下面的示例中，我们压缩并解压一个在一段文章中随机选取的1000个单词组成的文本流。这个示例同时演示了链接后端存储流，装饰器流以及适配器：

.. code:: csharp

    string[] words = "The quick brown fox jumps over the lazy dog".Split();
    Random rand = new Random();
    using (Stream s = File.Create ("compressed.bin"))
    using (Stream ds = new DeflateStream (s, CompressionMode.Compress))
    using (TextWriter w = new StreamWriter (ds))
      for (int i = 0; i < 1000; i++)
        w.Write (words [rand.Next (words.Length)] + " ");
    Console.WriteLine (new FileInfo ("compressed.bin").Length);      // 1073
    using (Stream s = File.OpenRead ("compressed.bin"))
    using (Stream ds = new DeflateStream (s, CompressionMode.Decompress))
    using (TextReader r = new StreamReader (ds))
      Console.Write (r.ReadToEnd());                 // Output below:
    lazy lazy the fox the quick The brown fox jumps over fox over fox The
    brown brown brown over brown quick fox brown dog dog lazy fox dog brown
    over fox jumps lazy lazy quick The jumps fox jumps The over jumps dog...

在这个例子中，DeflateStream高效的压缩为1073字节－仅比每一个单词多一个字节。

**在内存中压缩**

有时我们需要在全部在内存中进行压缩。下面的代码演示了如何使用MemoryStream来实现：

.. code:: csharp

    byte[] data = new byte[1000];          // We can expect a good compression
                                           // ratio from an empty array!
    var ms = new MemoryStream();
    using (Stream ds = new DeflateStream (ms, CompressionMode.Compress))
      ds.Write (data, 0, data.Length);
    byte[] compressed = ms.ToArray();
    Console.WriteLine (compressed.Length);       // 113
    // Decompress back to the data array:
    ms = new MemoryStream (compressed);
    using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))
      for (int i = 0; i < 1000; i += ds.Read (data, i, 1000 - i));

DeflatStream周围的using语句以规范的方式关闭，在此过程中输出未写入的缓冲区。这同时会关闭其所封装的MemoryStream－意味着我们必须调用ToArray来解出数据。

下面是避免关闭MemoryStream的另一种方法：

.. code:: csharp

    byte[] data = new byte[1000];
    MemoryStream ms = new MemoryStream();
    using (Stream ds = new DeflateStream (ms, CompressionMode.Compress, true))
      ds.Write (data, 0, data.Length);
    Console.WriteLine (ms.Length);             // 113
    ms.Position = 0;
    using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))
      for (int i = 0; i < 1000; i += ds.Read (data, i, 1000 - i));

发送给DefaltStream构造器的额外标记通知他不要遵循在销毁时销毁底层数据流的通常协议。换句话说，MemoryStram保持打开，使得我们可以将其定位到零并重新读取。

隔离存储
--------

每一个.NET程序都可以访问对于程序唯一的特殊操作文件系统，名为隔离存储。隔离存储十分有用与重要，原因如下：

-  

Chapter 15. Networking
======================

框架在System.Net.\*名字空间中提供了大量的类用于通过标准网络协议进行通信，例如HTTP，TCP/IP与FTP。下面是一些关键组件的总结：

-  WebClient类用于通过HTTP或是FTP实现简单的上传下载操作。
-  WebRequest与WebResponse类用于在HTTP或是FTP操作宫廷户端提供更多的控制。
-  HttpListener用于编写HTTP服务器。
-  SmtpClient用于构建并通过SMTP发送邮件消息。
-  Dns用于在域名与地址之间进行转换。
-  TcpClient，UdpClient，TcpListener与Socket类用于对传输层与网络层的直接访问。

框架主要支持基于网络的协议，尽管并没有将功能仅限制在网络；如TCP/IP协议同时统治着局域网领域。

本节中所描述的类型大部分位于System.Net与System.Net.Socket名字空间中；然而，许多示例同时使用System.IO中的类型。

网络体系结构
------------

图15-1显示了.NET网络类型及其所在的通信层。大部分网络类型位于传输层或是应用层。传输层为发送与接收字节（TCP与UDP）定义了基本协议；应用层为特定了应用定义了高层协议，例如接收web页面（HTTP），传输文件（FTP），发送邮件（SMTP），以及在域名以及IP地址之间进行转换（DNS）。

.. figure:: csharp_15_1.png
   :alt: csharp_15_1.png

   csharp\_15\_1.png
通常在应用层编程最为方便；然而，由于某些原因我们也许希望直接在传输层进行工作。如果我们需要一个在框架中并没有提供的应用协议就是其中一个原因，例如用于接收邮件的POP3。另一个原因也许是我们希望为特定的应用发明自定义的协议，例如P2P客户端。

在所有的应用协议中，HTTP是一个特殊的协议，因为其应用已经扩展到通用目的通信。其基本操作模式－“为我提供这个URL的web页面”－已经非常适合“为我提供使用这些参数调用该方法的返回值”。HTTP具有一个在多层业务应用以及面向服务的体系结构中非常有用的特性集合，例如用于验证与加密的协议，消息分块，扩展头与Cookie，以及具有共享一个端口与IP地址的多个服务器程序的能力等。正是由于这些原因，HTTP在框架中得到很好的支持，正如本章所描述的，通过WCF，Web
Services以及ASP.NET在较高层次上进行双向支持。

框架对用于发送与接收文件的FTP协议提供了客户端支持。服务器端支持以IIS或是基于Unix的服务器软件进行提供。

正如前面的讨论所清楚表明的，网络是一个很有挑战的领域。表格15-1列出了网络TLA（三字母缩写）。

.. figure:: csharp_table_15_1.png
   :alt: csharp_table_15_1.png

   csharp\_table\_15\_1.png
地址与端口
----------

为了使得通信能够工作，计算机或是设备需要一个地址。网络使用两种地址系统：

IPv4

当前占统治地位的地址系统；IPv4地址是32位宽。当格式化为字符串时，IPv4地址被书写为四个点分隔的十进制数（例如：101.102.103.104）。地址可以在世界中是唯一的，或者是在特定的子网中是唯一的。

IPv6

更新的128位地址系统。地址以冒号分隔的16进制形式格式化为字符串。.NET框架要求我们为地址添加一个方括号。

System.Net名字空间中的IPAddress类表示任意协议中的地址。他有一个接受字节数组的构造函数，以及一个接受已正确格式化的字符串的静态Parse方法：

.. code:: csharp

    IPAddress a1 = new IPAddress (new byte[] { 101, 102, 103, 104 });
    IPAddress a2 = IPAddress.Parse ("101.102.103.104");
    Console.WriteLine (a1.Equals (a2));                     // True
    Console.WriteLine (a1.AddressFamily);                   // InterNetwork
    IPAddress a3 = IPAddress.Parse
      ("[3EA0:FFFF:198A:E4A3:4FF2:54fA:41BC:8D31]");
    Console.WriteLine (a3.AddressFamily);   // InterNetworkV6

TCP与UDP协议将每一个IP地址分散到65535个端口上，从而允许一个计算机在一个地址上运行多个应用，每一个应用有其自己的端口。许多应用具有标准的端口约定；例如，HTTP使用端口80；SMTP使用端口25。

IP地址与端口组合在.NET框架中是通过IPEndPoint类来表示的：

.. code:: csharp

    IPAddress a = IPAddress.Parse ("101.102.103.104");
    IPEndPoint ep = new IPEndPoint (a, 222);           // Port 222
    Console.WriteLine (ep.ToString());                 // 101.102.103.104:222

URIs
----

URI是一个描述位于Internet或是LAN上资源的特殊格式化字符串，例如web页面，或是Email地址。URI的确切格式是由Internet
Engineering Task Force来定义的。

一个URI可以分解为多个元素序列－通常分为scheme，authority与path。System名字空间的中的Uri类执行这种分解任务，并获取每个元素的属性。如图15-2所示。

.. figure:: csharp_15_2.png
   :alt: csharp_15_2.png

   csharp\_15\_2.png
我们可以通过将下列参数中的一个传递给其构造函数来生成一个Uri对象：

-  URI字符串，例如http://www.ebay.com
   或是file://janespc/sharedpics/dolphin.jpg
-  到我们硬盘文件的绝对路径，例如：c:\\myfiles\\data.xmls
-  LAN上的UNC路径，例如\\\\janespc\\sharedpics\\dolphin.jpg

Chapter 16. Serialization
=========================

本章介绍序列化与反序列化，一种对象可以表示为普通文件或是二进制格式的机制。除非特别说明，本章中的类型全部位于下列名字空间中：

-  System.Runtime.Serialization
-  System.Xml.Serialization

序列化概念
----------

序列化是将内存中的对象或是对象图（彼此引用的对象集合）填充到二进制流或是XML节点中，从而可以被存储或是传输。反序列化执行相反的操作，将一个数据流重新构建为一个内存对象或是对象图。

序列化与反序列化通常用于：

-  跨越网络或是程序边界传输对象
-  在文件或是数据库中存储对象表示

另一种很少使用的用法是进行深拷贝对象。数据约定与XML序列化引擎也可以用作载入或是保存已知结构的XML文件的通用工具。

.NET框架同时由希望序列化与反序列化的客户端角度以及希望在类型如何进行序列化上进行控制的角度支持序列化与反序列化。

序列化引擎
~~~~~~~~~~

在.NET框架中有四种序列化机制：

-  数据约定序列化器
-  二进制序列化器
-  （基于属性）XML序列化器（XmlSerializer）
-  IXmlSerializable接口

在这些序列化机制中，前三个是为我们完成大部分序列化工作的序列化引擎。最后一个我们使用XmlReader与XmlWriter自己进行序列化工作。IXmlSerializable可以与数据约定序列化器或是XmlSerializer配合使用来处理更为复杂的XML序列化任务。

表16-1比较了每一种序列化引擎。

.. figure:: csharp_table_16_1.png
   :alt: csharp_table_16_1.png

   csharp\_table\_16\_1.png
IXmlSerializable假定我们已使用XmlReader与XmlWriter进行编码。XML序列化引擎要求我们重用相同的XmlSerializer对象以实现良好的性能。

**为什么存在三个引擎？**

存在三个引擎部分由于历史原因造成的。框架开始时要序列化上实现两个不同的目标：

-  序列化带有类型与引用的.NET对象图
-  交互操作XML与SOAP消息标准

第一个目标是由远程需求所导致的；第二个则是由Web
Services所导致的。编写一个序列化引擎来处理两种任务的工作是非常繁琐的，所以Microsoft编写了两个引擎：二进制序列化器与XML序列化器。

当后来作为框架3.0的组成部分的WCF被编写时，其部分目标就是要统一远程与Web
Services。这需要一个新的序列化引擎－所以诞生了数据约定序列化器。数据约定序列化器统一了以前与消息相关的两个引擎的特点。然而在这种应用环境之外，以前的两个引擎依然重要。

**数据约定序列化器**

数据约定序列化器是最新的，且是三个序列化引擎中最强大的并且为WCF所使用。该序列化器特别在两个应用场景中特别强大：

-  当通过标准兼容的消息协议交换信息时
-  当我们需要良好的版本容错性并且保留对象引用时

数据约定序列化器支持数据约定模式，从而有助于我们希望序列化的类型的底层细节与序列化数据的结构相分离。这提供了良好的版本容错，意味着我们可以反序列化由类型的以前或是稍后版本序列化的数据。我们甚至可以反序列化已经重命名或是移动到其他不同程序集中的类型。

数据约定序列化器可以处理大多数对象图，尽管比起二进制序列化器他需要更多的辅助。他也可以用作读取/写入XML文件的通用工具，如果我们不介意XML是如何组织的。（如果我们需要以属性存储数据或是处理随机顺序表示的XML元素，我们不能使用数据约定序列化器。）

**二进制序列化器**

二进制序列化器易于使用，高度自动化并且通过.NET框架进行良好的支持。远程使用二进制序列化器－包括相同进程内两个程序域之间通信的情况。

二进制序列化器是高度自动化的：经常的情况是，使得一个复杂的类型成为可完全序列化所需要的仅是一个属性。当需要完全类型精度时，二进制序列化器要比数据约定序列化器快速得多。然而，他将类型的内部结构与序列化数据的格式关联在一起，从而导致了糟糕的版本容错。同时二进制序列化器也不是被设计用来生成XML的，尽管他为基于SOAP的消息提供了一个格式化器，从而提供了与简单类型的有限互操作。

**XmlSerializer**

XML序列化器只能生成XML，而且在保存与恢复复杂对象图方面，他不如其他的引擎强大（他不能恢复共享的对象引用）。然而，在处理任意的XML结构时，他是三个序列化器中最为灵活的。例如，我们可以选择属性是否被序列化到元素或属性以及集合外层元素的处理。同时XML引擎也提供了优秀的版本容错。

XmlSerializer为ASMX Web Services所使用。

**IXmlSerializable**

实现IXmlSerializable意味着我们自己使用XmlReader与XmlWriter处理序列化。IXmlSerializable接口可以同时为XmlSerializer与数据约定序列化器所识别，所以他可以被用来处理更为复杂的类型。（同时他也可以直接为WCF与ASMX
Web Services所用）我们会在第11章详细描述XmlReader与XmlWriter。

格式化器
~~~~~~~~

数据约定与二进制序列化器的输出是通过一个插件化的格式化器来生成的。格式化器的角色与两种序列化引擎相同，尽管他们使用完全不同的类来完成相应的工作。

格式化器会调整最终的表示适应特定的媒介或是序列化环境。通常，我们可以在XML与二进制格式化器之间进行选择。XML格式化器被设计用于XML读取器/写入器，文本文件/流或是SOAP消息包。二进制序列化器被设计用于任意的字节流的环境－通常是文件/流或是消息包。二进制输出通常要小于XML。

理论上，引擎与其格式化器相分离。实践中，每一种引擎的设计都会受到一种格式化器类型的激励。

数据约定序列化器
----------------

下面是使用数据约定序列化器的基本步骤：

#. 确定是否使用DataContractSerializer或是NetDataContractSerializer。
#. 分别使用[DataContract]与[DataMember]属性来修饰我们希望序列化的类型与成员。
#. 实例化序列化器并调用WriteObject或ReadObject。

如果我们选择DataContractSerializer，我们将会同时需要注册已知类型（同时可以被序列化的子类型），并且要确定是否要保留对象引用。

同时我们也许会需要执行某些特殊的动作来确保集合被正确的序列化。

DataContractSerializer Versus NetDataContractSerializer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

有两种数据约定序列化器：

-  DataContractSerializer：.NET类型与数据约定类型公耦合
-  NetDataContractSerializer：.NET类型与数据约定类型松耦合

DataContractSerializer可以生成可互操作的标准XML，例如：

.. code:: xml

    <Person xmlns="...">
      ...
    </Person>

然而，这要求我们预先是显式注册可序列化的子类型，从而可以将如Person这样的数据约定正确的映射到.NET类型。NetDataContractSerializer不需要这些辅助，因为其输出其序列化的完全类型与类型的集合名，而不同于二进制序列化引擎：

.. code:: xml

    <Person z:Type="SerialTest.Person" z:Assembly=
      "SerialTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
      ...
    </Person>

然而这样的输出是专有的。为了进行反序列化，他同时依赖于特定名字空间中特定.NET类型以及程序集的存在。

如果我们正在将一个对象图存储到一个黑盒中，依据哪些优点对于我们更为重要可以选择任一序列化器。如果我们正通过WCF进行通信，或是读写XML文件，我们最可能需要的是DataContractSerializer。

两个序列化器之间另一个区别在于NetDataContractSerializer总是保持引用关系；DataContractSerializer只在需要时进行。

我们会在稍后的内容中深入这些主题。

使用序列化器
~~~~~~~~~~~~

在选择序列化器之间，下一步就是将属性关联到我们要序列化的类型与成员上。即：

-  为每一种类型添加[DataContract]属性
-  为我们希望包含的每一个成员添加[DataMember]属性

如下面所示：

.. code:: csharp

    namespace SerialTest
    {
      [DataContract] public class Person
      {
        [DataMember] public string Name;
        [DataMember] public int Age;
      }
    }

这些属性足够通过数据约定引擎使得类型隐式可序列化。

然后我们可以通过实例化DataContractSerializer或NetDataContractSerialier并调用WriteObject或ReadObject来序列化或反序列化实例：

.. code:: csharp

    Person p = new Person { Name = "Stacey", Age = 30 };
    var ds = new DataContractSerializer (typeof (Person));
    using (Stream s = File.Create ("person.xml"))
      ds.WriteObject (s, p);                            // Serialize
    Person p2;
    using (Stream s = File.OpenRead ("person.xml"))
      p2 = (Person) ds.ReadObject (s);                  // Deserialize
    Console.WriteLine (p2.Name + " " + p2.Age);         // Stacey 30

DataContractSerializer构造函数需要根对象类型（我们正显式序列化的对象类型）。相对应的，NetDataContractSerializer则不需要：

.. code:: csharp

    var ns = new NetDataContractSerializer();
    // NetDataContractSerializer is otherwise the same to use
    // as DataContractSerializer.
    ...

两种序列化器类型默认使用XML格式化器。通过XmlWriter，我们可以要求输出进行缩进从而更易于阅读：

.. code:: csharp

    Person p = new Person { Name = "Stacey", Age = 30 };
    var ds = new DataContractSerializer (typeof (Person));
    XmlWriterSettings settings = new XmlWriterSettings() { Indent = true };
    using (XmlWriter w = XmlWriter.Create ("person.xml", settings))
      ds.WriteObject (w, p);
    System.Diagnostics.Process.Start ("person.xml");

输出结果如下：

.. code:: csharp

    <Person xmlns="http://schemas.datacontract.org/2004/07/SerialTest"
            xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <Age>30</Age>
      <Name>Stacey</Name>
    </Person>

XML元素名反映了数据约定名，默认情况下是.NET类型名。我们可以将其覆盖并显示指定数据约定名，如下所示：

.. code:: csharp

    [DataContract (Name="Candidate")]
    public class Person { ... }

XML名字空间反映了数据约定名字空间，默认情况下为http://schemas.datacontract.org/2004/07/
加上.NET类型名字空间。我们也可以使用相同的方式进行覆盖：

.. code:: csharp

    [DataContract (Namespace="http://oreilly.com/nutshell")]
    public class Person { ... }

我们可以覆盖数据成员的名字：

.. code:: csharp

    [DataContract (Name="Candidate", Namespace="http://oreilly.com/nutshell")]
    public class Person
    {
      [DataMember (Name="FirstName")]  public string Name;
      [DataMember (Name="ClaimedAge")] public int Age;
    }

输出结果如下：

.. code:: xml

    <?xml version="1.0" encoding="utf-8"?>
    <Candidate xmlns="http://oreilly.com/nutshell"
               xmlns:i="http://www.w3.org/2001/XMLSchema-instance" >
      <ClaimedAge>30</ClaimedAge>
      <FirstName>Stacey</FirstName>
    </Candidate>

[DataMember]同时支持域与属性－public与private。域与属性的数据类型可以是下列类型之一：

-  基本数据类型
-  DataTime，TimeSpan，Guid，Uri或Enum值
-  上述值的空版本
-  byte[]
-  使用DataContract修饰的任意已知类型
-  任意IEnumerable类型
-  具有[Serializable]属性或是实现ISerializable的任意类型
-  实现IXmlSerializable的任意类型

**指定二进制格式化器**

我们可以通过DataContractSerialier或NetDataContractSerializer使用二进制格式化器：

.. code:: csharp

    Person p = new Person { Name = "Stacey", Age = 30 };
    var ds = new DataContractSerializer (typeof (Person));
    var s = new MemoryStream();
    using (XmlDictionaryWriter w = XmlDictionaryWriter.CreateBinaryWriter (s))
      ds.WriteObject (w, p);
     
    var s2 = new MemoryStream (s.ToArray());
    Person p2;
    using (XmlDictionaryReader r = XmlDictionaryReader.CreateBinaryReader (s2,
                                   XmlDictionaryReaderQuotas.Max))
      p2 = (Person) ds.ReadObject (r);

其输出要小于XML格式化器的输出，而如果我们的类型包含大数组还会更小。

序列化子类
~~~~~~~~~~

我们并不需要做某些特殊的事情即可通过NetDataContractSerializer来处理子类的序列化。唯一的要求是子类具有DataContract属性。序列化器将会输出其序列化的实际类型的全名，如下所示：

.. code:: xml

    <Person ... z:Type="SerialTest.Person" z:Assembly=
      "SerialTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">

然而，DataContractSerializer必须了解其要序列化或反序列化的所有子类型的信息。为了演示，考虑如下的子类Person：

.. code:: csharp

    [DataContract] public class Person
    {
      [DataMember] public string Name;
      [DataMember] public int Age;
    }
    [DataContract] public class Student : Person { }
    [DataContract] public class Teacher : Person { }

然后编写一个方法来拷贝Person：

.. code:: csharp

    static Person DeepClone (Person p)
    {
      var ds = new DataContractSerializer (typeof (Person));
      MemoryStream stream = new MemoryStream();
      ds.WriteObject (stream, p);
      stream.Position = 0;
      return (Person) ds.ReadObject (stream);
    }

我们可以使用下面的代码：

.. code:: csharp

    Person  person  = new Person  { Name = "Stacey", Age = 30 };
    Student student = new Student { Name = "Stacey", Age = 30 };
    Teacher teacher = new Teacher { Name = "Stacey", Age = 30 };
    Person  p2 =           DeepClone (person);     // OK
    Student s2 = (Student) DeepClone (student);    // SerializationException
    Teacher t2 = (Teacher) DeepClone (teacher);    // SerializationException

如果使用Person调用则DeepClone可以正常工作，但是使用Student或Teacher调用则会抛出异常，因为反序列化器并不知道Student或Teacher应解析到哪种.NET类型。这也有助于安全，因为他可以防止未期望类型的反序列化。

解决方案就是指定所有允许或已知的子类型。我们可以在构造DataConstractSerializer时指定：

.. code:: csharp

    var ds = new DataContractSerializer (typeof (Person),
      new Type[] { typeof (Student), typeof (Teacher) } );

或者通过KnownType属性在本类型本身内指定：

.. code:: csharp

    [DataContract, KnownType (typeof (Student)), KnownType (typeof (Teacher))]
    public class Person
    ...

下面是序列化的Student的样子：

.. code:: xml

    <Person xmlns="..."
            xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
            i:type="Student" >
      ...
    <Person>

因为我们指定Person作为根类型，所以根元素具有相同的名字。实际的子类型在type属性进行单独描述。

对象引用
~~~~~~~~

对其他对象的引用也可以被序列化。考虑下面的类：

.. code:: csharp

    [DataContract] public class Person
    {
      [DataMember] public string Name;
      [DataMember] public int Age;
      [DataMember] public Address HomeAddress;
    }
    [DataContract] public class Address
    {
      [DataMember] public string Street, Postcode;
    }

下面是使用DataContractSerializer将其序列化XML后的结果：

.. code:: csharp

    <Person...>
      <Age>...</Age>
      <HomeAddress>
        <Street>...</Street>
        <Postcode>...</Postcode>
      </HomeAddress>
      <Name>...</Name>
    </Person>

如果我们正在使用DataContractSerializer，当派生Address时同样适用该规则。所以如果我们定义一个USAddress，例如：

.. code:: csharp

    [DataContract]
    public class USAddress : Address { }

并将其实例赋值给Person：

.. code:: csharp

    Person p = new Person { Name = "John", Age = 30 };
    p.HomeAddress = new USAddress { Street="Fawcett St", Postcode="02138" };

p不会被序列化。解决方法是在Address上应用KnownType属性，如下所示：

.. code:: csharp

    [DataContract, KnownType (typeof (USAddress))]
    public class Address
    {
      [DataMember] public string Street, Postcode;
    }

或是在构造时告诉DataContractSerializer关于USAddress的信息：

.. code:: csharp

    var ds = new DataContractSerializer (typeof (Person),
      new Type[] { typeof (USAddress) } );

**保留对象引用**

NetDataContractSerializer总是保持引用平等性。DataContractSerializer并不会这样，除非我们特别要求。

这就意味着如果相同的对象在两个不同的位置被引用，DataContractSerializer会相应的输出两次。所以如果我们修改前面的示例使得Person同时存储工作地址：

.. code:: csharp

    [DataContract] public class Person
    {
      ...
      [DataMember] public Address HomeAddress, WorkAddress;
    }

然后序列化实例，如下所示：

.. code:: csharp

    Person p = new Person { Name = "Stacey", Age = 30 };
    p.HomeAddress = new Address { Street = "Odo St", Postcode = "6020" };
    p.WorkAddress = p.HomeAddress;

我们会看到在XML中看到两次相同的地址信息：

.. code:: xml

    ...
    <HomeAddress>
      <Postcode>6020</Postcode>
      <Street>Odo St</Street>
    </HomeAddress>
    ...
    <WorkAddress>
      <Postcode>6020</Postcode>
      <Street>Odo St</Street>
    </WorkAddress>

当其稍后被反序列化时，WordAddress与HomeAddress将会是不同的对象。这个系统的优点就在于他可以使得XML简单且符合标准，而其缺点则是包含了更大的XML，引用完整性的丢失以及无法处理循环引用。

我们可以通过在构造DataContractSerializer时将preserveObjectReferences指定为true来要求引用完整性。

.. code:: csharp

    var ds = new DataContractSerializer (typeof (Person),
                                         null, 1000, false, true, null);

当preserveObjectReferences为true时第三个参数是必须的：他指示了序列化器应跟踪的对象引用的最大数目。如果超出这个值序列化器则会抛出异常。

下面是具有相同的家庭与工作地址的Person的XML输出结果：

.. code:: xml

    <Person xmlns="http://schemas.datacontract.org/2004/07/SerialTest"
            xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:z="http://schemas.microsoft.com/2003/10/Serialization/"
            z:Id="1">
      <Age>30</Age>
      <HomeAddress z:Id="2">
        <Postcode z:Id="3">6020</Postcode>
        <Street z:Id="4">Odo St</Street>
      </HomeAddress>
      <Name z:Id="5">Stacey</Name>
      <WorkAddress z:Ref="2" i:nil="true" />
    </Person>

其代价则是互操作性的缺失。

版本容错
~~~~~~~~

我们可以添加与删除数据成员而不破坏向前或向后兼容性。默认情况下，数据约定反序列化器会执行下列操作：

-  忽略类型中没有[DataMember]的数据
-  如果序列化流中有[DataMember]丢失而不抱怨

我们不必略过未识别的数据，我们可以指示反序列化器将未识别的数据成员存储到一个黑盒中，然后在类型稍后被重新序列化时进行重放。这可以使得我们正确处理由类型的后续版本序列化的数据。为了实现这一特性，要实现IExtensibleDataObject。这个接口意味着IBlackBoxProvider。他要求我们实现一个属性来获取/设置黑盒：

.. code:: csharp

    [DataContract] public class Person : IExtensibleDataObject{
      [DataMember] public string Name;
      [DataMember] public int Age;
      ExtensionDataObject IExtensibleDataObject.ExtensionData { get; set; }
    }

**需要的成员**

如果某个成员对于类型来说是必须的，我们可以使用IsRequired来要求其必须存在：

[DataMember (IsRequired=true)] public int ID;

如果该成员不存在，则会在反序列化时抛出异常。

成员顺序
~~~~~~~~

数据约定序列化器对数据成员的顺序十分挑剔。事实上，反序列化器会忽略任何被认为超出序列的成员。

当序列化时成员以下列顺序进行输出：

#. 基类到子类
#. 低Order到高Order（对于设置了Order的数据成员）
#. 字母顺序（使用普通的字符串比较）

所以在前面的示例中，Age位于Name的前面。在下面的示例中，Name在Age的前面：

.. code:: csharp

    [DataContract] public class Person
    {
      [DataMember (Order=0)] public string Name;
      [DataMember (Order=1)] public int Age;
    }

如果Person具有基类，则基类的数据成员会被首先序列化。

指定顺序的主要原因是要遵守特定的XML
Schema。XML元素顺序等同于数据成员顺序。

如果我们不需要与其他内容进行互操作，则最简单的方法就是不指定成员Order而完全依赖于字母顺序。当成员被添加或是删除时序列化与反序列之间就不会出现矛盾。唯一的例外就是当我们在基类与子类之间移动成员时。

Null与Empty值
~~~~~~~~~~~~~

有两种方法处理数据成员的值为null或空：

#. 显示的输出null或是空值（默认情况）
#. 忽略序列化输出的数据成员

在XML中，显示的null值的样子如下：

.. code:: xml

    <Person xmlns="..."
               xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <Name i:nil="true" />
    </Person>

输出null或是空成员会浪费空间，特别是在大量的域或属性通常留空的类型上。最重要的是，我们也许遵循希望实质元素而不是nil值的XML
Schema。

我们可以指示序列化器不要输出null或空值的数据成员，如下所示：

.. code:: csharp

    [DataContract] public class Person
    {
      [DataMember (EmitDefaultValue=false)] public string Name;
      [DataMember (EmitDefaultValue=false)] public int Age;
    }

如果Name值为null则其会被忽略；如果Age值则其会被忽略。

二进制序列化器
--------------

二进制序列化引擎是由远程所隐式使用的。他可以用于执行如将对象保存到磁盘以及由磁盘恢复对象这样的任务。二进制序列化引擎是高度自动化并且可以使用最小的干涉处理复杂的对象图。

有两种方法可以使得类型支持二进制序列化。第一种是基于属性的；第二种是实现ISerializable。添加属性更为简单；实现ISerializable更为灵活。我们通常实现ISerializable来：

-  动态控制被序列化的内容
-  使得我们的可序列化类型可以为其他合作者友好的继承

**开始**

类型可以通过一个属性变为可序列化：

.. code:: csharp

    [Serializable] public sealed class Person
    {
      public string Name;
      public int Age;
    }

[Serializable]属性指示序列化器在类型中包含所有的域。这会同时包含private与public域（但是不包含属性）。每一个域本身必须是可序列化的；否则会抛出异常。基础.NET类型，例如string与int都支持序列化。

要序列化一个Person实例，我们实例化一个格式化器并且调用Serialize。对于二进制引擎有两种可用的格式化器：

-  BinaryFormatter：这是两者中更为高效的，可以在更少的时间内生成更小的输出。其名字空间是System.Runtime.Serialization.Formatter.Binary。
-  SoapFormatter：该格式支持远程所用的SOAP风格消息。其名字空间是System.Runtime.Serialization.Formatters.Soap。

BinaryFormatter包含在mscorlib中；SoapFormatter包含在System.Runtime.Serialization.Formatters.Soap.dll中。

两种格式化器的使用完全相同。下面的代码使用一个BinaryFormatter序列化Person：

.. code:: csharp

    Person p = new Person() { Name = "George", Age = 25 };
    IFormatter formatter = new BinaryFormatter();
    using (FileStream s = File.Create ("serialized.bin"))
      formatter.Serialize (s, p);

重新构造Person对象所需要的所有数据被输出到文件serialized.bin中。Deserialize方法重新恢复对象：

.. code:: csharp

    using (FileStream s = File.OpenRead ("serialized.bin"))
    {
      Person p2 = (Person) formatter.Deserialize (s);
      Console.WriteLine (p2.Name + " " + p.Age);     // George 25
    }

序列化的数据包含完全的类型与程序集信息，所以如果我们尝试转换反序列化的结果与另一个程序集中的Person类型相匹配，则会导致错误。反序列化器会在反序列化时将对象引用恢复到其原始状态。这包括集合。

二进制序列化属性
----------------

[NonSerialized]
~~~~~~~~~~~~~~~

不同于数据约定，其中的序列化域具有opt-in策略，二进制引擎具有opt-out策略。我们不希望序列化的域，例如用于临时计算，或是用于存储文件或窗口句柄的域，我们必须使用[NonSerialized]属性进行显式标定：

.. code:: csharp

    [Serializable] public sealed class Person
    {
      public string Name;
      public DateTime DateOfBirth;
      // Age can be calculated, so there's no need to serialize it.
      [NonSerialized] public int Age;
    }

这可以指示序列化器来忽略Age成员。

[OnDeserializing]与[OnDeserialized]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

反序列化会略过我们普通的构造函数以及所有的域初始化。如果所有的域都被序列化则没有太大的问题，但是如果某些域使用[NonSerialized]属性进行标识时则会出现问题。我们可以通过添加一个名为Valid的bool域来进行演示：

.. code:: csharp

    public sealed class Person
    {
      public string Name;
      public DateTime DateOfBirth;
      [NonSerialized] public int Age;
      [NonSerialized] public bool Valid = true;
      public Person() { Valid = true; }
    }

反序列化的Person将不会是Valid的－尽管构造函数与域初始化器进行了初始化。

解决方法与数据约定序列化器相同：使用[OnDeserializing]属性来定义一个特殊的反序列化“构造函数”。我们使用这个属性进行标识的方法将会在反序列化之前被调用：

.. code:: csharp

    [OnDeserializing]
    void OnDeserializing (StreamingContext context)
    {
      Valid = true;
    }

同时我们也可以编写一个[OnDeserialized]方法来更新已计算的Age域：

.. code:: csharp

    [OnDeserialized]
    void OnDeserialized (StreamingContext context)
    {
      TimeSpan ts = DateTime.Now - DateOfBirth;
      Age = ts.Days / 365;                         // Rough age in years
    }

[OnSerializing]与[OnSerialized]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

二进制引擎也支持[OnSerializing]与[OnSerialized]属性。这可以标定在序列化之前或之后执行的方法。要了解这些属性如何使用，我们将定义一个由泛型List组成的Team类：

.. code:: csharp

    [Serializable] public sealed class Team
    {
      public string Name;
      public List<Person> Players = new List<Person>();
    }

这个类可以使用二进制格式化器进行正确的序列化与反序列化，但是SOAP格式化器则不可以。这是因为一个不明显的限制：SOAP格式化器拒绝序列化泛型类型。一个简单的解决方法就是在序列化之前将Players转换为数组，然后在反序列化时转换为List。要使其能够工作，我们可以添加另一个域来存储数组，将原始的Players域标记为[NonSerialized]，然后使用下面的代码编写转换：

.. code:: csharp

    [Serializable] public sealed class Team
    {
      public string Name;
      Person[] _playersToSerialize;
      [NonSerialized] public List<Person> Players = new List<Person>();
      [OnSerializing]
      void OnSerializing (StreamingContext context)
      {
        _playersToSerialize = Players.ToArray();
      }
      [OnSerialized]
      void OnSerialized (StreamingContext context)
      {
        _playersToSerialize = null;   // Allow it to be freed from memory
      }
      [OnDeserialized]
      void OnDeserialized (StreamingContext context)
      {
        Players = new List<Person> (_playersToSerialize);
      }
    }

[OptionalField]与版本化
~~~~~~~~~~~~~~~~~~~~~~~

默认情况下，添加域会破坏与已序列化数据的兼容，除非我们新域上关联[OptionalField]属性。

为了进行演示，假定我们由只有一个域的Person类开始。我们团称其为版本1：

.. code:: csharp

    [Serializable] public sealed class Person       // Version 1
    {
      public string Name;
    }

稍后我们意识到需要第二个域，所以我们创建如下的版本2：

.. code:: csharp

    [Serializable] public sealed class Person       // Version 2
    {
      public string Name;
      public DateTime DateOfBirth;
    }

如果两个计算机通过Remoting来交换Person类，反序列化将会出错，除非我们同时更新到版本2。OptionalField属性可以解决这一问题：

.. code:: csharp

    [Serializable] public sealed class Person       // Version 2 Robust
    {
      public string Name;
      [OptionalField (VersionAdded = 2)] public DateTime DateOfBirth;
    }

这会告诉反序列化器如果在数据流中没有发现DateOfBirth时不要担心，并将其看作非序列化的域。这意味着我们会得到一个空的DateTime。

VersionAdded参数是我们每次增大类型域时将会增加的整数。这可以起到文档的作用，并且对序列化语义没有副作用。

到目前为止，我们关注向后兼容问题：反序列化器不能在序列化流中查找到所期望的域。但是对于双向交流，当反序列化器遇到不知如何处理的域时会出现前向兼容性问题。二进制格式化器是通过编程丢弃额外的数据来自动处理这种问题；SOAP格式化器则会抛出异常。所以，如果我们的双向交流要求健壮性时我们必须使用二进制格式化器；否则，通过实现ISerializable来手动控制序列化。

使用ISerializable的二进制序列化
-------------------------------

实现ISerializable可以为类型提供在其二进制序列化与反序列化上的完全控制。

下面是ISerializable接口的定义：

.. code:: csharp

    public interface ISerializable
    {
      void GetObjectData (SerializationInfo info, StreamingContext context);
    }

GetObjectData会在序列化时触发；其任务就是使用我们希望序列化的所有域中的数据来填充SerializationInfo对象。下面显示了我们如何编写GetObjectData方法来序列化Name与DateOfBirth域：

.. code:: csharp

     public virtual void GetObjectData (SerializationInfo info,
                                         StreamingContext context)
      {
        info.AddValue ("Name", Name);
        info.AddValue ("DateOfBirth", DateOfBirth);
      }

在这个示例中，我们选择通过相应的域来命名每一项。这并不是必须的；可以使用任意的名字，只要在反序列化时使用相同的名字即可。值本身可以是可序列化的任意类型；框架会在需要时进行递归序列化。在字典中存储null值是合法的。

SerializationInfo同时包含我们可以用来控制类型与程序集的属性。StreamingContext参数是一个包含表明我们序列化的实例位于哪里的一个结构。

除了实现ISerializable，控制其序列化的类型需要提供反序列化构造函数，在其中处理与GetObjectData相同的两个参数。构造函数可以声明为任意的可访问性，而运行时将可以找到他。然而通常，我们将其声明为protected从而可以子类可以进行访问。

在下面的示例中，我们在Team类中实现了ISerializable。当其处理选手List时，我们将数据序列化为数组而不是一个泛型List，从而可以提供与SOAP格式化器的兼容性：

.. code:: csharp

    [Serializable] public class Team : ISerializable
    {
      public string Name;
      public List<Person> Players;
      public virtual void GetObjectData (SerializationInfo si,
                                         StreamingContext sc)
      {
        si.AddValue ("Name", Name);
        si.AddValue ("PlayerData", Players.ToArray());
      }
      public Team() {}
      protected Team (SerializationInfo si, StreamingContext sc)
      {
        Name = si.GetString ("Name");
        // Deserialize Players to an array to match our serialization:
        Person[] a = (Person[]) si.GetValue ("PlayerData", typeof (Person[]));
        // Construct a new List using this array:
        Players = new List<Person> (a);
      }
    }

对于通常使用的类型，SerializationInfo类具有一个类型化的Get方法，例如GetString，从而使得编写反序列化构造函数更为容易。如果我们指定一个不存在数据的名字，则会抛出异常。这通常发生在执行序列化与反序列化的代码之间版本不匹配的情况。例如，我们已添加了一个额外的域，然而忘记了旧实例中关于反序列化的实现。为了解决这一问题，我们可以：

-  在稍后版本中所添加的获取数据成员处添加异常处理。
-  实现我们自己的版本计数系统。例如：

.. code:: csharp

    public string MyNewField;
    public virtual void GetObjectData (SerializationInfo si,
                                         StreamingContext sc)
    {
      si.AddValue ("_version", 2);
      si.AddValue ("MyNewField", MyNewField);
      ...
    }
    protected Team (SerializationInfo si, StreamingContext sc)
    {
      int version = si.GetInt32 ("_version");
      if (version >= 2) MyNewField = si.GetString ("MyNewField");
      ...
    }

**派生可序列化的类**

在前面的示例中，我们将用于序列化的属性的类声明为sealed。要了解为什么，考虑下面的类层次结构：

.. code:: csharp

    [Serializable] public class Person
    {
      public string Name;
      public int Age;
    }
    [Serializable] public sealed class Student : Person
    {
      public string Course;
    }

在这个示例中，Person与Student都是可序列化的，而且两个类都使用了默认运行时序列化，因为没有类实现ISerializable。

现在假定Person的开发者出于某种原因决定实现ISerializable并且提供了一个反序列化构造函数来控制Person序列化。新版本的Person如下：

.. code:: csharp

    [Serializable] public class Person : ISerializable
    {
      public string Name;
      public int Age;
      public virtual void GetObjectData (SerializationInfo si,
                                         StreamingContext sc)
      {
        si.AddValue ("Name", Name);
        si.AddValue ("Age", Age);
      }
      protected Person (SerializationInfo si, StreamingContext sc)
      {
        Name = si.GetString ("Name");
        Age = si.GetInt32 ("Age");
      }
      public Person() {}
    }

尽管这可以用于Person实例，但是这种变化却会破坏Student实例的序列化。序列化Student实例也许会看起来成功了，但是Student中的Course并没有被保存到流中，因为Person上的ISerializable.GetObjectData的实现并不了解Student派生的类型。另外，Student实例的反序列化会抛出异常，因为运行时会在Student上查找反序列化构造函数。

该问题的解决方案就是为public与非sealed的序列化类由最外层实现ISerializable。（对于internal类并不如此重要，因为如果需要我们可以很容易的在稍后修改子类。）

如果我们可以编写前面示例中的Person类，Student可以编写为如下的样子：

.. code:: csharp

    [Serializable]
    public class Student : Person
    {
      public string Course;
      public override void GetObjectData (SerializationInfo si,
                                          StreamingContext sc)
      {
        base.GetObjectData (si, sc);
        si.AddValue ("Course", Course);
      }
      protected Student (SerializationInfo si, StreamingContext sc)
        : base (si, sc)
      {
        Course = si.GetString ("Course");
      }
      public Student() {}
    }

XML序列化
---------

Chapter 17. Assembiles
======================

Chapter 18. Reflection and Metadata
===================================

正如我们在前面的章节中所看到的，C#程序编译进一个包含元数据，已编译代码以及资源的程序集中。在运行时检视元数据以及已编译的代码被称为反射。

程序集中的已编译代码几乎包含原始源码中的所有内容。但是某些内容会丢失，例如局部变量名，注释以及预处理器语句。然而，反映可以访问其他所有的内容，甚至是编写一个反编译器也是可能的。

.NET中以及通过C#（例如动态绑定，序列化，数据绑定以及远程）所提供的许多服务都依赖于元数据的存在。我们自己的程序也可以利用这种元数据，甚至是通过使用自定义属性的新信息进行扩展。System.Reflection名字空间提供反映API。也可以通过System.Reflection.Emit名字空间中的类在运行时或是动态创建新的元数据与IL中的可执行指令。

本章中的示例假定我们导入了System与System.Reflection以及System.Reflection.Emit名字空间。

反射与激活类型
--------------

在本节中，我们将会探讨如何获取Type，检视其元数据，并且使用他来动态实例化对象。

获取类型
~~~~~~~~

System.Type的实例表示类型的元数据。因为Type被广泛使用，他位于System名字空间中而不是Sytsem.Reflection名字空间。

我们可以通过在任意对象上调用GetType方法或是使用C#的typeof操作来获得System.Type的实例：

.. code:: csharp

    Type t1 = DateTime.Now.GetType();     // Type obtained at runtime
    Type t2 = typeof (DateTime);          // Type obtained at compile time

我们可以使用typeof来获得数组类型与泛型类型，如下所示：

.. code:: csharp

    Type t3 = typeof (DateTime[]);          // 1-d Array type
    Type t4 = typeof (DateTime[,]);         // 2-d Array type
    Type t5 = typeof (Dictionary<int,int>); // Closed generic type
    Type t6 = typeof (Dictionary<,>);       // Unbound generic type

我们也可以通过名字获取Type。如果有一个到Assembly的引用，则可以调用Assembly.GetType：

Type t = Assembly.GetExecutingAssembly().GetType ("Demos.TestProgram");

如果我们没有Assembly对象，我们可以通过其程序集修饰名（类型的全名后跟完全的修饰名）来获得类型。程序集隐式载入，就如同我们调用Assembly.Load(string)一样：

.. code:: csharp

    Type t = Type.GetType ("System.Int32, mscorlib, Version=2.0.0.0, " +
                           "Culture=neutral, PublicKeyToken=b77a5c561934e089");

一旦我们拥有System.Type对象，我们就可以使用其属性来访问类型的名字，程序集，基类型，可见性，等。如下所示：

.. code:: csharp

    Type stringType = typeof (String);
    string name     = stringType.Name;          // String
    Type baseType   = stringType.BaseType;      // typeof(Object)
    Assembly assem  = stringType.Assembly;      // mscorlib.dll
    bool isPublic   = stringType.IsPublic;      // true

System.Type实例是进入类型整个元数据以及其定义所在的程序集的一个窗口。

**获取数组类型**

正如我们刚才看到的，typeof与GetType可以用于数组类型。我们也可以通过在元素类型上调用MakeArrayType来获取数组类型：

.. code:: csharp

    Type tSimpleArray = typeof (int).MakeArrayType();
    Console.WriteLine (tSimpleArray == typeof (int[]));     // True

可以向MakeArray传递一个整数参数来创建多维矩形数组：

.. code:: csharp

    Type tCube = typeof (int).MakeArrayType (3);       // cube shaped
    Console.WriteLine (tCube == typeof (int[,,]));     // True

GetElementType执行相反的操作；他获取数组类型的元素类型：

Type e = typeof (int[]).GetElementType(); // e == typeof (int)

GetArrayRank返回一个矩形数组的维数：

int rank = typeof (int[,,]).GetArrayRank(); // 3

**获取嵌入类型**

要获取嵌入类型，在所包含的类型上调用GetNestedTypes。例如：

.. code:: csharp

    foreach (Type t in typeof (System.Environment).GetNestedTypes())
      Console.WriteLine (t.FullName);
    OUTPUT: System.Environment+SpecialFolder

关于嵌入类型的一个警告就是CLR会将嵌入类型看作具有特殊的“嵌入”访问级别。例如：

.. code:: csharp

    Type t = typeof (System.Environment.SpecialFolder);
    Console.WriteLine (t.IsPublic);                      // False
    Console.WriteLine (t.IsNestedPublic);                // True

类型名字
~~~~~~~~

一个类型有Namespace，Name与FullName属性。在大数情况下，FullName是前两者的组合：

.. code:: csharp

    Type t = typeof (System.Text.StringBuilder);
    Console.WriteLine (t.Namespace);      // System.Text
    Console.WriteLine (t.Name);           // StringBuilder
    Console.WriteLine (t.FullName);       // System.Text.StringBuilder

这个规则有两个例外：嵌入类型与封装的泛型类型。

**嵌入类型名字**

对于嵌入类型，所包含的类型只出现在FullName中：

.. code:: csharp

    Type t = typeof (System.Environment.SpecialFolder);
    Console.WriteLine (t.Namespace);      // System
    Console.WriteLine (t.Name);           // SpecialFolder
    Console.WriteLine (t.FullName);       // System.Environment+SpecialFolder

+号将包含类型与嵌入的名字空间所区别。

**泛型类型名字**

泛型类型名字以'符号为前缀，其后是类型参数的个数。如果泛型类型是非绑定的，则这一规则同样适用于Name与FullName：

.. code:: csharp

    Type t = typeof (Dictionary<,>); // Unbound
    Console.WriteLine (t.Name);      // Dictionary'2
    Console.WriteLine (t.FullName);  // System.Collections.Generic.Dictionary'2

然而如果泛型类型被封闭，FullName会要求额外的附加物。每一个类型参数的完全程序集修饰名会被枚举：

.. code:: csharp

    Console.WriteLine (typeof (Dictionary<int,string>).FullName);
    // OUTPUT:
    System.Collections.Generic.Dictionary'2[[System.Int32, mscorlib,
    Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],
    [System.String, mscorlib, Version=2.0.0.0, Culture=neutral,
    PublicKeyToken=b77a5c561934e089]]

这可以保证AssemblyQualifiedName（类型的全名与程序集名字的组合）包含足够的信息来完全标识泛型类型及其类型参数。

**数组与指针类型名字**

数组使用与我们在typeof表达式中所有的相同前缀来表示：

.. code:: csharp

    Console.WriteLine (typeof ( int[]  ).Name);      // Int32[]
    Console.WriteLine (typeof ( int[,] ).Name);      // Int32[,]
    Console.WriteLine (typeof ( int[,] ).FullName);  // System.Int32[,]

指针类型类似：

.. code:: csharp

    Console.WriteLine (typeof (byte*).Name);     // Byte*

**ref与out参数类型名字**

描述ref与out参数的Type具有一个&前缀：

.. code:: csharp

    Type t = typeof (bool).GetMethod ("TryParse").GetParameters()[1]
                                                 .ParameterType;
    Console.WriteLine (t.Name);    // Boolean&

基类型与接口
~~~~~~~~~~~~

Type公开了BaseType属性：

.. code:: csharp

    Type base1 = typeof (System.String).BaseType;
    Type base2 = typeof (System.IO.FileStream).BaseType;
    Console.WriteLine (base1.Name);     // Object
    Console.WriteLine (base2.Name);     // Stream

GetInterfaces方法返回一个类型所实现的接口：

.. code:: csharp

    foreach (Type iType in typeof (Guid).GetInterfaces())
      Console.WriteLine (iType.Name);
    IFormattable
    IComparable
    IComparable'1
    IEquatable'1

反射为C#的静态is操作提供了两个动态等同物：

-  IsInstanceOfType:接收一个类型与实例
-  IsAssignableFrom：接受两个类型

下面是第一个的示例：

.. code:: csharp

    object obj  = Guid.NewGuid();
    Type target = typeof (IFormattable);
    bool isTrue   = obj is IFormattable;             // Static C# operator
    bool alsoTrue = target.IsInstanceOfType (obj);   // Dynamic equivalent

IsAssignableFrom更为复杂：

.. code:: csharp

    Type target = typeof (IComparable), source = typeof (string);
    Console.WriteLine (target.IsAssignableFrom (source));         // True

IsSubclassOf方法的工作原则与IsAssignableFrom类型，但是排除了接口。

实例化类型
~~~~~~~~~~

有两种由其类型动态实例化对象的方法：

-  调用静态的Activator.CreateInstance方法
-  通过在Type上调用GetConstructor所获得的ConstructorInfo对象上调用Invoke方法

Activator.CreateInstance接受一个类型以及可以传递给构造器的可选参数：

.. code:: csharp

    int i = (int) Activator.CreateInstance (typeof (int));
    DateTime dt = (DateTime) Activator.CreateInstance (typeof (DateTime),
                                                       2000, 1, 1);

CreateInstance可以让我们指定许多其他选项，例如要从中载入类型的程序集，目标程序域，以及是否要绑定到一个非公开的构造器。如果运行时不能找到合适的构造器则会抛出MissingMethodException。

当我们的参数值在重载的构造器之间不能确定时，在ConstructorInfo上调用Invoke方法则是必要的。例如，假定类X有两个构造器：一个接受string类型参数，而另一个接受StringBuilder类型参数。当我们向Activator.CreateInstance传递一个null参数时目标是不确定的。这时我们就需要使用ConstructorInfo方法：

.. code:: csharp

    // Fetch the constructor that accepts a single parameter of type string:
    ConstructorInfo ci = typeof (X).GetConstructor (new[] { typeof (string) };
    // Construct the object using that overload, passing in null:
    object foo = ci.Invoke (new object[] { null });

要仅基于元素类型动态实例化数组，首先调用MakeArrayType。我们也可以实例化一个泛型类型：我们会在后面的章节中进行描述。

要动态实例化一个委托，调用Delegate.CreateDelegate。下面的示例演示了实例化一个实例委托与一个静态委托：

.. code:: csharp

    class Program
    {
      delegate int IntFunc (int x);
      static int Square (int x) { return x * x; }       // Static method
      int        Cube   (int x) { return x * x * x; }   // Instance method
      static void Main()
      {
        Delegate staticD = Delegate.CreateDelegate
          (typeof (IntFunc), typeof (Program), "Square");d
        Delegate instanceD = Delegate.CreateDelegate
          (typeof (IntFunc), new Program(), "Cube");
        Console.WriteLine (staticD.DynamicInvoke (3));      // 9
        Console.WriteLine (instanceD.DynamicInvoke (3));    // 27
      }
    }

我们可以通过DynamicInvoke来调用返回的Delegate对象，正如我们在示例中所做的，或者是通过转换为类型委托：

.. code:: csharp

    IntFunc f = (IntFunc) staticD;
    Console.WriteLine (f(3));         // 9 (but much faster!)

我们可以向CreateDelegate传递MethodInfo，而不是一个方法名。我们稍后将会描述MethodInfo。

泛型类型
~~~~~~~~

Type可以表示一个封闭的或是非绑定的泛型类型。正如在编译时，封闭的泛型类型可以被实例化，而未绑定的类型则不可以：

.. code:: csharp

    Type closed = typeof (List<int>);
    List<int> list = (List<int>) Activator.CreateInstance (closed);  // OK
    Type unbound   = typeof (List<>);
    object anError = Activator.CreateInstance (unbound);    // Runtime error

MakeGenericType方法将一个未绑定泛型类型转换为一个封闭的泛型类型。只需要简单的传递一个类型参数：

.. code:: csharp

    Type unbound = typeof (List<>);
    Type closed = unbound.MakeGenericType (typeof (int));

GetGenericTypeDefinition方法执行相反的操作：

.. code:: csharp

    Type unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2

如果Type为泛型的，则IsGenericType属性会返回true，而如果泛型类型是未绑定的，则IsGenericTypeDefinition属性会返回true。下面的代码测试一个类型是否为可空的值类型：

.. code:: csharp

    Type nullable = typeof (bool?);
    Console.WriteLine (
      nullable.IsGenericType &&
      nullable.GetGenericTypeDefinition() == typeof (Nullable<>));   // True

GetGenericArguments返回封闭泛型类型的类型参数：

.. code:: csharp

    Console.WriteLine (closed.GetGenericArguments()[0]);     // System.Int32
    Console.WriteLine (nullable.GetGenericArguments()[0]);   // System.Boolean

对于未绑定的泛型类型，GetGenericArguments返回一个表示在泛型定义中指定的占位符类型的伪类型：

Console.WriteLine (unbound.GetGenericArguments()[0]); // T

反射与调用成员
--------------

GetMembers方法返类型的成员。考虑下面的类：

.. code:: csharp

    class Walnut
    {
      private bool cracked;
      public void Crack() { cracked = true; }
    }

我们可以像下面这样来反射其公开成员：

.. code:: csharp

    MemberInfo[] members = typeof (Walnut).GetMembers();
    foreach (MemberInfo m in members)
      Console.WriteLine (m);

其结果如下：

.. code:: csharp

    Void Crack()
    System.Type GetType()
    System.String ToString()
    Boolean Equals(System.Object)
    Int32 GetHashCode()
    Void .ctor()

当不指定参数调用时，GetMembers会返回一个类型（及其基类型）的所有公开成员。GetMember通过名字接收特定的成员－尽管他仍然返回一个数组，因为成员可以被重载：

.. code:: csharp

    MemberInfo[] m = typeof (Walnut).GetMember ("Crack");
    Console.WriteLine (m[0]);                              // Void Crack()

MemberInfo同时有一个名为类型MemberTypes的MemberType的属性。这是一个具有下列值的标志枚举：

.. code:: csharp

    All           Custom        Field        NestedType     TypeInfo
    Constructor   Event         Method       Property

当调用GetMembers，我们可以传递一个MemberTypes实例来限制返回的成员类型。相对应的，我们可以通过调用GetMethods，GetFields，GetProperties，GetEvents，GetConstructors或是GetNestedTypes来限制结果集。这些方法中的每一个还有一个单数版本来在特定的成员上细化。

MemberInfo对象有一个Name属性与两个Type属性：

-  DeclaringType：返回定义成员的Type
-  ReflectedType：返回在其上调用GetMembers的Type

两者的区别体现在在其类型中定义的成员之上调用时：DeclaringType返回基类型，而ReflectedType返回子类型。下面的示例强调了这一点：

.. code:: csharp

    class Program
    {
      static void Main()
      {
        // MethodInfo is a subclass of MemberInfo; see Figure 18-1.
        MethodInfo test = typeof (Program).GetMethod ("ToString");
        MethodInfo obj  = typeof (object) .GetMethod ("ToString");
        Console.WriteLine (test.DeclaringType);      // System.Object
        Console.WriteLine (obj.DeclaringType);       // System.Object
        Console.WriteLine (test.ReflectedType);      // Program
        Console.WriteLine (obj.ReflectedType);       // System.Object
        Console.WriteLine (test == obj);             // False
      }
    }

因为他们有不同的ReflectedTypes，所以test与obj对象并不相等。然而他们的不同纯粹是反映API构成的不同；我们的Program类型在底层的类型系统中并没有单独的ToString方法。我们可以验证在两种方法中两个MethodInfo对象指向相同的方法：

.. code:: csharp

    Console.WriteLine (test.MethodHandle == obj.MethodHandle);    // True
    Console.WriteLine (test.MetadataToken == obj.MetadataToken    // True
                       && test.Module == obj.Module);

MethodHandle对于程序域中的每一个方法是唯一的；MetadataToken对程序集模型中的所有类型与成员是唯一的。

MemberInfo同时定义了返回自定义属性的方法。

成员类型
~~~~~~~~

MemberInfo本身构建在成员之上，因为他是图18-1中所示的类型的抽象基类。

.. figure:: csharp_18_1.png
   :alt: csharp_18_1.png

   csharp\_18\_1.png
如果我们通过GetMethod，GetField，GetProperty，GetEvent，GetConstructor，或是GetNestedType（或是他们的复数版本）获得成员，则转换不是必须的。表18-1总结了对于每一种类别的C#构造使用哪种方法：

|csharp\_table\_18\_1\_1.png| |csharp\_table\_18\_1\_2.png|

每一个MemberInfo子类有很多的方法与属性，公开了成员元数据的所有方面。这其中包括可见性，修饰符，泛型类型参数，参数，返回类型以及自定义属性。

下面是使用GetMethod的一个示例：

.. code:: csharp

    MethodInfo m = typeof (Walnut).GetMethod ("Crack");
    Console.WriteLine (m);                             // Void Crack()
    Console.WriteLine (m.ReturnType);                  // System.Void

所有的\*Info实例会在第一次使用时为反射API缓存：

.. code:: csharp

    MethodInfo method = typeof (Walnut).GetMethod ("Crack");
    MemberInfo member = typeof (Walnut).GetMember ("Crack") [0];
    Console.Write (method == member);       // True

与保留的对象标识一起，缓存改进了较慢API的性能。

C#成员与CLR成员
~~~~~~~~~~~~~~~

前面的表格表现了某些C#功能构造与CLR构造之间并没有1:1的映射关系。这是可以理解的，因为CLR与反射API被设计为所有的.NET语言所用，我们甚至可以在Visual
Basic中使用反射。

某些C#构造－分别为索引器，枚举，操作符与清理器－与CLR的关注是相同的。特别是：

-  C#索引器转换为接受一个或多个参数的属性，标识为类型的[DefalutMember]。
-  C#枚举转换为System.Enum的一个子类型，对于每个成员使用一个静态域。
-  C#操作符转换为特殊命名的静态方不地，以"op\_"开头；例如，"op\_Addition"。
-  C#清理器转换为重写Finalize的方法。

另一个复杂之处在于属性与事件实际上是由以下两点组成的：

-  描述属性或事件（通过PropertyInfo或是EventInfo封装）的元数据
-  一个或是两个后端方法

在C#程序中，后端方法被封装在属性或事件定义中。但是当编译为IL时，后端方法就表示为我们可以调用的普通方法。这就意味着GetMethods会如同普通方法一样返回属性或事件的后端方法。如下所示：

.. code:: csharp

    class Test { public int X { get { return 0; } set {} } }
    void Demo()
    {
      foreach (MethodInfo mi in typeof (Test).GetMethods())
        Console.Write (mi.Name + "  ");
    }
    // OUTPUT:
    get_X  set_X  GetType  ToString  Equals  GetHashCode

我们可以通过MethodInfo中的IsSpecialName属性来标识这些方法。对于属性，索引器，事件访问以及操作符，IsSpecialName会返回true。他对于常规的C#方法以及Finalize方法则返回false。

下面是C#所生成的后端方法：

.. figure:: csharp_backingmethods.png
   :alt: csharp_backingmethods.png

   csharp\_backingmethods.png
每一个后端方法都有一个相关联的MethodInfo对象。我们可以像下面这样进行访问：

.. code:: csharp

    PropertyInfo pi = typeof (Console).GetProperty ("Title");
    MethodInfo getter = pi.GetGetMethod();                   // get_Title
    MethodInfo setter = pi.GetSetMethod();                   // set_Title
    MethodInfo[] both = pi.GetAccessors();                   // Length==2

GetAddmethod与GetRemoveMethod为EventInfo执行类似的工作。

要进入相反的方向－由MthodInfo到其关联的PropertyInfo或是EventInfo－我们需要需要执行查询。LINQ是此类工作的理想选择：

.. code:: csharp

    PropertyInfo p = mi.DeclaringType.GetProperties()
                       .First (x => x.GetAccessors (true).Contains (mi));

泛型类型参数
~~~~~~~~~~~~

我们可以同时为未绑定的与封闭的泛型类型获取成员元数据：

.. code:: csharp

    PropertyInfo unbound = typeof (IEnumerator<>)  .GetProperty ("Current");
    PropertyInfo closed = typeof (IEnumerator<int>).GetProperty ("Current");
    Console.WriteLine (unbound);   // T Current
    Console.WriteLine (closed);    // Int32 Current
    Console.WriteLine (unbound.PropertyType.IsGenericParameter);  // True
    Console.WriteLine (closed.PropertyType.IsGenericParameter);   // False

由未绑定的与封闭的泛型类型中所返回的MemberInfo对象总是不同的：

.. code:: csharp

    PropertyInfo unbound = typeof (List<>)  .GetProperty ("Count");
    PropertyInfo closed = typeof (List<int>).GetProperty ("Count");
    Console.WriteLine (unbound);   // Int32 Count
    Console.WriteLine (closed);    // Int32 Count
    Console.WriteLine (unbound == closed);   // False
    Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True
    Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False

未绑定泛型类型的成员不能被动态调用。

动态调用成员
~~~~~~~~~~~~

一旦我们有了MemberInfo对象，我们就可以动态调用或是读取/设置其值。这被称为动态绑定或是后绑定，因为我们在运行时而不是在编译时选择要调用哪一个成员。

为了进行演示，下面的代码使用普通的静态绑定：

.. code:: csharp

    string s = "Hello";
    int length = s.Length;

下面是使用反射动态执行的：

.. code:: csharp

    object s = "Hello";
    PropertyInfo prop = s.GetType().GetProperty ("Length");
    int length = (int) prop.GetValue (s, null);               // 5

GetValue与SetValue读取或是设置PropertyInfo或是FieldInfo的值。第一个参数是实例，对于静态成员可以为null。访问索引器就类似于访问名为Item的属性，所不同的是当调用GetValaue或是SetValue时我们要为索引器提供值作为第二个参数。

要动态调用一个方法，在MethodInfo上调用Invoke，提供传递给方法的参数数组。如果任意的参数类型错误，则会在运行时抛出异常。使用动态调用，我们丢失了编译时的类型安全，但是依然有运行时的类型安全（就如同dynamic关键字）。

方法参数
~~~~~~~~

假定我们要动态调用string的Substring方法。静态时我们可以使用如下的代码：

Console.WriteLine ("stamp".Substring(2)); // "amp"

下面是使用反射的动态调用：

.. code:: csharp

    Type type = typeof (string);
    Type[] parameterTypes = { typeof (int) };
    MethodInfo method = type.GetMethod ("Substring", parameterTypes);
    object[] arguments = { 2 };
    object returnValue = method.Invoke ("stamp", arguments);
    Console.WriteLine (returnValue);                           // "amp"

因为Substring方法被重载了，我们必须向GetMethod方法传递一个参数类型数组来表明我们希望哪一个版本。如果没有参数类型，GetMethod会抛出AmbiguousMatchException。

定义在MethodBase（MethodInfo与ConstructorInfo的基类）上的GetParameters方法返回参数元数据。我们可以继续我们前面的示例，如下所示：

.. code:: csharp

    ParameterInfo[] paramList = method.GetParameters();
    foreach (ParameterInfo x in paramList)
    {
      Console.WriteLine (x.Name);                 // startIndex
      Console.WriteLine (x.ParameterType);        // System.Int32
    }

**处理ref与out参数**

要传递ref或是out参数，在获取方法之前在类型上调用MakeByRefType方法。例如下面的代码：

.. code:: csharp

    int x;
    bool successfulParse = int.TryParse ("23", out x);

可以动态执行如下：

.. code:: csharp

    object[] args = { "23", 0 };
    Type[] argTypes = { typeof (string), typeof (int).MakeByRefType() };
    MethodInfo tryParse = typeof (int).GetMethod ("TryParse", argTypes);
    bool successfulParse = (bool) tryParse.Invoke (null, args);
    Console.WriteLine (successfulParse + " " + args[1]);       // True 23

同样的方法同时适用于ref与out参数类型。

**获取与调用泛型方法**

在调用GetMethod方法时显式指定参数类型可以有效避免重载方法的不确定性。然而，指定泛型参数类型是不可能的。例如，考虑System.Linq.Enumerable类，该类重载了Where方法，如下所示：

.. code:: csharp

    public static IEnumerable<TSource> Where<TSource>
     (this IEnumerable<TSource> source, Func<TSource, bool> predicate);
    public static IEnumerable<TSource> Where<TSource>
     (this IEnumerable<TSource> source, Func<TSource, int, bool> predicate);

要获取特定的重载，我们必须获取所有的方法然后手动查找所需要的重载。下面的查询获取前一个重载的Where：

.. code:: csharp

    from m in typeof (Enumerable).GetMethods()
    where m.Name == "Where" && m.IsGenericMethod
    let parameters = m.GetParameters()
    where parameters.Length == 2
    let genArg = m.GetGenericArguments().First()
    let enumerableOfT = typeof (IEnumerable<>).MakeGenericType (genArg)
    let funcOfTBool = typeof (Func<,>).MakeGenericType (genArg, typeof (bool))
    where parameters[0].ParameterType == enumerableOfT
       && parameters[1].ParameterType == funcOfTBool
    select m

在这个查询上调用.Single()可以返回具有未绑定参数类型的正确的MethodInfo对象。下一步是通过调用MakeGenericMethod来封闭类型参数：

var closedMethod = unboundMethod.MakeGenericMethod (typeof (int));

在这个示例中，我们使用int来封闭TSource，从而使得我们可以使用类型IEnumerable类型源以及Func类型预测来调用Enumerable.Where：

.. code:: csharp

    int[] source = { 3, 4, 5, 6, 7, 8 };
    Func<int, bool> predicate = n => n % 2 == 1;   // Odd numbers only

现在我们调用封闭的泛型方法，如下所示：

.. code:: csharp

    var query = (IEnumerable<int>) closedMethod.Invoke
      (null, new object[] { source, predicate });
    foreach (int element in query) Console.Write (element + "|");  // 3|5|7|

使用委托改善性能
~~~~~~~~~~~~~~~~

动态调用效率相对较低，通常在毫秒级。如果我们在一个循环中重复调用方法，通过动态实例化一个指向我们动态方法的委托，我们就可以将每一次调用的花费降为纳秒级。在下面的示例中，我们动态调用string的Trim方法一百万次而没有性能负担：

.. code:: csharp

    delegate string StringToString (string s);
    static void Main()
    {
      MethodInfo trimMethod = typeof (string).GetMethod ("Trim", new Type[0]);
      var trim = (StringToString) Delegate.CreateDelegate
                                        (typeof (StringToString), trimMethod);
      for (int i = 0; i < 1000000; i++)
        trim ("test");
    }

这样做速度较快，因为花费较大的动态绑定仅发生一次。

访问非公开成员
~~~~~~~~~~~~~~

用于探测元数据的类型上的所有方法（例如GetProperty，GetField等）具有利用BindingFlags枚举的负载。这个枚举可以作为元数据过滤器，从而可以使得我们改变默认的选择条件。最通常的用法是来获取非公开成员。

例如，考虑下面的类：

.. code:: csharp

    class Walnut
    {
      private bool cracked;
      public void Crack() { cracked = true; }
      public override string ToString() { return cracked.ToString(); }
    }

我们可以像下面这样来使用：

.. code:: csharp

    Type t = typeof (Walnut);
    Walnut w = new Walnut();
    w.Crack();
    FieldInfo f = t.GetField ("cracked", BindingFlags.NonPublic |
                                         BindingFlags.Instance);
    f.SetValue (w, false);
    Console.WriteLine (w);         // False

使用反射来访问非公开成员非常强大，但是这也很危险，因为我们可以破坏封装，在类型的内部实现上创建非托管的依赖。

**BindingFlags枚举**

BindingFlags是可以位组合的。为了获得所有的匹配，我们需要使用下列四个组合中的一个来开始：

.. code:: csharp

    BindingFlags.Public    | BindingFlags.Instance
    BindingFlags.Public    | BindingFlags.Static
    BindingFlags.NonPublic | BindingFlags.Instance
    BindingFlags.NonPublic | BindingFlags.Static

非公开包括internal, protected, protected internal以及private。

下面的示例获取类型object类型上的所有公开静态成员：

.. code:: csharp

    BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;
    MemberInfo[] members = typeof (object).GetMembers (publicStatic);

下面的示例获取object类型上的所有非公开成员，包括静态与实例的：

.. code:: csharp

    BindingFlags nonPublicBinding =
      BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
    MemberInfo[] members = typeof (object).GetMembers (nonPublicBinding);

DeclaredOnly排除了由基类型继承的函数，除非他们被重写。

泛型方法
~~~~~~~~

泛型方法不能被直接调用；下面的代码会抛出异常：

.. code:: csharp

    class Program
    {
      public static T Echo<T> (T x) { return x; }
      static void Main()
      {
        MethodInfo echo = typeof (Program).GetMethod ("Echo");
        Console.WriteLine (echo.IsGenericMethodDefinition);    // True
        echo.Invoke (null, new object[] { 123 } );             // Exception
      }
    }

为了调用泛型方法，需要在MethodInfo上调用MakeGenericMethod方法，指定具体的泛型参数类型。这会返回另一个我们可以调用的MethodInfo，如下所示：

.. code:: csharp

    MethodInfo echo = typeof (Program).GetMethod ("Echo");
    MethodInfo intEcho = echo.MakeGenericMethod (typeof (int));
    Console.WriteLine (intEcho.IsGenericMethodDefinition);            // False
    Console.WriteLine (intEcho.Invoke (null, new object[] { 3 } ));   // 3

匿名调用泛型接口的成员
~~~~~~~~~~~~~~~~~~~~~~

当我们需要调用泛型接口的成员并且我们直到运行时才会知道类型参数时，反射十分有用。在理论上，如果类型进行完美设计，这种需要是不会出现的；当然，类型并不会总是进行完美设计。

例如，假定我们希望编写一个更强大的ToString版本，他可以扩展LINQ查询的结果。我们可以编写如下的代码：

.. code:: csharp

    public static string ToStringEx <T> (IEnumerable<T> sequence)
    {
      ...
    }

这已经暴露不足了。如果sequence包含我们同时希望枚举的嵌入集合时怎么办呢？我们必须重载这个方法来进行处理：

public static string ToStringEx (IEnumerable> sequence)

如果sequence包含集合或是嵌入的sequence时时会怎么办呢？方法重载的静态解决方案变得不可能了，我们需要一种能够扩展来处理任意对象图的方法，例如下面的代码：

.. code:: csharp

    public static string ToStringEx (object value)
    {
      if (value == null) return "<null>";
      StringBuilder sb = new StringBuilder();
      if (value is List<>)                                            // Error
        sb.Append ("List of " + ((List<>) value).Count + " items");   // Error
      if (value is IGrouping<,>)                                      // Error
        sb.Append ("Group with key=" + ((IGrouping<,>) value).Key);   // Error
      // Enumerate collection elements if this is a collection,
      // recursively calling ToStringEx()
      // ...
      return sb.ToString();
    }

不幸的是，上面的代码不能通过编译：我们不能调用类似List<>或是IGrouping<>这样的未绑定泛型类型的成员。在List<>的情况下，我们可以通过使用非泛型的IList接口来解决这一问题：

.. code:: csharp

      if (value is IList)
        sb.AppendLine ("A list with " + ((IList) value).Count + " items");

IGrouping<,>的解决则不是如此简单。下面是接口的定义：

.. code:: csharp

    public interface IGrouping <TKey,TElement> : IEnumerable <TElement>,
                                                 IEnumerable
    {
      TKey Key { get; }
    }

我们并没有可以用来访问Key属性的非泛型类型，所以我们必须使用反射。解决方案并不是调用未绑定泛型类型的成员（这是不可能的），而是调用封闭泛型类型的成员，其类型参数是我们在运行时建立的。

首先是确定value是否实现的IGrouping<,>，如果实现了，则获取其封闭泛型接口。通过LINQ查询我们可以很容易实现。然后我们获取并调用Key属性：

.. code:: csharp

    public static string ToStringEx (object value)
    {
      if (value == null) return "<null>";
      if (value.GetType().IsPrimitive) return value.ToString();
      StringBuilder sb = new StringBuilder();
      if (value is IList)
        sb.Append ("List of " + ((IList)value).Count + " items: ");
      Type closedIGrouping = value.GetType().GetInterfaces()
        .Where (t => t.IsGenericType &&
                     t.GetGenericTypeDefinition() == typeof (IGrouping<,>))
        .FirstOrDefault();
      if (closedIGrouping != null)   // Call the Key property on IGrouping<,>
      {
        PropertyInfo pi = closedIGrouping.GetProperty ("Key");
        object key = pi.GetValue (value, null);
        sb.Append ("Group with key=" + key + ": ");
      }
      if (value is IEnumerable)
        foreach (object element in ((IEnumerable)value))
          sb.Append (ToStringEx (element) + " ");
      if (sb.Length == 0) sb.Append (value.ToString());
      return "\r\n" + sb.ToString();
    }

这种解决方法是健壮的：无论IGrouping<,>被隐式实现还是显式实现，该方法都可以适用。下面的示例演示了该方法：

.. code:: csharp

    Console.WriteLine (ToStringEx (new List<int> { 5, 6, 7 } ));
    Console.WriteLine (ToStringEx ("xyyzzz".GroupBy (c => c) ));
    List of 3 items: 5 6 7
    Group with key=x: x
    Group with key=y: y y
    Group with key=z: z z z

反射程序集
----------

我们可以通过在Assembly对象上调用GetType或是GetTypes动态反射程序集。下面的代码由Demos名字空间中的名为TestProgram的当前程序集获取信息：

Type t = Assembly.GetExecutingAssembly().GetType ("Demos.TestProgram");

下面的示例列出了e:\\demo中mylib.dll程序集中的所有类型：

.. code:: csharp

    Assembly a = Assembly.LoadFrom (@"e:\demo\mylib.dll");
    foreach (Type t in a.GetTypes())
      Console.WriteLine (t);

GetTypes只返回顶层类型而不返回嵌套类型。

将程序集载入到反射环境中
~~~~~~~~~~~~~~~~~~~~~~~~

在前面的示例中，为了列出程序中的类型，我们将程序集载入到当前的程序域中。这会导致不希望的副作用，例如执行静态构造器或是子类型解析。如果我们仅是希望探测类型信息（而不实例化或调用类型），则解决方法是将程序集载入到反射环境中（reflection-only
context）：

.. code:: csharp

    Assembly a = Assembly.ReflectionOnlyLoadFrom (@"e:\demo\mylib.dll");
    Console.WriteLine (a.ReflectionOnly);   // True
    foreach (Type t in a.GetTypes())
      Console.WriteLine (t);

这是编写类浏览器的起点。

有三种方法可以将程序集载入到反射环境中：

-  ReflectionOnlyLoad(byte[])
-  ReflectionOnlyLoad(string)
-  ReflectionOnlyLoadFrom(string)

模块
~~~~

在一个多模块的程序集上调用GetTypes会返回所有模块中的所有类型。所以，我们可以忽略模块的存在，并将程序集看作一个类型的容器。然而有一个模型相关的特例－那就是当处理元数据标记的时候。

元数据标记是在模块的作用范围内引用类型，成员，字符串或是资源的唯一整数。IL使用元数据标记，所以如果我们正解析IL，我们需要对元数据标记进行解析。执行这些操作的方法定义在Module类型中并且名为ResolveType，ResolveMember，ResolveString与ResolveSignature。我们会在本章的最后部分，编写程序集解析器时对这些方法进行探讨。

我们可以通过调用GetModules获取程序集中所有模块的列表。我们也可以通过程序集的ManifestModule属性来直接访问其主模块。

使用属性
--------

CLR允许通过属性向类型，成员以及程序集关联额外的元数据。这是许多CLR功能，例如序列化与安全所用的功能，使得属性成为程序不可分割的一部分。

属性的一个关键特点是我们可以编写我们自己的属性，然后就如同使用其他的属性一样使用我们自己的属性并通过额外的信息来装饰代码元素。这种额外的信息可以被编译进底层的程序集中并且可以使用反射在运行时获取来构建声明式服务，例如自动化单元测试。

属性基础
~~~~~~~~

有三种类型的属性：

-  位映射属性
-  自定义属性
-  伪处自定义属性

其中，只有自定义属性是可扩展的。

位映射属性映射到类型的元数据中的专一位。大多数的C#修饰符关键字，例如public，abstract以及sealed被编译为位映射属性。这些属性非常高效，因为他们在元数据中只需要最少的空间（通常为一位），而CLR可以通过较少或是元需重定向来定位这些属性。反射API通过Type（以及其他的MemberInfo子类）上的专一属性来提供这些属性，例如IsPublic，IsAbstract以及IsSealed。Attributes属性返回一个描述大多数属性的标记枚举：

.. code:: csharp

    static void Main()
    {
      TypeAttributes ta = typeof (Console).Attributes;
      MethodAttributes ma = MethodInfo.GetCurrentMethod().Attributes;
      Console.WriteLine (ta + "\r\n" + ma);
    }

其输出结果为：

.. code:: csharp

    AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit
    PrivateScope, Private, Static, HideBySig

相对应的，自定义属性被编译为类型的主元数据表中的一块。所有的自定主义属性通过System.Attribute的子类来表示，与位映射属性不同，自定义属性是不可扩展的。元数据中的块标识了属性类，同时存储了当提供属性时所指定的位置或是命名参数。我们自己所定义的自定义属性在体系结构上与.NET框架中所定义的自定义属性是相同的。

第4章描述了如何向C#中的类型或是成员关联自定义属性。在这里，我们向Foo类关联一个预定义的Obsolete属性：

[Obsolete] public class Foo {...}

这会通知编译器向Foo的元数据中添加了一个ObsoleteAttribute实例，然后可以在运行时通过在Type或是MemberInfo对象上调用GetCustomAttributes进行反射。

伪自定义属性看起来类似于标准的自定义属性。他们通过System.Attribute子类表示，并且以标准方式进行关联：

[Serializable] public class Foo {...}

区别在于编译器或是CLR在内部会通过将其转换为位映射属性来优化伪自定义属性。伪自定义属性的示例包括[Serializable]，StructLayout，In与Out。反射通过专一属性来公开伪自定义属性，例如IsSerializable，并且在许多情况下，当我们调用GetCustomeAttributes（包括SerializableAttribute）时，伪自定义属性也会作为Syste.Attribute对象返回。这就意味着我们可以忽略伪自定义属性与非伪自定义属性之间的区别。

AttributeUsage属性
~~~~~~~~~~~~~~~~~~

AttributeUsage是一个应用在属性类上的属性。他告诉编译器目标属性应如何被使用：

.. code:: csharp

    public sealed class AttributeUsageAttribute : Attribute
    {
      public AttributeUsageAttribute (AttributeTargets validOn);
      public bool AllowMultiple        { get; set; }
      public bool Inherited            { get; set; }
      public AttributeTargets ValidOn  { get; }
    }

AllowMultiple控制所定义的属性是否可以多次应用相同的目标上；Inherited控制属性是否可以被继承。ValidOn确定了属性可以被关联到的目标集合（类，接口，属性，方法，参数等）。他接受AttributeTargets枚举值的任意组合，其成员如下：

.. code:: csharp

    All Delegate GenericParameter Parameter
    Assembly Enum Interface Property
    Class Event Method ReturnValue
    Constructor Field Module Struct

为了进行演示，下面显示子.NET框架的作者如何向Serializable属性应用AttributeUsage：

.. code:: csharp

    [AttributeUsage (AttributeTargets.Delegate |
                     AttributeTargets.Enum     |
                     AttributeTargets.Struct   |
                     AttributeTargets.Class,     Inherited = false)
    ]
    public sealed class SerializableAttribute : Attribute
    {
    }

事实上，这是Serializable属性的完整定义。编写一个没有属性或是特殊构造器的属性类就是这样简章。

定义我们自己的属性
~~~~~~~~~~~~~~~~~~

下面是我们如何编写我们自己的属性：

#. 由System.Attribute或是System.Attribute的子孙类派生一个类。一般的约定时类名应以Attribute结尾，尽管这并不是必须的。
#. 应用AttributeUsage属性，我们在前面进行了描述。如果属性在其构造器中并不需要属性或是参数，则工作就完成了。
#. 编写一个或是多个公开的构造器。构造器的参数定义了属性的位置参数，并且当使用属性时会变为必须的。
#. 为我们希望支持的每一个命名参数声明了一个公开的域或属性。当使用属性时命名参数是可选的。

下面的类为辅助自动单元测试系统定义了一个属性。他表明了应被测试的方法，测试重复的次数，以及失败时的消息：

.. code:: csharp

    [AttributeUsage (AttributeTargets.Method)]
    public sealed class TestAttribute : Attribute
    {
      public int     Repetitions;
      public string  FailureMessage;
      public TestAttribute () : this (1)     { }
      public TestAttribute (int repetitions) { Repetitions = repetitions; }
    }

下面的Foo类以各种方式使用Test属性对方法进行修饰：

.. code:: csharp

    class Foo
    {
      [Test]
      public void Method1() { ... }
      [Test(20)]
      public void Method2() { ... }
      [Test(20, FailureMessage="Debugging Time!")]
      public void Method3() { ... }
    }

运行时获取属性
~~~~~~~~~~~~~~

有两种标准方法可以在运行时获取属性：

-  在任意的Type或是MemberInfo对象上调用GetCustomAttributes
-  调用Attribute.GetCustomAttribute或是Attribute.GetCustomeAttributes

后两种方法被重载来接受与正确的属性目标（Type，Assembly，Module，MemberInfo或是ParameterInfo）相对应的任意反射对象。

下面的代码显示了如何枚举前面的具有TestAttribute的Foo类的方法：

.. code:: csharp

    foreach (MethodInfo mi in typeof (Foo).GetMethods())
    {
      TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute
        (mi, typeof (TestAttribute));
      if (att != null)
        Console.WriteLine ("Method {0} will be tested; reps={1}; msg={2}",
                            mi.Name, att.Repetitions, att.FailureMessage);
    }

其输出结果如下：

.. code:: csharp

    Method Method1 will be tested; reps=1; msg=
    Method Method2 will be tested; reps=20; msg=
    Method Method3 will be tested; reps=20; msg=Debugging Time!

为了完整演示我们如何用其来编写单元测试系统，下面是相同的示例扩展，从而他实际调用使用Test属性修饰的方法：

.. code:: csharp

    foreach (MethodInfo mi in typeof (Foo).GetMethods())
    {
      TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute
        (mi, typeof (TestAttribute));
     
      if (att != null)
        for (int i = 0; i < att.Repetitions; i++)
          try
          {
            mi.Invoke (new Foo(), null);    // Call method with no arguments
          }
          catch (Exception ex)       // Wrap exception in att.FailureMessage
          {
            throw new Exception ("Error: " + att.FailureMessage, ex);
          }
    }

回到属性反射，下面是列出特定类型上属性的示例：

.. code:: csharp

    [Serializable, Obsolete]
    class Test
    {
      static void Main()
      {
        object[] atts = Attribute.GetCustomAttributes (typeof (Test));
        foreach (object att in atts) Console.WriteLine (att);
      }
    }

其输出结果如下：

.. code:: csharp

    System.ObsoleteAttribute
    System.SerializableAttribute

在反射环境中获取属性
~~~~~~~~~~~~~~~~~~~~

在被载入到反射环境中的成员之上调用GetCustomeAttributes是被禁止的，因为这需要实例化任意的类型属性（记住在反射环境中对象实例化是不允许的）。为了解决这一问题，有一个名为CustomeAttributeData的特殊类型用来在这些属性上反射。下面是如何使用的一个示例：

.. code:: csharp

    IList<CustomAttributeData> atts = CustomAttributeData.GetCustomAttributes
                                      (myReflectionOnlyType);
    foreach (CustomAttributeData att in atts)
    {
      Console.Write (att.GetType());               // Attribute type
      Console.WriteLine (" " + att.Constructor);   // ConstructorInfo object
      foreach (CustomAttributeTypedArgument arg in att.ConstructorArguments)
        Console.WriteLine ("  " +arg.ArgumentType + "=" + arg.Value);
      foreach (CustomAttributeNamedArgument arg in att.NamedArguments)
        Console.WriteLine ("  " + arg.MemberInfo.Name + "=" + arg.TypedValue);
    }

在许多情况下，属性类型将会位于不同于我们正在反射的另一个程序集中。一个解决方法就
是在当前的程序域中处理ReflectionOnlyAssemblyResolve事件：

.. code:: csharp

    ResolveEventHandler handler = (object sender, ResolveEventArgs args)
                                => Assembly.ReflectionOnlyLoad (args.Name);
    AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += handler;
    // Reflect over attributes...
    AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= handler;

动态代码生成
------------

System.Reflection.Emit名字空间包含在运行时创建元数据与IL的类。动态代码生成对于特定类型的程序任务十分有用。一个例子就是正则表达式API，他可以将表述类型转换为特定的正则表达式。框架中的其他Reflection.Emit的使用包括为远程动态生成透明代码以及使用最少的运行负载生成执行特定XSLT转换的类型。LINQPad使用Reflection.Emit动态生成类型DataContext类。

使用DynamicMethod生成IL
~~~~~~~~~~~~~~~~~~~~~~~

DynamicMethod是System.Reflection.Emit名字空间中用于即时生成方法的一个轻量级工具。不同于TypeBuilder，他并不需要我们首先设置一个包含该方法的动态程序集，模块以及类型。这使得他适用于简章的任务－同时也承担介绍Reflection.Emit的任务。

下面是使用DynamicMethod创建一个要控制台输出Hello world方法的简单示例：

.. code:: csharp

    public class Test
    {
      static void Main()
      {
        var dynMeth = new DynamicMethod ("Foo", null, null, typeof (Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        gen.EmitWriteLine ("Hello world");
        gen.Emit (OpCodes.Ret);
        dynMeth.Invoke (null, null);                    // Hello world
      }
    }

OpCodes对于每一个IL操作码有一个静态只读域。大多数功能是通过各种操作码来提供的，尽管ILGenerator具有用于生成标签与局部变量以及异常处理的特殊方法。方法总是以Opcodes.Ret结束，意味着"return"。ILGenerator上的EmitWriteLine方法是输出大量的底层操作码的简写。我们可以使用下面的代码来替换EmitWriteLine方法，而我们会获得相同的结果：

.. code:: csharp

    MethodInfo writeLineStr = typeof (Console).GetMethod ("WriteLine",
                               new Type[] { typeof (string) });
    gen.Emit (OpCodes.Ldstr, "Hello world");     // Load a string
    gen.Emit (OpCodes.Call, writeLineStr);       // Call a method

注意，我们向DynamicMethod的构造器传递了typeof(Test)。这可以使得动态方法访问类型的非公开方法，从而允许我们这样做：

.. code:: csharp

    public class Test
    {
      static void Main()
      {
        var dynMeth = new DynamicMethod ("Foo", null, null, typeof (Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        MethodInfo privateMethod = typeof(Test).GetMethod ("HelloWorld",
          BindingFlags.Static | BindingFlags.NonPublic);
        gen.Emit (OpCodes.Call, privateMethod);     // Call HelloWorld
        gen.Emit (OpCodes.Ret);
        dynMeth.Invoke (null, null);                // Hello world
      }
      static void HelloWorld()       // private method, yet we can call it
      {
        Console.WriteLine ("Hello world");
      }
    }

理解IL需要大量的时间。与理解全部的操作码不同，编译C#程序，然后检测，拷贝并调整IL要简单得多。程序集查看工作，例如ildasm或是Lutz
Roeder的反映器适用于这种工作。

计算栈
~~~~~~

IL的中心是计算栈（evaluation
stack）的概念。计算栈不同于用来存储局部变量与方法参数的栈。

要使用参数调用方法，我们首先将参数压入计算栈，然后调用方法。然后方法由栈中弹出他所需要的参数。我们在前面调用Console.WriteLine时演示了这一过程。下面是一个使用整数的类似例子：

.. code:: csharp

    var dynMeth = new DynamicMethod ("Foo", null, null, typeof(void));
    ILGenerator gen = dynMeth.GetILGenerator();
    MethodInfo writeLineInt = typeof (Console).GetMethod ("WriteLine",
                                            new Type[] { typeof (int) });
    // The Ldc* op-codes load numeric literals of various types and sizes.
    gen.Emit (OpCodes.Ldc_I4, 123);        // Push a 4-byte integer onto stack
    gen.Emit (OpCodes.Call, writeLineInt);
    gen.Emit (OpCodes.Ret);
    dynMeth.Invoke (null, null);           // 123

要将两个数相加，我们首先将每一个数字载入到计算栈上，然后调用Add。Add操作码由计算栈上弹出两个值，然后将结果压入栈。下面的代码将2与2相加，然后使用writeLine方法输出结果：

.. code:: csharp

    gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2
    gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2
    gen.Emit (OpCodes.Add);                 // Add the result together
    gen.Emit (OpCodes.Call, writeLineInt);

要计算10/2+1，我们可以使用下面的方法：

.. code:: csharp

    gen.Emit (OpCodes.Ldc_I4, 10);
    gen.Emit (OpCodes.Ldc_I4, 2);
    gen.Emit (OpCodes.Div);
    gen.Emit (OpCodes.Ldc_I4, 1);
    gen.Emit (OpCodes.Add);
    gen.Emit (OpCodes.Call, writeLineInt);

或者：

.. code:: csharp

    gen.Emit (OpCodes.Ldc_I4, 1);
    gen.Emit (OpCodes.Ldc_I4, 10);
    gen.Emit (OpCodes.Ldc_I4, 2);
    gen.Emit (OpCodes.Div);
    gen.Emit (OpCodes.Add);
    gen.Emit (OpCodes.Call, writeLineInt);

向动态方法传递参数
~~~~~~~~~~~~~~~~~~

Chapter 19. Dynamic Programming
===============================

在第4章中，我们解释了C#语言中的动态绑定的工作原理。在本章中，我们会简要了解DLR，然后会探讨下列的动态编程模式：

-  数值类型统一
-  动态成员重载解析
-  实现动态对象
-  与动态语言互操作

本章中的类型位于System.Dynamic名字空间中，除了CallSite<>，其位于System.Runtime.CompilerServices。

动态语言运行时
--------------

C#依赖动态语言运行时（DLR）来执行动态绑定。

相对于其名字，DLR并不是CLR的动态版本。他是位于CLR之上的一个库，就如同System.Xml.dll等其他库。其主要角色就是提供运行时服务来统一动态编程－静态与动态类型语言。这意味着如C#，VB，IronPython与IronRuby都会使用共同的协议来动态调用函数，允许他们共享库并且调用以其他语言所编写的代码。

DLR同时可以使得在.NET中编写新的动态语言相对更为容易。动态语言的作者是在表达式树的层次上进行工作，而不必接触IL。

DLR进一步保证所有的消费者都会获得call-site缓存的好处，这是DLR避免不必要的重复的动态绑定中昂贵的成员解析所做的优化。

**什么是Call Site?**

当编译器遇到一个动态表达式时，他并不知道谁会在运行时计算该表达式。例如，考虑下面的方法：

.. code:: csharp

    public dynamic Foo (dynamic x, dynamic y)
    {
      return x / y;   // Dynamic expression
    }

x与y变量可以是任意的CLR对象，COM对象甚至可以是动态语言中的对象。所以编译并不能用其通常静态方法来调用已知类型的已知方法。相反，编译器会调用最终会导致描述操作，由DLR在运行时绑定的call
site管理的表达式树。call site实际上扮演了调用者与被调用者之间的中介。

一个call
site是由Sytem.Core.dll中的CallSite<>类来表示的。我们可以通过反编译前面的方法来看到－结果类似于下面的代码：

.. code:: csharp

    static CallSite<Func<CallSite,object,object,object>> divideSite;
    [return: Dynamic]
    public object Foo ([Dynamic] object x, [Dynamic] object y)
    {
      if (divideSite == null)
        divideSite =
          CallSite<Func<CallSite,object,object,object>>.Create (
            Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation (
              CSharpBinderFlags.None,
              ExpressionType.Divide,
              /* Remaining arguments omitted for brevity */ ));
      return divideSite.Target (divideSite, x, y);
    }

正如我们所看到的，call
site会在静态域中进行缓存来避免每次调用重新调用的代价。DLR进一步缓存绑定阶段的结果与实际的方法目标。

然后实际的动态调用通过调用site的Target并传递x与y操作数来实现。

注意Binder类是特定于C#的。支持动态绑定的所有语言提供了语言特定的绑定器来帮助DLR以一种语言特定的方式解释表达式。例如，如果我们使用整数值5和2来调用Foo，C#绑定器会保证我们返回2。相对的，VB.NET绑定器将会返回2.5。

数值类型统一
------------

我们会第4章中已经看到dynamic如何让我们编写一个跨越所有数值类型的方法：

.. code:: csharp

    static dynamic Mean (dynamic x, dynamic y)
    {
      return (x + y) / 2;
    }
    static void Main()
    {
      int x = 3, y = 5;
      Console.WriteLine (Mean (x, y));
    }

然而这牺牲了静态类型安全。下面的语句编译时无错，但会在运行时出错：

string s = Mean (3, 5); // Runtime error!

我们可以通过引用一个泛型类型参数来修改这一问题，然后在计算本身内部转换为dynamic：

.. code:: csharp

    static T Mean<T> (T x, T y)
    {
      dynamic result = ((dynamic) x + y) / 2;
      return (T) result;
    }

注意我们显式的将结果转换为T。如果我们忽略这一转换，我们就要依赖于隐式转换，也许最初看起来会是正确的。然而在使用8位或是16位整数类型调用方法时，隐式转换会在运行时失败。要理解为什么，考虑当我们将两个8位数相加时对普通的静态类型会发生什么：

.. code:: csharp

    byte b = 3;
    Console.WriteLine ((b + b).GetType().Name);  // Int32

我们会得到Int32，因为编译器会在执行算术操作之前将8位或是16位数值转换为Int32。为了一致性，C#绑定器会告诉DLR执行相同的操作，而我们就会得到一个需要显式转换为较小整数值类型的Int32。当然，如果我们相加而不是获取平均数也许就会有溢出的可能。

动态绑定会导致一些小的性能影响－即使使用call-site缓存。我们可以通过添加一些仅覆盖最常用类型的静态重载形式来减少性能影响。例如，如果性能测试表明使用double调用Mean是一个性能瓶颈，我们可以添加下面的重载形式：

.. code:: csharp

    static double Mean (double x, double y)
    {
      return (x + y) / 2;
    }

当使用在编译时就已知为double类型的参数来调用Mean方法，编译器将会优先使用重载版本。

动态成员重载解析
----------------

使用动态类型参数调用静态已知的方法会延迟由编译时到运行时的成员重载解析。这在简化特定编程任务时会非常有用－例如简化Visitor设计模式。同时他在解决C#的静态类型所用的限制方面也十分有用。

简化Visitor模式
~~~~~~~~~~~~~~~

实际上，Visitor模式可以使得我们向类层次结构添加一个新方法而不修改已有的类。尽管十分有用，这种模式处于静态形式并且与其大多数设计模式比起来要简单得多。他同时要求被访问的类通过提供一个Accept方法而变得“对访问者友好”，如果类并不在我们的控制之下，那么是不可能的。

通过动态绑定，我们可以更为容易的实现相同的目标－而且不需修改已存在的类。为了进行演示，考虑下面的类层次结构：

.. code:: csharp

    class Person
    {
      public string FirstName { get; set; }
      public string LastName  { get; set; }
      // The Friends collection may contain Customers & Employees:
      public readonly IList<Person> Friends = new Collection<Person> ();
    }
    class Customer : Person { public decimal CreditLimit { get; set; } }
    class Employee : Person { public decimal Salary      { get; set; } }

假定我们希望编写一个方法将Person的详细内容导出为一个XML
XElement。最显然的解决方案就是在Person类中编写一个名为ToXElement()的方法，返回一个使用Person属性填充的XElement。然后，我们可以在Customer与Employee类中重载该方法，从而使得XElement也可以使用CreditLimit与Salary进行填充。然而，这种模式是有问题的，主要由于两个原因：

-  我们也许并不拥有Person，Customer与Employee类，从而向其中添加方法是不可能的。（并且扩展方法并不会提供多态行为）
-  Person，Customer与Employee类也许已经非常庞大。例如Person已经包含了如此之多的功能从而变成了维护的噩梦。一个好的矫正方法就是避免向Person类添加并不需要访问Person私有状态的方法。ToXElement方法也许是一个很好的替代者。

通过动态成员重载解析，我们可以在一个单独的类编写ToXElement功能，而无需依据类型进行切换：

.. code:: csharp

    class ToXElementPersonVisitor
    {
      public XElement DynamicVisit (Person p)
      {
        return Visit ((dynamic)p);
      }
      XElement Visit (Person p)
      {
        return new XElement ("Person",
          new XAttribute ("Type", p.GetType().Name),
          new XElement ("FirstName", p.FirstName),
          new XElement ("LastName", p.LastName),
          p.Friends.Select (f => DynamicVisit (f))
        );
      }
      XElement Visit (Customer c)   // Specialized logic for customers
      {
        XElement xe = Visit ((Person)c);   // Call "base" method
        xe.Add (new XElement ("CreditLimit", c.CreditLimit));
        return xe;
      }
      XElement Visit (Employee e)   // Specialized logic for employees
      {
        XElement xe = Visit ((Person)e);   // Call "base" method
        xe.Add (new XElement ("Salary", e.Salary));
        return xe;
      }
    }

DynamicVisit方法执行动态转发－在运行时调用Visit的最特定方法。注意粗体显示的代码行，其中我们在Friends集合中的每一个人上调用DynamicVisit。这可以保证如果一个朋友是Customer或Employee，正确的重载方法会被调用。

我们可以使用如下的代码进行演示：

.. code:: csharp

    var cust = new Customer
    {
      FirstName = "Joe", LastName = "Bloggs", CreditLimit = 123
    };
    cust.Friends.Add (
      new Employee { FirstName = "Sue", LastName = "Brown", Salary = 50000 }
    );
    Console.WriteLine (new ToXElementPersonVisitor().DynamicVisit (cust));

输出结果如下：

.. code:: csharp

    <Person Type="Customer">
      <FirstName>Joe</FirstName>
      <LastName>Bloggs</LastName>
      <Person Type="Employee">
        <FirstName>Sue</FirstName>
        <LastName>Brown</LastName>
        <Salary>50000</Salary>
      </Person>
      <CreditLimit>123</CreditLimit>
    </Person>

**变体**

如果我们计划多个访问者类，一个有用的变体可以为访问者定义抽象蕨类：

.. code:: csharp

    abstract class PersonVisitor<T>
    {
      public T DynamicVisit (Person p) { return Visit ((dynamic)p); }
      protected abstract T Visit (Person p);
      protected virtual T Visit (Customer c) { return Visit ((Person) c); }
      protected virtual T Visit (Employee e) { return Visit ((Person) e); }
    }

这样子类就不需要定义其自己的DynamicVisit方法：他们所需要做的就是重载Visit版本来实现特定的行为。

Chapter 20. Security
====================

Chapter 21. Threading
=====================

C#允许我们通过多线程并行执行代码。

线程类似于我的程序运行所在的操作系统进程。类似于进程在一个计算机上并行运行，线程在一个进程内并行运行。进程彼此之间是完全隔离的；线程只具有有限的隔离。通常情况下，线程与运行在相同程序中的其他线程共享（堆）内存。这在某种程度上是线程为什么有用的原因：例如，一个线程可以在后台获取数据，而另一个线程可以在数据到达时显示数据。

本章描述用于创建，配置，线程交互以及如何通过锁和信号协调线程动作的语言和框架特性。同时描述辅助线程的基本预定义类型，例如BackgroundWorker与Timer类。

线程的使用与烂用
----------------

多线程有许多用处；下面是多线程最通常的应用：

开始
----

客户程序（Console，WPF或是Windows
Forms）在一个由CLR与操作系统自动创建的单线程中启动。这里他作为单线程程序结束生命周期，除非我们通过创建多线程执行其他一些操作。

我们可以通过实例化一个Thread对象并调用其Start方法来创建并启动一个新线程。Thread的最简单的构造器需要一个ThreadStart委托：表明由哪里开始执行的一个无参数方法。例如，如下面的代码：

.. code:: csharp

    class ThreadTest
    {
      static void Main()
      {
        Thread t = new Thread (WriteY);          // Kick off a new thread
        t.Start();                               // running WriteY()
        // Simultaneously, do something on the main thread.
        for (int i = 0; i < 1000; i++) Console.Write ("x");
      }
      static void WriteY()
      {
        for (int i = 0; i < 1000; i++) Console.Write ("y");
      }
    }
    // Output:
    xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy
    yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
    yyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    ...

主线程创建一个新线程t，并在些基础上运行重复输出字符y的方法。同时主线程重复输出字符x，如图21-1所示。在单核的计算机上，操作系统必须为每一个线程分配时间片来模拟并行，从而产生x与y的重复块。在一个多核或是多处理器的机器上，这两个线程可以实现真正的并行，尽管我们仍然会得到x与y的重复块，这是由Console处理并发请求的机制导致的。

线程一旦启动，线程的IsAllive属性返回true，直到线程的结束点。当传递给Thread的构造器的委托执行完成时，线程结束。一旦结束，线程不能重新启动。

我们可以通过调用线程的Join方法来等待另一个线程的结束。如下面的示例：

.. code:: csharp

    static void Main()
    {
      Thread t = new Thread (Go);
      t.Start();
      t.Join();
      Console.WriteLine ("Thread t has ended!");
    }
    static void Go() { for (int i = 0; i < 1000; i++) Console.Write ("y"); }

这会输出y 1000次，然后是Thread t has
ended!。当调用Join时我们可以包含一个超时，以毫秒或是TimeSpan形式。如果线程结束则返回true，如果超时则返回false。

Thread.Sleep会将当前的线程挂起一段时间：

.. code:: csharp

    Thread.Sleep (TimeSpan.FromHours (1));  // sleep for 1 hour
    Thread.Sleep (500);                     // sleep for 500 milliseconds

Thread.Sleep(0)会立即放弃线程当前的时间片，自愿的将CPU交给其他的线程。Framework
4.0新的Thread.Yield()方法会执行相同的操作－所不同的是他只放弃给运行在相同处理器上的其他线程。

每一个线程都有一个Name属性，我们可以为了调试的目的进行设置。这在Visual
Studio中特别有用，因为线程的名字会显示在线程窗口与Debug
Location工具栏上。我们只能设置一次线程的名字；以后尝试修改会抛出异常。

静态的Thread.CurrentThread属性会返回当前正在运行的线程：

Console.WriteLine (Thread.CurrentThread.Name);

向线程提供数据
~~~~~~~~~~~~~~

向线程的目标方法传递参数的最简单的方法就是执行使用所需要的参数调用方法的Lambda表达式：

.. code:: csharp

    static void Main()
    {
      Thread t = new Thread ( () => Print ("Hello from t!") );
      t.Start();
    }
    static void Print (string message) { Console.WriteLine (message); }

使用这个方法，我们可以向方法传递任意数量的参数。我们甚至可以将整个实现封装为一个多语句的Lambda：

.. code:: csharp

    new Thread (() =>
    {
      Console.WriteLine ("I'm running on another thread!");
      Console.WriteLine ("This is so easy!");
    }).Start();

在C# 2.0中我们也可以很容易的使用匿名方法来执行相同的操作：

.. code:: csharp

    new Thread (delegate()
    {
      ...
    }).Start();

另一个技术则是向Thread的Start方法传递参数：

.. code:: csharp

    static void Main()
    {
      Thread t = new Thread (Print);
      t.Start ("Hello from t!");
    }
    static void Print (object messageObj)
    {
      string message = (string) messageObj;   // We need to cast here
      Console.WriteLine (message);
    }

之所以可以这样是因为Thread的构造器被重载来接受两个委托中的任意一个：

.. code:: csharp

    public delegate void ThreadStart();
    public delegate void ParameterizedThreadStart (object obj);

ParameterizedThreadStart的限制是他只接受一个参数。并且由于他是object类型，通常需要转换。

**Lambda表达式与捕获变量**

正如我们所看到的，Lambda表达式是向线程传递数据的最强大的方法。然而，然而我们必须小心在启动线程之后偶然修改捕获变量。例如，考虑下面的示例：

.. code:: csharp

    for (int i = 0; i < 10; i++)
      new Thread (() => Console.Write (i)).Start();

其输出是不确定的！下面是一种结果：

0223557799

问题在于变量i在整个循环生命周期中指向相同的内存地址。所以，每一个线程都是在一个运行时值会发生变量的变量上调用Console.Write！解决方法就是使用临时变量，如下所示：

.. code:: csharp

    for (int i = 0; i < 10; i++)
    {
      int temp = i;
      new Thread (() => Console.Write (temp)).Start();
    }

现在temp是局限于每一个循环迭代的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以简单的使用下面的示例使用更为简单的代码来演示前面的问题：

.. code:: csharp

    string text = "t1";
    Thread t1 = new Thread ( () => Console.WriteLine (text) );
    text = "t2";
    Thread t2 = new Thread ( () => Console.WriteLine (text) );
    t1.Start();
    t2.Start();

其输出结果为：

.. code:: csharp

    t2
    t2

在线程间共享数据
~~~~~~~~~~~~~~~~

前面的示例演示了在线程之间共享捕获变量。让我们后退一步并检测一下在更为简单的没有调用Lambda表达式或匿名方法的情况使用局部变量会发生什么情况。考虑下面的程序：

.. code:: csharp

    static void Main()
    {
      new Thread (Go).Start();      // Call Go() on a new thread
      Go();                         // Call Go() on the main thread
    }
    static void Go()
    {
      // Declare and use a local variable - 'cycles'
      for (int cycles = 0; cycles < 5; cycles++) Console.Write (cycles);
    }
    // OUTPUT:  0123401234

当进入Go方法时，每一个线程会获得一份单独的周期变量的拷贝，从而不会与另一个并发线程相影响。CLR与操作系统是通过为局部变量赋一个线程专有的私有内存栈来实现的。

如果线程希望共享数据，这可以通过共同的引用来实现。这可以是我们前面所看到的捕获变量－但是域的情况更为常见。如下面的示例：

.. code:: csharp

    static void Main()
    {
      Introducer intro = new Introducer();
      intro.Message = "Hello";
      var t = new Thread (intro.Run);
      t.Start(); t.Join();
      Console.WriteLine (intro.Reply);
    }
    class Introducer
    {
      public string Message;
      public string Reply;
      public void Run()
      {
        Console.WriteLine (Message);
        Reply = "Hi right back!";
      }
    }
    // Output:
    Hello
    Hi right back!

共享域同时可以向新线程传送数据以及稍后由其获取返回数据。而且，他可以使得线程在运行时彼此通信。共享域可以是实例或是静态的。

前台与后台线程
~~~~~~~~~~~~~~

默认情况下，我们显式创建的线程是前台线程。只要有一个前台线程在运行，前台线程就可以使得程序保持存活，而后台线程并不会这样。一旦所有的前台线程完成，而后台线程依然运行直到突然结束。

我们可以使用线程的IsBackground属性来查询或是修改线程的后台状态。如下面的示例：

.. code:: csharp

    class PriorityTest
    {
      static void Main (string[] args)
      {
        Thread worker = new Thread ( () => Console.ReadLine() );
        if (args.Length > 0) worker.IsBackground = true;
        worker.Start();
      }
    }

如果这个程序以无参数的形式调用，工作线程会假定前台状态并且会等待用户输入回车的ReadLine语句。同时，主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。

相反，如果参数被传递给Main()，工作线程被赋值为后台状态，而当主线程退出时，程序几乎是立即退出。

当一个进程以这种方式结束时，后台线程执行栈中的finally块就会被避开。如果我们的程序依赖finally（或是using）块来执行清理工作，例如释放资源或是删除临时文件，则是一个问题。为了避免这一问题，在退出程序时我们可以显式的等待这些后台线程。有两种方法可以实现这一目的：

-  如果我们自己创建了线程，在线程上调用Join方法。
-  如果我们使用池线程，使用事件等待句柄。

在任一种况下，我们都应指定一个超时时间，从而我们可以放弃由于某种原因而拒绝完成的线程。这是我们的后备退出策略：最后，我们希望我们的程序关闭－而无需用户由任务管理器中结束。

前台线程不需要这种处理，但是我们必须小心避免会使得线程没有结束的bug。程序退出失败最可能的原因就是活跃的前台线程的存在。

线程优先级
~~~~~~~~~~

线程的优先级决定了相对于操作系统中的其他活跃线程，他可以获得多少执行时间，线程优先级值如下：

enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest
}

只有当多个线程同时活跃时，线程优先级才有意义。

仅是提升线程的优先级并且使用执行实时的工作，因为他还受到程序进程优先的限制。要进行实时的工作，我们必须同时使用System.Diagnostics中的Process类来提升进程的优先级。

.. code:: csharp

    using (Process p = Process.GetCurrentProcess())
      p.PriorityClass = ProcessPriorityClass.High;

ProcessPriorityClass.High实际上就是最高优先级：Realtime。将一个进程的优先级设置为Realtime即是通知OS我们绝不希望该进程将CPU时间交给其他进程。如果我们的程序恰好进入了无限循环，我们就会发现甚至是操作系统也被锁住了，也不会电源按钮来拯救我们。正是由于这一原因，High通常是实时程序的最好选择。

注意：如果我们的实时拥有用户界面，提升进程的优先级会使得屏幕更新超出CPU时间，降低整台机器的速度（特别是如果UI很复杂时）。降低主线程的优先级结合提升进程的优先级可以保证实时线程不会被屏幕重绘所抢占，但是依然没有解决问题，因为操作系统依然作为一个整体的进程分配不成比例的资源。一个完美的解决方案就是拥有一个实时进程，同时用户界面作为一个具有不同进程优先级的单独程序来运行，彼此之间通过远程或是内存映射文件进行通信。内存映射文件十分适用于这一任务；我们会在第14章与25章中解释其如何工作。

即使是提升了进程优先级，但是在处理硬实时需求时依然存在托管环境适用性的限制。在第12章中，我们描述了垃圾回收的问题。进一步说，操作系统也会面临其他的挑战－即使是对非托管程序－这可以通过特殊的硬件或是特殊的实时平台得到最好的解决。

异常处理
~~~~~~~~

当线程被创建并开始执行时，则作用域内的try/catch/finally块则与该线程不再有任何关系。考虑下面的程序：

.. code:: csharp

    public static void Main()
    {
      try
      {
        new Thread (Go).Start();
      }
      catch (Exception ex)
      {
        // We'll never get here!
        Console.WriteLine ("Exception!");
      }
    }
    static void Go() { throw null; }   // Throws a NullReferenceException

这个示例中的try/catch语句是无效的，而新创建的线程将会遇到一个未处理的NullReferenceException。当我们认为每一个线程具有独立的执行路径时，这种行为就可以理解了。

修改方法是将异常处理器移到Go方法中：

.. code:: csharp

    public static void Main()
    {
       new Thread (Go).Start();
    }
    static void Go()
    {
      try
      {
        ...
        throw null;    // The NullReferenceException will get caught below
        ...
      }
      catch (Exception ex)
      {
        Typically log the exception, and/or signal another thread
        that we've come unstuck
        ...
      }
    }

我们在生产程序中所有线程入口函数处都需要一个异常处理器，就如同我们在主线程所做的这样。未处理的异常会使得整个程序停止运行，并提示一个讨厌的对话框。

然而，在某些情况下，我们可以不必处理工作线程上的异常，因为.NET框架会为我们处理。在下面的内容中，我们将会讨论：

-  异步委托
-  BackgroundWorker
-  任务并行库

线程池
------

当我们启动一个线程时，会有几百毫秒的时候花费在组织如刷新私有局部变量栈这样的事情上。每个线程会占用（默认情况下）1M内存。线程池通过共享与重用线程，允许多线程应用非常小的粒度级别上而没有性能损失来减轻这些负担。这在多核心处理器以并行“分治”的风格执行计算代码时将会十分有用。

线程池也会限制其同时运行的线程总数。大多的活动线程会加重操作系统的管理负担同时会使得CPU缓存无效。一旦达到极限，任务就会进行排除，并且只会在一个任务完成时才会启动另一个任务。这使得任意的并行程序成为可能，例如web服务器。

有多种方法可以进入线程池：

-  通过任务并行库或是PLINQ
-  调用ThreadPool.QueueUserWorkItem
-  通过异步委托
-  通过BackgroundWorker

任务并行库（TPL）与PLINQ非常强大，而我们会希望在一个高级层次上使用他们来辅助多线程，即使当线程池化并不重要。我们会在下一章中对其进行详细讨论。现在，我们会简单看一下我们如何使用Task类作为在池化的线程上运行委托的简单方法。

我们可以通过属性来查询我们当前是否运行在池化线程上。

通过TPL进行线程池
~~~~~~~~~~~~~~~~~

我们可以很容易的使用任务并行库中的Task类来进入线程池。这是由框架4.0引入的：如果我们熟悉旧式的构造，可以将非泛型的Task类看作ThreadPool.QueueUserWorkItem的替换，而泛型的Task看作异步委托的替换。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。

要使用非泛型的Task类，调用Task.Factory.StartNew，并传递目标方法的委托：

.. code:: csharp

    static void Main()    // The Task class is in System.Threading.Tasks
    {
      Task.Factory.StartNew (Go);
    }
    static void Go()
    {
      Console.WriteLine ("Hello from the thread pool!");
    }

Task.Factory.StartNew返回一个Task对象，我们可以用来监视任务，例如，我们可以通过调用其Wait方法来等待其结束。

泛型的Task类是非泛型Task的一个子类。他可以使得我们在其完成执行后由任务中返回值。在下面的示例中，我们使用Task来下载一个web页面：

.. code:: csharp

    static void Main()
    {
      // Start the task executing:
      Task<string> task = Task.Factory.StartNew<string>
        ( () => DownloadString ("http://www.linqpad.net") );
      // We can do other work here and it will execute in parallel:
      RunSomeOtherMethod();
      // When we need the task's return value, we query its Result property:
      // If it's still executing, the current thread will now block (wait)
      // until the task finishes:
      string result = task.Result;
    }
    static string DownloadString (string uri)
    {
      using (var wc = new System.Net.WebClient())
        return wc.DownloadString (uri);
    }

当我们查询任务的Result属性时，未处理的异常会被封装在AggregateException中自动重新抛出。然而，如果我们查询其Result属性失败（并且没有调用Wait），未处理的异常会使得进程结束。

任务并行库具有更多的特性，并且非常适合于多核处理器。我们会在下一章中重新讨论TPL。

无需TPL进入线程池
~~~~~~~~~~~~~~~~~

如果我们在使用.NET框架4.0以前的版本，我们不能使用任务并行库。相反，我们必须一种老式的构建进入线程池：ThreadPool.QueueUserWorkItem与异步委托。这两者之间的不同在于异步委托可以让我们由线程中返回数据。同时异步委托还可以将异常发送回调用者。

**QueueUserWorkItem**

要使用QueueUserWorkItem，仅需要简单的使用我们希望在池化的线程上运行的委托来调用该方法：

.. code:: csharp

    static void Main()
    {
      ThreadPool.QueueUserWorkItem (Go);
      ThreadPool.QueueUserWorkItem (Go, 123);
      Console.ReadLine();
    }
    static void Go (object data)   // data will be null with the first call.
    {
      Console.WriteLine ("Hello from the thread pool! " + data);
    }
    // Output:
    Hello from the thread pool!
    Hello from the thread pool! 123

我们的目标方法，Go，必须接受一个object参数（来指定WaitCallback委托）。这提供了一种向方法传递数据的合适方式，类似于ParameterizedThreadStart。与Task不同，QueueUserWorkItem并不会返回一个对象来帮助我们在后续管理异常。同时，我们必须在目标代码中显示处理异常－未处理的异常会结束程序。

**异步委托**

ThreadPool.QueueUserWorkItem并没有为在线程结束执行之后由线程中返回值的简单机制。异步委托解决了这一问题，可以允许在两个方向传递任意数量的类型参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，调用EndInvoke的线程），所以他们不需要显示处理。

下面是我们如何通过异步委托启动一个工作任务：

#. 实例化一个致力于我们希望并行运行的方法的委托（通常是一个预定义的Func委托）。
#. 在该委托上调用BeginInvokde，保存其IAsyncResult返回值。BeginInvokde会向调用者立即返回。当池化的线程正在工作时，我们可以执行其他的动作。
#. 当我们需要结果时，在委托上调用EndInvokde，传递所保存的IAsyncResult对象。

在下面的示例中，我们使用一个异步委托调用在主线程中并行执行，这仅是一个返回字行串长度的简单方法：

.. code:: csharp

    static void Main()
    {
      Func<string, int> method = Work;
      IAsyncResult cookie = method.BeginInvoke ("test", null, null);
      //
      // ... here's where we can do other work in parallel...
      //
      int result = method.EndInvoke (cookie);
      Console.WriteLine ("String length is: " + result);
    }
    static int Work (string s) { return s.Length; }

EndInvoke完成三件事。首先，如果异步委托还没有结束，他会等待异步委托完成执行。其次，他会接收返回值（同时ref或是out参数）。第三，他会向调用线程抛出未处理的异常。

当调用BeginInvokde时我们也可以指定一个回调委托－在完成时会被自动调用的接受IAsyncResult对象的方法。这会使得线程忘记异步委托，但是这需要在回调端做一些其他的工作：

.. code:: csharp

    static void Main()
    {
      Func<string, int> method = Work;
      method.BeginInvoke ("test", Done, method);
      // ...
      //
    }
    static int Work (string s) { return s.Length; }
    static void Done (IAsyncResult cookie)
    {
      var target = (Func<string, int>) cookie.AsyncState;
      int result = target.EndInvoke (cookie);
      Console.WriteLine ("String length is: " + result);
    }

BeginInvoke的最后一个参数是填充IAsyncResult的AsyncState属性的用户状态对象。他可以包含我们希望的任何事情；在这个示例中，我们向完成回调传递方法委托，从而我们可以其上调用EndInvokde。

优化线程池
~~~~~~~~~~

线程池初始时其池内有一个线程。随着任务的分配，线程池管理管理所插入的处理额外的并行工作的新线程，直到最大的限制。在足够的非活动周期之后，线程池管理器也主行会收回某些线程。

我们可以通过调用ThreadPool.SetMaxThreads方法来设置线程池可以创建的线程上限；默认如下：

-  在框架4.0 32位环境下为1023
-  在框架4.0 64位环境下为32768
-  在框架3.5下每个核心250
-  在框架2.0下每个核心25

我们也可以通过ThreadPool.SetMinThreads设置下限。下限的角色比较微妙：他是一种高级的优化技术，他可以指示线程池管理器在达到下限之前不要延迟线程的分配。当存在阻塞线程时，提高最小线程计数可以改善程序并发性。

同步
----

到目前为止，我们已经描述了如何在线程上启动任务、配置线程以及在两个方向上传递数据。同时我们还描述了局部变量对于线程来说如何是私有的，以及引用如何在线程之间共享从而使其通过普通域进行通信。

下一步是同步：为某个可预知的结果组合线程的动作。当线程访问相同的数据时，同步尤其重要。

同步结构可以分为四种类别：

-  简单的阻塞方法

这些方法会等待其他线程结束或是等待一段时间。Sleep，Join与Task.Wait都是简单的阻塞方法。

-  锁结构

这限制了每次可以执行某些动作或是执行代码段的线程数目。排他锁结构是最常见的－每次只允许一个线程，从而可以使得竞争线程访问共同的数据而不会彼此干扰。标准的排他锁结构是lock（Monitor.Enter/Monitor.Exit），Mutex与SpinLock。非排他锁结构是Semaphore，SemaphoreSlim与ReaderWriterLockSlim（我们会本章稍后的内容中讨论读写锁）。

-  信号结构

这可以使得一个线程暂停，直到接收到另一个线程的通知，从而避免低效轮询的需要。有两种经常使用的信号设备：事件等待处理与Monitor的Wait/Pluse方法。框架4.0引入了CountdownEvent与Barrier类。

-  非阻塞同步结构

这些方法通过访问处理器来保护对共同域的访问。CLR与C#提供了下列非阻塞结构：Thread.MemoryBarrier，Thread.VolatileRead，Thread.VolatileWrite，volatile关键字，以及Interlocked类。

让我们简要探讨这些概念。

阻塞
~~~~

当线程的执行由于某些原因被暂停，例如Sleep或是通过Join与EndInvoke方法等待其他结束的结束时，则称此线程被阻塞。被阻塞的线程会立即让出其处理器时间片，并且从此不再消耗处理器时间，直到阻塞条件被满足。我们可以通过其ThreadState属性来测试一个线程是否被阻塞：

当一个线程被阻塞或是解除阻塞时，操作系统会执行环境切换。这会花费几毫秒的时间。

Blocking Versus Spinning
~~~~~~~~~~~~~~~~~~~~~~~~

有时一个线程必须被暂停直到满足特定的条件。信号与锁结构通过在条件满足之间阻塞来实现该目的。然而，还有一种更为简单的方法：线程可以通过在一个轮询循环内自旋来等待满足的条件。例如：

while (!proceed);

或者：

while (DateTime.Now < nextStartTime);

通常，这非常浪费处理器的时间：正如CLR与操作系统所关注的，线程正在执行重要的计算，从而获得相应的分配资源。

有时会使用阻塞与自旋锁的组合：

while (!proceed) Thread.Sleep (10);

尽管并不优雅，但是这比仅用自旋锁更高效。然而这也会出现问题，这是由proceed标志上的并行处理所引起的。正确的使用阻塞与信号会避免这些问题。

锁
--

排他锁用来保证一次只有一个线程进入特定的代码部分。两种主要的排他锁结构是lock与Mutex。在这两者之间，lock结构速度更快且更为方便。然而，Mutex可以使得其锁跨越计算机上不同进程之间中的多个程序。

在本节中，我们将会由lock结构开始，然后探讨Mutex与信号号。在本章的稍后我们会探讨读写锁。

让我们由下面的类开始：

.. code:: csharp

    class ThreadUnsafe
    {
      static int _val1 = 1, _val2 = 1;
      static void Go()
      {
        if (_val2 != 0) Console.WriteLine (_val1 / _val2);
        _val2 = 0;
      }
    }

这个类并不是线程安全的：如果Go为两个线程同时调用，则可能会得到一个除零错误，因为在一个线程执行到if语句与Console.WriteLine语句之间时，另一个线程会将\_val2设置为0。

下面显示了lock如何来解决这一问题：

.. code:: csharp

    class ThreadSafe
    {
      static readonly object _locker = new object();
      static int _val1, _val2;
      static void Go()
      {
        lock (_locker)
        {
          if (_val2 != 0) Console.WriteLine (_val1 / _val2);
          _val2 = 0;
        }
      }
    }

每次只有一个线程可以锁定同步对象，并且在锁被释放之前其他的竞争线程会被阻塞。如果有多个线程在竞争锁，他们会在一个“只读队列”中进行排除，并且遵循先到先服务的原则。排他锁有时被称之为强制对锁保护的内容进行顺序访问，因为一个线程的访问不能与另一个线程相重叠。在这个例子中，我们在Go方法内部保护逻辑，也就是\_val1与\_val2域。

等待竞争锁的阻塞线程具有WaitSleepJoin的ThreadState。稍后我们会描述阻塞线程如何通过其他线程进行强制释放。这是一种用于结束线程的重要技术。

Monitor.Enter与Monitor.Exit
~~~~~~~~~~~~~~~~~~~~~~~~~~~

事实上，C#的lock语句是对具有try/finally块的Monitor.Enter与Monitor.Exit方法调用的语法缩写。下面是在前面示例中的Go方法内部所发生的事情（简化版本）：

.. code:: csharp

    Monitor.Enter (_locker);
    try
    {
      if (_val2 != 0) Console.WriteLine (_val1 / _val2);
      _val2 = 0;
    }
    finally { Monitor.Exit (_locker); }

在同一个对象上没有首先调用Monitor.Enter而调用Monitor.Exit会抛出一个异常。

**lockTaken重载**

我们刚刚所描述的代码是C#1.0、2.0与3.0在翻译lock语句时所引入的代码。

然而上述的代码有一个致命的弱点。假定在Monitor.Enter的实现内部或者在Monitor.Enter调用与try块之间抛出异常的事件。在这样的场景下，锁有可能获得也有可能没有获得。如果获得了锁，则该锁就不会被释放－因为我们永远不会进入try/finally块。这会导致泄漏锁。

为了避免这种危险，CLR4.0的设计者为Monitor.Enter添加了下面的重载：

public static void Enter (object obj, ref bool lockTaken);

如果（当且仅当）Enter方法抛出异常，在此方法之后lockTaken为假，而不会获得锁。

下面是正确的使用模式：

.. code:: csharp

    bool lockTaken = false;
    try
    {
      Monitor.Enter (_locker, ref lockTaken);
      // Do your stuff...
    }
    finally { if (lockTaken) Monitor.Exit (_locker); }

**TryEnter**

Monitor同时提供了一个TryEnter方法，从而允许以毫秒或是TimeSpan的方式指定超时时间。如果获得锁，该方法会返回true，而如果由于方法超时没有获得锁则会返回false。TryEnter也可以以无参数的形式进行调用，这会对锁进行测试，如果不能立即获得锁则会立即超时。

类似于Enter方法，该方法在CLR 4.0中也被重载来接受lockTaken参数。

选择同步对象
~~~~~~~~~~~~

任何对于参与线程可见的对象都可以用作同步对象，但有一个硬性规定：同步对象必须为引用类型。同步对象通常是私有的（因为有这有助于封装锁逻辑），并且通常是一个实例或是一个静态域。同步对象可以多于他所保护的对象，如下列示例中的\_list域：

.. code:: csharp

    class ThreadSafe
    {
      List <string> _list = new List <string>();
      void Test()
      {
        lock (_list)
        {
          _list.Add ("Item 1");
          ...

用于这种锁目的的域（例如前面示例中的\_locker）可以在锁的作用域与粒度上进行精确控制。包含对象（this）或者其类型都可以用作同步对象：

lock (this) { ... }

或是：

lock (typeof (Widget)) { ... } // For protecting access to statics

这种锁方式的缺点在于我们并没有封装锁逻辑，从而较难避免死锁与额外的阻塞。类型上的锁也会在应用域边界之间渗透。

我们也可以在Lambda表达或是匿名方法所捕获的局部变量上加锁。

何时加锁
~~~~~~~~

作为一条基本原则，我们需要在访问任何可写的共享域时加锁。即使是在最简单的情况－对单个域的赋值操作－我们都必须考虑同步。在下面的类中，Increment与Assign方法都不是线程安全的：

.. code:: csharp

    class ThreadUnsafe
    {
      static int _x;
      static void Increment() { _x++; }
      static void Assign()    { _x = 123; }
    }

下面是Increment与Assign的线程安全版本：

.. code:: csharp

    class ThreadSafe
    {
      static readonly object _locker = new object();
      static int _x;
      static void Increment() { lock (_locker) _x++; }
      static void Assign()    { lock (_locker) _x = 123; }
    }

锁与原子性
~~~~~~~~~~

如果一组变量总是在相同的块内进行读写，我们就可以称这组变量是原子性读写。让我们假定域x与y总是在对象locker上的lock内进行读取与赋值：

lock (locker) { if (x != 0) y /= x; }

我们就可以说x与y是原子性访问的，因为上面的代码块不能为其他的线程分割。如果x与y总是在相同的排他锁中进行访问，我们就不会得到除零错误。

指令原子性则不同，尽管是相似的概念：如果指令不可分割的在底层处理器上运行，则该指令是原子的。

嵌套锁
~~~~~~

线程可以以嵌套的方式重复锁住相同的对象：

.. code:: csharp

    lock (locker)
      lock (locker)
        lock (locker)
        {
           // Do something...
        }

或是：

.. code:: csharp

    Monitor.Enter (locker); Monitor.Enter (locker);  Monitor.Enter (locker);
    // Do something...
    Monitor.Exit (locker);  Monitor.Exit (locker);   Monitor.Exit (locker);

在这样的场景中，只有当最外层的lock语句退出时，对象才会被解锁－或是执行了匹配数目的Monitor.Exit语句。

当一个方法在锁中调用另一个方法时，嵌套锁将会十分有用：

.. code:: csharp

    static readonly object _locker = new object();
    static void Main()
    {
      lock (_locker)
      {
         AnotherMethod();
         // We still have the lock - because locks are reentrant.
      }
    }
    static void AnotherMethod()
    {
      lock (_locker) { Console.WriteLine ("Another method"); }
    }

线程只有在第一个锁处阻塞。

死锁
~~~~

当两个线程彼此等待为另一个线程所占用的资源时会发生死锁，从而任何一个线程都不会执行。演示死锁最简单的方法就是使用两个锁：

.. code:: csharp

    object locker1 = new object();
    object locker2 = new object();
     
    new Thread (() => {
                        lock (locker1)
                        {
                          Thread.Sleep (1000);
                          lock (locker2);      // Deadlock
                        }
                      }).Start();
    lock (locker2)
    {
      Thread.Sleep (1000);
      lock (locker1);                          // Deadlock
    }

使用三个或是更多的线程可以创建死锁链。

死锁是多线程中最难的问题之一，特别有多个相关的对象时。基本来说，困难在于我们不能确定我们的调用者已经获得了哪些锁。

所以，我们可能会锁信类x中的私有域a，而并不知道我们的调用者已经锁住了类y中的域b。同时，另一个线程正在执行相反的操作－创建死锁。具有讽刺意味的是，这种问题会由于面向对象的设计模式而加剧，因为这些模式创建了直到运行时才会确定的调用链。

流行的建议，“以相同的顺序锁住对象以避免死锁”，尽管有助于我们开始时的示例，但是很难应用到我们刚才所描述的场景。更好的策略是小心那些在对象中调用会引用我们自射对象的方法。同时考虑我们是否真的需要锁住其他类中的方法调用。更多的依赖于声明与数据并行，不可变类型与非阻塞的同步结构可以减少锁的需要。

另一个死锁的场景出现在我们调用Dispatcher.Invoke（在WPF程序中）或是Control.Invoke（在Windows
Forms程序中）同时占有一个锁。如果UI恰好要运行等待相同的锁的另一个方法，就会这里发生死锁。这通常可以通过调用BegionInvoke而不是Invoke进行简单的修正。或者，我们可以在调用Invoke之前释放我们的锁，尽管如果我们的调用者占用锁这种方法并不会起作用。

性能
~~~~

锁速度很快：如果我们的锁不是竞争锁，我们可以期望在2010年代的计算机上以小于100纳秒的时间获得与释放锁。如果是竞争锁，相应的环境切换会接近毫秒级别，尽管这在线程真正被重新调度之前会更长。我们可以稍后章节中所描述的SpinLock类来避免环境切换的代价。

如果我们过多使用，锁会通过使得其他线程进行不必要的等待而降低并行性。同时这也会增加死锁的机会。

Mutex
~~~~~

Mutex类似于C#的lock，但是他可以跨越多个进程工作。换句话说，Mutex可以是计算域也可以是程序域。

对于Mutex类，我们可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或是销毁Mutex会自动释放锁。类似于lock语句，Mutex只能由获得该Mutex的相同线程释放。

跨进程Mutex的一个通常应用就是确保一次只能运行一个程序实例。下面演示了这是如何实现的：

.. code:: csharp

    class OneAtATimePlease
    {
      static void Main()
      {
        // Naming a Mutex makes it available computer-wide. Use a name that's
        // unique to your company and application (e.g., include your URL).
        using (var mutex = new Mutex (false, "oreilly.com OneAtATimeDemo"))
        {
          // Wait a few seconds if contended, in case another instance
          // of the program is still in the process of shutting down.
          if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))
          {
            Console.WriteLine ("Another instance of the app is running. Bye!");
            return;
          }
          RunProgram();
        }
      }
      static void RunProgram()
      {
        Console.WriteLine ("Running. Press Enter to exit");
        Console.ReadLine();
      }
    }

Semaphore
~~~~~~~~~

信号量类似于一个夜总会：他具有一定的容量，并且有保安把守。一旦满员，则不允许其他人进入，并且在外部随队。然后，对于离开的每一个人，则排在队列前头的人可以进入。这种结构需要两个参数：当前夜总会中可用的位置数以及夜总会的总容量。

具有容量的信号量类似于Mutex或lock，所不同的是信号量没有拥有者。任何线程都可以在Semaphore上调用Release，而对于Mutex与lock，只有获得锁的线程可以释放。

信号量在有限制的并行中非常有用－可以阻止过多的线程同时执行特定的代码段。在下面的示例中，五个线程尝试进入一次只允许三个线程进入的夜总会：

.. code:: csharp

    class TheClub      // No door lists!
    {
      static SemaphoreSlim _sem = new SemaphoreSlim (3);    // Capacity of 3
      static void Main()
      {
        for (int i = 1; i <= 5; i++) new Thread (Enter).Start (i);
      }
      static void Enter (object id)
      {
        Console.WriteLine (id + " wants to enter");
        _sem.Wait();
        Console.WriteLine (id + " is in!");           // Only three threads
        Thread.Sleep (1000 * (int) id);               // can be here at
        Console.WriteLine (id + " is leaving");       // a time.
        _sem.Release();
      }
    }
    1 wants to enter
    1 is in!
    2 wants to enter
    2 is in!
    3 wants to enter
    3 is in!
    4 wants to enter
    5 wants to enter
    1 is leaving
    4 is in!
    2 is leaving
    5 is in!

如果Sleep语句被替换为磁盘IO操作，Seamphore通过限制过多的并行磁盘操作可以改善整体性能。

类似于Mutex，Seamphore也可以跨越多个进程。

线程安全
--------

如果一个程序或是方法在任意的多线程场景中没有不确定性，则称该线程或方法是线程安全的。线程安全主要是通过锁以及减少线程交互的可能性来实现的。线程安全主要是通过锁与减少线程交互的可能性来实现的。

通用类型很少在其整个生命周期内是线程安全的，原因如下：

-  完全线程安全的开发负担非常繁重，特别是如果一个类型有多个域时
-  线程安全是导致性能损耗
-  线程安全的类型并不一定会保证使用该类型的程序线程安全，并且后者所涉及的问题会使得前者变得多余。

所以线程安全通常只会在需要时实现，为了处理特定的多线程场景。

然而，有多种方法来欺骗并使得大而复杂的类在多线程环境中安全运行。一种方法是通过牺牲粒度将大的代码段－甚至访问整个对象－封装在一个排他锁内，从而在高层次上保证序列化访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码时（或绝大多数的框架类型）时，这种策略是十分必要的。这种技巧只是简单的使用相同的排他锁来保护对线程不安全对象上所有属性、方法与域的访问。这种解决方案适用于对象的所有方法都会快速执行（否则会导致大量的阻塞）。

另一种欺骗的方法就是通过减少共享数据来减少线程交互。这是一种优秀的方法并且隐式的用在无状态的中间层程序与web页面服务器中。因为多个客户端请求可以同时到达，所有他们所请求的服务器方法必须是安全的。无状态设计（由于扩展性需求）本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。然后线程交互仅被限制为我们也许会选择创建的静态域，这种方法就如同在内存中缓存经常用到的数据以及提供如验证这样的基础服务等。

实现线程安全的最后一种策略就是使用自动锁机制。如果我们继承ContextBoundObject并且在类上应用Synchronization属性时.则NET框架所采用的就是这种方法。然后当该对象上的方法或是属性被调用时，一个对象粒度的锁就会自动用于整个方法或是属性的执行。尽管这减少了线程安全的负担，但是他有其自己的问题：死锁、降低并发性以及不可预料的重新进入。正是由于这些原因，手动加锁通常是更好的选择。

线程安全与.NET框架类型
~~~~~~~~~~~~~~~~~~~~~~

锁可以用来将线程不安全的代码转换为线程安全的代码。这种机制的一个良好应用就是.NET框架：当实例化时，几乎其所有的非基础类型都不是线程安全的，然而如果对指定对象的所有访问都通过锁进行保护，则他们就可以用于多线程代码中。例如，当两个线程同时向相同的List集合中添加对象时，然后枚举列表：

.. code:: csharp

    class ThreadSafe
    {
      static List <string> _list = new List <string>();
      static void Main()
      {
        new Thread (AddItem).Start();
      }
      static void AddItem()
      {
        lock (_list) _list.Add ("Item " + _list.Count);
        string[] items;
        lock (_list) items = _list.ToArray();
        foreach (string s in items) Console.WriteLine (s);
      }
    }

在这个示例中，我们在\_list对象本身上加锁。如果我们有两个彼此相关的列表，我们需要依据要加锁的列表选择一个共同的对象（我们可以使用其中一个列表，或者更好的是使用独立的域）。

枚举.NET集合也是线程不安全的，如果在枚举的过程中列表被修改则会抛出异常。在这个示例中，我们并没有将整个枚举过程加锁，而是首先将其中对象拷贝到一个数组中。如果我们在枚举过程中的操作很耗时，这样可以避免过多的持有锁。（另一种解决方案是使用读写锁）

**为线程安全对象加锁**

我们同时需要为访问线程安全的对象加锁。为了进行演示，考虑框架的List类，该类确实是线程安全的，而我们希望向列表中添加一个新对象：

if (!\_list.Contains (newItem)) \_list.Add (newItem);

无论列表是否是线程安全的，上面的语句都不是线程安全的。为了防止关系测试与添加新对象之间的抢占，整个if语句需要封装在一个锁中。然后相同的锁需要用在我们修改列表的所有地方。例如，下面的语句也需要封装在一个相同的锁中：

\_list.Clear();

来确保他不会抢占前面的语句。换句话说，我们需要精确锁住线程非安全的集合类。

**静态方法**

将对对象的访问封装在一个自定义锁中只适用于使用该锁的所有并发线程。如果对象具有更宽的作用域则不适用。最糟糕的情况就是公开类型中的静态方法。例如，假定如果DateTime结构上的静态属性，DateTime.Now，不是线程安全的，则两个并发线程调用会导致垃圾输出或是异常。使用外部锁进行修正的唯一方法就是在调用DateTime.Now之前锁住类型本身-lock(typeof(DateTime))。这仅适用于所有的程序员都同意这样做。而且，锁住类型本身也有其自身的问题。

由于这一原因，DateTime结构的静态成员已经进行了细心的编程使其是线程安全的。这在.NET框架中是一个常见的模式：静态成员是线程安全的；实例成员则不是。遵循这一原则，编写公用的类型而不是创建不可能的线程安全难题也是有道理的。

**只读线程安全**

使得并行只读访问成为类型线程安全是有利的，因为这意味着消费者可以避免排他锁。许多.NET框架类型遵循这一原则：例如，集合对于并行读取者是线程安全的。

我们遵循这一愿则也很简单：如果我们希望一个类型对于并行只读访问是线程安全的，不要在消费者期望是只读的方法内写入域。例如，在集合中实现ToArray()方法中，我们也许会由整理集合的内部结构开始。然而，这会使得其对于期望该方法是只读的消费来说是非线程安全的。

只读线程安全也是枚举器不同于“可枚举”的原因之一：两个线程可以在一个集合上同时进行枚举，因为每一个都会获得单独的枚举器。

应用服务器中的线程安全
~~~~~~~~~~~~~~~~~~~~~~

应用服务器需要多线程化来处理并行的客户请求。WCF，ASP.NET与Web
Services应用是隐式多线程的；对于使用网络隧道，如TCP或HTTP的远程服务器应用也是如此。这意味着当在服务器端编写代码时，如果存在处理客户请求的线程之间交互时，我们必须考虑线程安全性。幸运的是，这样的可能性很少出现；一个典型的服务器类或者是无状态的（没有域），或者具有为每个客户或请求创建单独对象实例的激活模式。交互通常只在静态域中出现，有时用于数据库部分的内存缓存以改善性能。

例如，假定我们有一个查询数据库的RetrieveUser方法：

.. code:: csharp

    // User is a custom class with fields for user data
    internal User RetrieveUser (int id) { ... }

如果这个方法被频繁调用，我们可以通过将结果缓存在一个静态的Dictionary中来改善性能。下面是一个考虑线程安全的解决方案：

.. code:: csharp

    static class UserCache
    {
      static Dictionary <int, User> _users = new Dictionary <int, User>();
      internal static User GetUser (int id)
      {
        User u = null;
        lock (_users)
          if (_users.TryGetValue (id, out u))
            return u;
        u = RetrieveUser (id);           // Method to retrieve from database;
        lock (_users) _users [id] = u;
        return u;
      }
    }

我们必须至少要在读取与更新字典时加锁来保证线程安全。在这个示例中，我们在加锁的简单与性能之间选择了一个实际的平衡。实际上我们的设计略有一些效率的问题：如果两个线程同时使用之前并未获取的id来调用该方法，RetrieveUser方法就会被调用两次－而字典就会进行不必要的更新。对整个方法加锁会避免这一问题，但是会出现更糟的效率问题：在调用RetrieveUser的期间整个缓存被加锁，在这段时间内，其他的线程会被阻塞。

富客户端应用与线程安全
~~~~~~~~~~~~~~~~~~~~~~

WPF与Windows
Forms库都遵循基于线程关系的模型。尽管每一个都具有单独的实现，但是他们在作用原理上非常相似。

构成富客户端的对象主要基于WPF情况下的DependencyObject或是Windows
Forms情况下的Control。这些对象具有线程关系，这意味着只有实例化这些对象的线程才能在稍后访问其成员。违反这一原则或者会引起不可预料的行为，或者是抛出异常。

好的一面时，这意味着我们在访问UI对象时并不需要加锁。坏的一面则是，如果我们希望调用在线程Y上所创建的对象X的成员，我们必须将请求转换为线程Y。我们通过下列方法显式实现：

-  在WPF中，在元素的Dispatcher对象上调用Invoke或是BeginInvoke。
-  在Windows Forms中，在控件上调用Invoke或是BeginInvoke。

Invoke与BeginInvoke都接受一个委托，引用我们希望运行的目标控件上的方法。Invoke同步执行：调用者会阻塞，直到转换完成。BeginInvoke异步执行：调用者会立即返回，而转换的请求会进入队列（使用与处理键盘，鼠标与计时器事件相同的消息队列）。

假定我们有一个包含名为txtMessage的文本框，我们希望一个工作线程更新其内容，下面是一个WPF示例：

.. code:: csharp

    public partial class MyWindow : Window
    {
      public MyWindow()
      {
        InitializeComponent();
        new Thread (Work).Start();
      }
      void Work()
      {
        Thread.Sleep (5000);           // Simulate time-consuming task
        UpdateMessage ("The answer");
      }
      void UpdateMessage (string message)
      {
        Action action = () => txtMessage.Text = message;
        Dispatcher.Invoke (action);
      }
    }

对于Windows Form代码类似，所不同的是我们调用Form的Invoke方法：

.. code:: csharp

      void UpdateMessage (string message)
      {
        Action action = () => txtMessage.Text = message;
        this.Invoke (action);
      }

**工作线程与UI线程**

将一个富客户端应用看作有两个不同的线程类型是很有益的：UI线程与工作线程。UI线程实例化UI元素；工作线程则不会。工作线程通常执行常时间任务，如获取数据。

大多数的富客户端应用有一个单独的UI线程并不时产生工作线程－直接产生或是使用BackgroundWorker。为了更新控件或是报告进程，这些工作线程会转换为主UI线程。

那么一个应用何时会有多个UI线程呢？主要的应用场景是当我们有一个具有多个顶级窗口的应用时，通常被称为单文档界面（SDI）程序，例如Microsoft
Word。每个SDI窗口通常会在任务栏上显示为单独的程序，并且大多数在功能上与其他的SDI窗口相独立。通过为每一个这样的窗口指定一个单独的UI线程，应用可以进行更好的响应。

不可更改的对象
~~~~~~~~~~~~~~

不可修改的对象其状态不能在外部或内部被修改。不可修改对象内的域通常被声明为只读的，并且是在构造过程中被完全初始化的。

不可修改性是函数式编程的一个特点－与其相对的是可修改的对象，我们可以使用不同的属性创建一个新的对象。LINQ使用这种范式。不可修改性在多线程中也很有价值，因为他通过消除（或是最小化）可写性来避免可写状态的问题。

使用不可修改对象的一个模式是封装一组相关的域来最小化锁的时长。为了使用一个简单的示例，假定我们有如下的两个域：

.. code:: csharp

    int _percentComplete;
    string _statusMessage;

而我们希望对其进行原子性的读/写。我们并不需要将这些域进行加锁，相反我们可以定义如下的不可修改类：

.. code:: csharp

    class ProgressStatus    // Represents progress of some activity
    {
      public readonly int PercentComplete;
      public readonly string StatusMessage;
      // This class might have many more fields...
      public ProgressStatus (int percentComplete, string statusMessage)
      {
        PercentComplete = percentComplete;
        StatusMessage = statusMessage;
      }
    }

然后我们可以定义该类型的一个域以及一个锁对象：

.. code:: csharp

    readonly object _statusLocker = new object();
    ProgressStatus _status;

现在我们可以读取该类型的值而不需要锁定多个单一的赋值：

.. code:: csharp

    var status = new ProgressStatus (50, "Working on it");
    // Imagine we were assigning many more fields...
    // ...
    lock (_statusLocker) _status = status;    // Very brief lock

要读取该对象，我们首先获取该对象的一个拷贝（在锁内）。然后我们可以读取其值而不需要加锁：

.. code:: csharp

    ProgressStatus status;
    lock (_locker ProgressStatus) status = _status;   // Again, a brief lock
    int pc = statusCopy.PercentComplete;
    string msg = statusCopy.StatusMessage;

注意这种无锁的方法避免了一组相关域内的不一致性。但是他并没有避免我们后续操作时的数据修改，因此，我们通常需要锁。在第22章中，我们将会看到使用不可修改性来简化多线程的更多示例，包括PLINQ。

非阻塞同步
----------

读/写锁
-------

通常，类型的实例对于并行的读操作是线程安全的，但是对于并行的更新操作则不是线程安全的（对于并行的读取与更新操作也不是线程安全的）。对于如文件这样的资源也是如此。尽管使用一个适用于所有访问模式的简单的排他锁对该类型的实例进行保护是常用到的一个小技巧，如果有多个读取操作而仅有少量的更新操作，则这种限制并发性的技巧并不合理。这种应用场景也许会出现在业务程序服务器上，其中经常用到的数据会被缓存在静态域中以进行快速获取。ReaderWriterLockSlim类被设计用来为此种应用场景提供最大的可用锁。

对于这些类，有两种基本的锁类型－读锁与写锁：

-  写锁通常是排他的
-  读锁可以与其他的读锁兼容

所以，持有写锁的线程会阻塞尝试获取读锁或写锁的其他线程。但是如果没有线程持有写锁，任意数量的线程可以同时获得读锁。

ReaderWriterLockSlim定义了下面的方法用来获取与释放读/写锁：

.. code:: csharp

    public void EnterReadLock();
    public void ExitReadLock();
    public void EnterWriteLock();
    public void ExitWriteLock();

另外，所有的EnterXXX方法还有一个Try版本来接受Monitor.TryEnter风格的超时参数。ReaderWriterLock提供了类似的方法，名为AcquireXXX与ReleaseXXX。如果超时，这些方法会抛出ApplicationException，而不是返回false。

下列程序演示了ReaderWriterLockSlim。三个线程连续枚举一个列表，而另外两个线程每秒向列表添加一个随机数字。读锁保护列表读取器，而写锁保护列表写入器：

.. code:: csharp

    class SlimDemo
    {
      static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();
      static List<int> _items = new List<int>();
      static Random _rand = new Random();
      static void Main()
      {
        new Thread (Read).Start();
        new Thread (Read).Start();
        new Thread (Read).Start();
        new Thread (Write).Start ("A");
        new Thread (Write).Start ("B");
      }
      static void Read()
      {
        while (true)
        {
          _rw.EnterReadLock();
          foreach (int i in _items) Thread.Sleep (10);
          _rw.ExitReadLock();
        }
      }
      static void Write (object threadID)
      {
        while (true)
        {
          int newNumber = GetRandNum (100);
          _rw.EnterWriteLock();
          _items.Add (newNumber);
          _rw.ExitWriteLock();
          Console.WriteLine ("Thread " + threadID + " added " + newNumber);
          Thread.Sleep (100);
        }
      }
      static int GetRandNum (int max) { lock (_rand) return _rand.Next(max); }
    }

下面为输出结果：

.. code:: text

    Thread B added 61
    Thread A added 83
    Thread B added 55
    Thread A added 33
    ...

ReaderWriterLockSlim要比一个简单锁允许更多的并发Read活动。我们可以通过在while循环的起始处的Write方法中插入下列代码来演示：

Console.WriteLine (\_rw.CurrentReadCount + " concurrent readers");

这几乎总是输出“3 concurrent
readers”。除了CurrentReadCount，ReaderWriterLockSlim还提供了下列属性用于监视锁：

.. code:: csharp

    public bool IsReadLockHeld            { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld           { get; }
    public int  WaitingReadCount          { get; }
    public int  WaitingUpgradeCount       { get; }
    public int  WaitingWriteCount         { get; }
    public int  RecursiveReadCount        { get; }
    public int  RecursiveUpgradeCount     { get; }
    public int  RecursiveWriteCount       { get; }

可更新的锁与递归
~~~~~~~~~~~~~~~~

有时在单一的原子操作中为写锁封装一个读锁是很用的。例如，假定我们只希望在列表中没有某个元素时向列表添加该元素。确实，我们希望最小化在写锁上所花的时间，所以我们可以进行如下处理：

#. 获取一个读锁
#. 测试某项是否位于列表中，如果存在，释放锁并返回
#. 释放读锁
#. 获取一个写锁
#. 添加该项

问题在于另一个线程也许会在步骤3与4之间插入并修改列表。ReaderWriterLockSlim通过一个名为可更新锁的第三种锁来解决这一问题。可更新的锁类似于读锁，所不同的他可以在稍后的原子操作中提升为写锁。下面是我们的用法：

#. 调用EnterUpgradeableReadLock
#. 执行读操作
#. 调用EnterWriteLock（这会将可更新锁转换为写锁）
#. 执行写操作
#. 调用ExitWriteLock（这会将写锁转换为读锁）
#. 执行其他的读操作
#. 调用ExitUpgradeableReadLock

由调用者的角度来看，这类似于嵌入锁或是递归锁。然而在第3步中，ReaderWriterLockSlim在原子操作中释放了我们的读锁并获取了一个新锁。

在可更新锁与读锁之间还有另一个重要区别。可更新锁可以与任意数量的读锁共存，但是很次只能有一个可更新锁起作用。这可以防止死锁的出现。

我们可以通过修改前面示例中的Write方法从而只在某个元素在列表中不存在时添加该元素来演示可更新锁：

.. code:: csharp

    while (true)
    {
      int newNumber = GetRandNum (100);
      _rw.EnterUpgradeableReadLock();
      if (!_items.Contains (newNumber))
      {
        _rw.EnterWriteLock();
        _items.Add (newNumber);
        _rw.ExitWriteLock();
        Console.WriteLine ("Thread " + threadID + " added " + newNumber);
      }
      _rw.ExitUpgradeableReadLock();
      Thread.Sleep (100);
    }

**递归加锁**

相应的，嵌入或是递归锁是为ReaderWriterLockSlim所禁止的。所以下面的代码会抛出异常：

.. code:: csharp

    var rw = new ReaderWriterLockSlim();
    rw.EnterReadLock();
    rw.EnterReadLock();
    rw.ExitReadLock();
    rw.ExitReadLock();

然而如果我们使用下面的代码为构造ReaderWriterLockSlim则不会出现运行错误：

var rw = new ReaderWriterLockSlim
(LockRecursionPolicy.SupportsRecursion);

这可以保证递归锁只在我们特意的地方出现。递归锁会带来不必要的复杂性，因为很可能他会获取多种类型的锁：

.. code:: csharp

    rw.EnterWriteLock();
    rw.EnterReadLock();
    Console.WriteLine (rw.IsReadLockHeld);     // True
    Console.WriteLine (rw.IsWriteLockHeld);    // True
    rw.ExitReadLock();
    rw.ExitWriteLock();

基本原则就是一旦我们获取一个锁，接下来的递归锁应该更弱，而不是更强：

Read Lock→Upgradeable Lock→Write Lock

然而，将可更新锁提升为写锁的请求总是合法的。

计时器
------

如果我们需要在固定的时间间隔执行某个方法，最简单的方法就是使用计时器。与类似于下面代码所示的技术比起来，在其内存与资源的使用方法，计时器都是方便而高效的：

.. code:: csharp

    new Thread (delegate() {
                             while (enabled)
                             {
                               DoSomeAction();
                               Thread.Sleep (TimeSpan.FromHours (24));
                             }
                           }).Start();

上面的代码不仅会占用线程资源，而且如果没有额外的代码，DoSomeAction会在每天稍后一些的时间发生。计时器可以解决这些问题。

.NET框架提供了四种计时器。其中的两个是通用多线程的计时器：

-  System.Threading.Timer
-  System.Timers.Timer

其他两个是具有特殊用途的单线程计时器：

-  System.Windows.Forms.Timer（Windows窗体计时器）
-  System.Windows.Threading.DispatcherTimer（WPF计时器）

多线程计时器更强大，精确与灵活；单线程计时器对于运行更新Windows窗体控件或WPF元素这样的简单任务更为安全和方便。

多线程计时器
~~~~~~~~~~~~

System.Threading.Timer是最简单的多线程计时器：他只有一个构造函数与两个方法。在下面的示例中，计时器调用Tick方法，他会在五秒之后输出“tick...”，并在其后的每一秒输出，直到用户输入回车：

.. code:: csharp

    using System;
    using System.Threading;
    class Program
    {
      static void Main()
      {
        // First interval = 5000ms; subsequent intervals = 1000ms
        Timer tmr = new Timer (Tick, "tick...", 5000, 1000);
        Console.ReadLine();
        tmr.Dispose();         // This both stops the timer and cleans up.
      }
      static void Tick (object data)
      {
        // This runs on a pooled thread
        Console.WriteLine (data);          // Writes "tick..."
      }
    }

我们可以在稍后通过调用其Change方法来修改计时器的间隔。如果我们希望计时器仅触发一次，在构造函数中的最后一个参数指定Timeout.Infinite。

.NET框架在System.Timers名字空间中提供了另一个相同名字的计时器。这个计时器仅是简单的封装了System.Threading.Timer，为使用相同的底层引擎时提供了额外的方便。下面是其所添加特性的小结：

-  Component实现，允许其位于Visual Studio设计器中
-  Interval属性而不是Change方法
-  Elapsed事件而不是回调委托
-  Enabled属性来启动或停止计时器（默认值为false）
-  避免与Enabled相混淆的Start与Stop方法
-  表明重复事件的AutoReset标记（默认值为true）
-  用于在WPF元素与Windows窗体控件上使用Invoke与BeginInvoke调用的SynchronizingObject属性

下面是一个使用示例：

.. code:: csharp

    using System;
    using System.Timers;   // Timers namespace rather than Threading
    class SystemTimer
    {
      static void Main()
      {
        Timer tmr = new Timer();       // Doesn't require any args
        tmr.Interval = 500;
        tmr.Elapsed += tmr_Elapsed;    // Uses an event instead of a delegate
        tmr.Start();                   // Start the timer
        Console.ReadLine();
        tmr.Stop();                    // Stop the timer
        Console.ReadLine();
        tmr.Start();                   // Restart the timer
        Console.ReadLine();
        tmr.Dispose();                 // Permanently stop the timer
      }
      static void tmr_Elapsed (object sender, EventArgs e)
      {
        Console.WriteLine ("Tick");
      }
    }

多线程计时器使用线程池来允许少量线程承担多个计时器的任务。这意味着每次回调方法或Tick事件也许会在不同的线程上触发。而且，Tick总时及时触发－无论前一个Tick是否已经完成执行。所以，回调或是事件处理器必须是线程安全的。

多线程计时器的精度依赖于操作系统，而且通常位于10－20ms区域。如果我们需要更高的精度，我们可以使用本地交互并调用Windows多媒体计时器。这可以达到1ms的精度并且定义在winmm.dll中。首先调用timeBeginPeriod来通知操作系统我们需要较高的计时精度，然后调用timeSetEvent来启动一个多媒体计时器。当我们完成时，调用timeKillEvent来停止计时器与timeEndPeriod来通知操作系统我们不再需要更高的计时精度。第25章演示使用P/Invoke来调用外部方法。我们可以通过搜索关键字dllimport
winmm.dll timesetevent来查找关于使用多媒体计时器更为完整的例子。

单线程计时器
~~~~~~~~~~~~

.NET框架提供了为解决WPF与Windows窗体程序的线程安全问题而设计的计时器：

-  System.Windows.Threading.DispatcherTimer(WPF)
-  System.Windows.Forms.Timer(Windows Forms)

这两个计时器在其所提供的成员（Interval，Tick，Start与Stop）以及使用方式的类似上与System.Timers.Timer非常像。然而，其内部工作原则是完全不同的。WPF与Windows
Forms计时器器并不使用线程池来生成计时器事件，而是依赖其底层用户界面模型的消息机制。这意味着Tick事件总是在与创建计时器相同的线程上触发－在通常程序中，是与用来管理所有用户界面元素与控件的线程相同的线程。这有下列优点：

-  我们可以忘记线程安全性
-  在前面一个Tick完成处理之前不会触发新的Tick事件
-  我们可以直接由Tick事件处理代码中更新用户界面元素与控制，而无需调用Control.Invoke与Dispatcher.Invoke。

在我们意识到使用这些计时器的程序并不是真正的多线程程序之前－并没有并行执行，这听起来似乎不错。一个线程为所有的线程提供服务－同时处理UI事件。这会为我们带来单线程计时器的缺点：

-  除非Tick事件处理器快速执行完毕，否则用户界面会没有响应。

这使得WPF与Windows
Forms计时器仅适用于较小的工作，通常仅适用于更新用户界面的某些方面。否则，我们就需要一个多线程计时器。

在精度方面，单线程计时器类似于多线程计时器（几十毫秒），尽管这两个计时器精度更低，因为他们可以被其他的用户界面请求处理所延迟。

Chapter 22. Parallel Programming
================================

Chapter 23. Asynchronous Methods
================================

在21章中，我们看到了线程如何提供并行路径。我们会理所当然的认为无论何时我们需要并行运行某些任务，我们可以为该任务赋予一个新线程或是池化的线程。尽管这通常是正确的，但是仍有一些例外。假定我们正在编写一个需要处理1000个并发客户请求的TCP
Socket或是Web服务器程序。如果我们为每一个新到的请求使用一个线程，我们就会消耗G字节的内存。

异步方法通过一种模式来解决这些问题：该模型通过少量的池化线程来大量的并发活动。这使得编写高并发的程序以及线程高效的程序成为可能。

为了理解本章的内容，我们需要熟悉线程与流。

为什么存在异步方法？
--------------------

如果所需要的所有线程总是处于繁忙状态，则上面所描述的问题将是不可解决的。但是并不出现这样的情况：例如获取一个web页面从开始到结束也许只需要几秒钟（由于慢速的网络连接）并且只消耗几毫秒的CPU时间。处理HTTP请求与响应并不需要大量的计算。

这意味着处理单个客户请求的服务器线程也许99%的时间都在被阻塞。异步方法模式（也称之为异步编程模式或APM）就要释放这种潜力，只需要少量完全的线程来处理上千的并发任务。

异步方法的目标就在于绝不阻塞线程，而是使用返回回调的模式。（阻塞意味着整个WaitSleepJoin状态－或是使得其他的线程等待－浪费宝贵的线程资源。）要实现这一目的，异步方法必须放弃调用阻塞方法。

APM的终极目标就在于线程经济性。这意味着阻塞也是可以的－例如当锁住读写域时。

需要一段时间来运行的方法并不违反APM，因为他会执行大量的计算。异步方法的目的并不是为方法的并行执行提供一个方便的机制；他要优化线程资源。APM的黄金原则为：

充分利用CPU或是使用回调函数退出！

这意味着一个异步方法，例如BeginRead，并不会立即返回到调用者。他会使得调用者等待所需要的时间－同时充分利用处理器或是其他的约束资源。他甚至可以同步完成整个工作－假定他不会被阻塞或是使得其他线程被阻塞。

异步方法的主要作用是处理大量运行时间较长的并发请求－通常在慢速的网络连接上。

异步方法签名
------------

通过约定，异步方法都以Begin开头，同时有一个以End结束的对应方法，并具有类似于异步委托的签名：

.. code:: csharp

    IAsyncResult BeginXXX (in/ref-args, AsyncCallback callback, object state);
    return-type EndXXX (out/ref-args, IAsyncResult asyncResult);

下面是Stream类中的示例：

.. code:: csharp

    public IAsyncResult BeginRead (byte[] buffer, int offset, int size,
                                   AsyncCallback callback, object state);
    public int EndRead (IAsyncResult asyncResult);

Begin方示返回一个IAsyncResult对象，该对象会有助于我们来管理异步操作。然后相同的对象会被传递给完成回调函数。其委托如下：

public delegate void AsyncCallback (IAsyncResult ar);

对于异步委托，EndXXX方法可以允许获取返回值以任意的out/ref参数。这也是异常被重新抛出的地方。

为了避免阻塞，我们几乎总是在回调方法内部调用EndXXX方法。回调函数总是运行在池化线程上。

**IAsyncResult**

IAsyncResult接口定义如下：

.. code:: csharp

    public interface IAsyncResult
    {
      object AsyncState { get; }            // "state" object passed to Begin.
      WaitHandle AsyncWaitHandle { get; }   // Signaled when complete.
      bool CompletedSynchronously { get; }  // Did it complete on BeginX?
      bool IsCompleted { get; }             // Has it completed yet?
    }

AsyncState可以允许我们访问传递给BeginXXX方法的state参数。

当操作完成时，wait句柄会被赋值。为了无阻塞的等待，我们可以调用ThreadPool.RegisterWaitForSingleObject：

.. code:: csharp

    ThreadPool.RegisterWaitForSingleObject (
      result.AsyncWaitHandle,
      (data, timedOut) => { /* Callback */ },
      null, ?1, true);

CompletedSynchronously属性表明在调用BeginXXX方法之后操作会立即完成。这适用于以下三种原因：

-  操作将会很快完成－从而被异步执行来避免管理异步操作的负载。
-  底层实现－或操作系统－并支持这种应用场景中的APM。
-  操作是CPU绑定的并且会无阻塞的完成。

当这个属性返回true时，回调函数依然会被触发－但是也许会与调用BeginXXX的函数位于同一个线程上。忘记考虑这种可能性也许会导致意料不到的递归，从而导致堆栈溢出。

异步方法与异步委托
------------------

异步委托的目的是实现与其方法签名相同的模式－但是并没有线程节约的目标：

+---------------------------------------+--------------------------------------------------+
| 异步方法                              | 异步委托                                         |
+---------------------------------------+--------------------------------------------------+
| 很少或绝不阻塞线程                    | 也许会阻塞线程任意长的时间（尽管并不调用线程）   |
+---------------------------------------+--------------------------------------------------+
| Begin方法也许并不会立即返回给调用者   | BeginInvoke会立即返回给调用者                    |
+---------------------------------------+--------------------------------------------------+

异步方法的目的是使得多个任务运行在少量的线程之上；异步委托的目的是使得调用者并行执行某个任务。

我们可以使用异步委托来调用异步方法－从而执行可以保证立即返回给调用者，同时依然遵循APM。或者更好的是：我们可以使用框架4.0新的Task类来封装异步方法调用来简化管理（我们将会在本间津稍后解释如何来做）。

如果我们使用异步委托来调用一个阻塞方法，我们就回到了老路上来：服务器或者会超出有限的并发或者需要上千的线程来执行任务。

使用异步方法
------------

让我们编写一个满足下列要求的简单的TCP Socket服务器：

#. 他等待客户请求
#. 他读取5000字节确切长度的消息
#. 他反转消息中的字节，然后将其返回给客户

让我们首先使用一个标准的线程阻塞模式来编写。下面是代码，但是并没有异常处理：

.. code:: csharp

    using System;
    using System.Threading;
    using System.Net;
    using System.Net.Sockets;
    public class Server
    {
     public void Serve (IPAddress address, int port)
     {
        ThreadPool.SetMinThreads (50, 50);    // Refer to Chapter 21
        ThreadPool.SetMaxThreads (50, 50);    // Refer to Chapter 21
        TcpListener listener = new TcpListener (address, port);
        listener.Start();
        while (true)
        {
          TcpClient c = listener.AcceptTcpClient();
          ThreadPool.QueueUserWorkItem (Accept, c);
        }
      }
      void Accept (object clientObject)
      {
        using (TcpClient client = (TcpClient) clientObject)
        using (NetworkStream n = client.GetStream())
        {
          byte[] data = new byte [5000];
          int bytesRead = 0; int chunkSize = 1;
          while (bytesRead < data.Length && chunkSize > 0)
            bytesRead +=
              chunkSize = n.Read
                (data, bytesRead, data.Length - bytesRead);    // BLOCKS
          Array.Reverse (data);
          n.Write (data, 0, data.Length);                      // BLOCKS
        }
      }
    }

我们线程池的使用可以阻止创建任意大量的线程数目并且减少为每个请求创建线程所浪费的时间。我们的程序很简单而快速，但是只能处理50个并发请求。

为了扩展到处理1000个并发处理请求－而不增加线程数量－我们必须使用异步方法模式。这意味着避免阻塞I/O方法而使用其对应的异步方法。下面是我们的做法：

.. code:: csharp

    public class Server
    {
      public void Serve (IPAddress address, int port)
      {
        ThreadPool.SetMinThreads (50, 50);
        TcpListener listener = new TcpListener (address, port);
        listener.Start();
        while (true)
        {
          TcpClient c = listener.AcceptTcpClient();
          ThreadPool.QueueUserWorkItem (ReverseEcho, c);
        }
      }
      void ReverseEcho (object client)
      {
        new ReverseEcho().Begin ((TcpClient)client);
      }
    }
    class ReverseEcho
    {
      TcpClient _client;
      NetworkStream _stream;
      byte[] _data = new byte [5000];
      int _bytesRead = 0;
      internal void Begin (TcpClient c)
      {
        try
        {
          _client = c;
          _stream = c.GetStream();
          Read();
        }
        catch (Exception ex) { ProcessException (ex); }
      }
      void Read()            // Read in a nonblocking fashion.
      {
        while (true)
        {
          IAsyncResult r = _stream.BeginRead
           (_data, _bytesRead, _data.Length - _bytesRead, ReadCallback, null);
          // This will nearly always return in the next line:
          if (!r.CompletedSynchronously) return;   // Handled by callback
          if (!EndRead (r)) break;
        }
        Write();
      }
      void ReadCallback (IAsyncResult r)
      {
        try
        {
          if (r.CompletedSynchronously) return;
          if (EndRead (r))
          {
            Read();       // More data to read!
            return;
          }
          Write();
        }
        catch (Exception ex) { ProcessException (ex); }
      }
      bool EndRead (IAsyncResult r)   // Returns false if there's no more data
      {
        int chunkSize = _stream.EndRead (r);
        _bytesRead += chunkSize;
        return chunkSize > 0 && _bytesRead < _data.Length;   // More to read
      }
      void Write()
      {
        Array.Reverse (_data);
        _stream.BeginWrite (_data, 0, _data.Length, WriteCallback, null);
      }
      void WriteCallback (IAsyncResult r)
      {
        try { _stream.EndWrite (r); }
        catch (Exception ex) { ProcessException (ex); }
        Cleanup();
      }
      void ProcessException (Exception ex)
      {
        Cleanup();
        Console.WriteLine ("Error: " + ex.Message);
      }
      void Cleanup()
      {
        if (_stream != null) _stream.Close();
        if (_client != null) _client.Close();
      }
    }

这个程序可以在不多于10个池化线程上处理1000个并发请求。

每个客户请求都不会调用任何阻塞方法进行处理。

在Read方法中，我们由在流上调用BeginRead方法开始，同时指定一个完成回调函数。我们可以将整个方法简化为如下样子并获得相同的结果：

.. code:: csharp

    void Read()
    {
      _stream.BeginRead
        (_data, _bytesRead, _data.Length - _bytesRead, ReadCallback, null);
    }

然而有一个小小的挑战，BeginRead将会异步完成，然后在相同的线程上调用ReadCallback。因为ReadCallback会再次调用Read，这也许会导致某些非常深的递归与堆栈溢出。为了避免这一问题，我们必须在BeginRead调用之后检测CompletedSynchronously，并且如果其返回true，使用循环来调用Read直到完成而不要依赖于ReadCallback中的递归调用。

这就导致了我们为什么在Server方法中调用AcceptTcpClient－而不是其异步版本，BeginAcceptTcpClient。出于保存线程的优点，后者需要与BeginRead相同的模式使用来避免可能的堆栈溢出。

ReverseEcho类为其生命周期封装了请求状态。我们不能再为该任务使用局部变量，因为每次我们退出时执行堆栈都会退出。这同时意味着简单的using语句不再适用于关闭我们的TcpClient与流。

另一个影响因素是我们不能使用如BinaryReader与BinaryWriter这样的类型，因为他们并没有提供其方法的异步版本。

异步方法与任务
--------------

在前面的示例中我们看到了框架4.0的Task类如何能够管理池化线程上的工作单元。我们也可以使用Task来封装异步方法调用－通过TaskFactory上的FromAsync方法。

我们通过调用FromAsync所获得的任务只是在BeginXXX与EndXXX方法上的一个轻量封装器－他并不会像普通的任务一样获得调度。使用FromAsync的原因就在于利用如连续与子任务这样的特性。FromAsync在内部是使用TaskCompletionSource来实现的。

FromAsync方法需要下列参数：

-  指定BeginXXX方法的委托
-  指定EndXXX方法的委托
-  传递给这些方法的其他参数

FromAsync被重载来接受与.NET框架中几乎所有的异步方法签名相匹配的委托类型与参数。例如，假定stream是一个Stram，我们并不会使用下面的代码：

.. code:: csharp

    var buffer = new byte[1000];
    stream.BeginRead (buffer, 0, 1000, MyCallback, null);
    ...
    void MyCallback (IAsyncResult r)
    {
      int bytesRead;
      try { bytesRead = stream.EndWrite (r); }
      catch (Exception ex) { Console.Write (ex.Message); }
      Console.Write (bytesRead + " bytes read");
    }

而是会使用下面的代码：

.. code:: csharp

    var buffer = new byte[1000];
    Task<int> readChunk = Task<int>.Factory.FromAsync (
      stream.BeginRead, stream.EndRead, buffer, 0, 1000, null);
    readChunk.ContinueWith (ant => Console.Write (ant.Result + " bytes read"),
                                   TaskContinuationOptions.NotOnFaulted);
    readChunk.ContinueWith (ant => Console.Write (ant.Exception.Message),
                                   TaskContinuationOptions.OnlyOnFaulted);

这段代码本身并没有什么节省：当我们引入父子线程扩展时就会看到真正的好处。重新考虑我们前面的示例，假定我们重构ReverseEcho的Begin方法，从而他在一个新的任务上调用Read。这会将Server.Server由创建任务自身中解脱出来，但是更重要的是，他可以依据我们可以关联到哪个扩展来为From
Async创建的任务创建一个父任务。这就避免了必须为每一个子任务编写单独的异常处理块或是显示的错误处理。清理也可以很容易的作为另一个父任务的扩展来实现：

.. code:: csharp

    public class Server
    {
      public void Serve (IPAddress address, int port)
      {
        ThreadPool.SetMinThreads (50, 50);
        TcpListener listener = new TcpListener (address, port);
        listener.Start();
        while (true)
        {
          TcpClient c = listener.AcceptTcpClient();
          new ReverseEcho().BeginAsync (c);
        }
      }
    }
    class ReverseEcho
    {
      TcpClient _client;
      NetworkStream _stream;
      byte[] _data = new byte [5000];
      int _bytesRead = 0;
      internal void BeginAsync (TcpClient c)
      {
        _client = c;
        _stream = c.GetStream();
        var task = Task.Factory.StartNew (Read);
        // Set up centralized error handling and cleanup:
        task.ContinueWith (ant =>
          Console.WriteLine ("Error: " + ant.Exception.Message),
          TaskContinuationOptions.OnlyOnFaulted);
        task.ContinueWith (ant =>
        {
          if (_stream != null) _stream.Close();
          if (_client != null) _client.Close();
        });
      }
      void Read()    // This will create a child task.
      {
        Task<int> readChunk = Task<int>.Factory.FromAsync (
          _stream.BeginRead, _stream.EndRead,
          _data, 0, _data.Length - _bytesRead, null,
          TaskCreationOptions.AttachedToParent);
        readChunk.ContinueWith (Write, TaskContinuationOptions.NotOnFaulted);
      }
      void Write (Task<int> readChunk)
      {
        _bytesRead += readChunk.Result;
        if (readChunk.Result > 0 && _bytesRead < _data.Length)
        {
          Read();       // More data to read!
          return;
        }
        Array.Reverse (_data);
        Task.Factory.FromAsync (_stream.BeginWrite, _stream.EndWrite,
                                _data, 0, _data.Length, null,
                                TaskCreationOptions.AttachedToParent);
      }
    }

同时我们不需要担心Read进入递归并执行栈分割：扩展并不会同步发生，除非我们显示要求。

***异步方法与迭代器***

在VS2010的PFX的并行编程示例中，我们会发现在TaskFactory上有一个名为Iterate的扩展方法。使用这个方法，我们可以将我们示例中的ReverseEcho类中的逻辑移动到另一个单独的迭代器方法中。在简单的场景中这将是一个恐怖的模式，因为这意味着我们可以使用具有局部变量的简单方法来替换ReverseEcho及其域。下面是我们重构的Server类：

.. code:: csharp

    public class Server
    {
      public void Serve (IPAddress address, int port)
      {
        ThreadPool.SetMinThreads (50, 50);
        TcpListener listener = new TcpListener (address, port);
        listener.Start();
        while (true)
        {
          TcpClient c = listener.AcceptTcpClient();
          Task.Factory.Iterate (ReverseEcho(c)).ContinueWith (t =>
            Console.WriteLine ("Error: " + t.Exception.Message),
            TaskContinuationOptions.OnlyOnFaulted);
        }
      }
      IEnumerable<Task> ReverseEcho (TcpClient client)
      {
        using (client)
        using (var stream = client.GetStream())
        {
          byte[] data = new byte[Program.MessageLength];
          int bytesRead = 0;
          while (true)
          {
            // ReadASync is an extension method in the samples.
            Task<int> readChunk = stream.ReadAsync
              (data, bytesRead, data.Length - bytesRead);
            yield return readChunk;
            bytesRead += readChunk.Result;
            if (readChunk.Result <= 0 || bytesRead >= data.Length)
              break;
          }
          Array.Reverse(data);
          yield return stream.WriteAsync (data, 0, bytesRead);
        }
      }
    }

然而，在更为复杂的情况下，拥有一个类是很有帮助的，因为我们可以将代码抽象为我们所希望的多个方法。迭代器的问题在于我们在迭代器中所调用的任何方法本身并不会影响到调用者的行为，而这限制了我们重构大代码块的能力。

编写异步方法
------------

回到我们前面的示例，假定5000字节的交换量仅是更高级协议的一个小部分。将我们已编写的代码转换为类似下面的方法将是不错的选择：

public byte[] ReverseEcho (TcpClient client);

当然，问题在于该方法的签名是同步的；我们需要提供一个异步的版本－换句话说，BeginReverseEcho。更进一步，如果遇到异常，将其输出到控制台并不是太好；我们需要在某一时刻将其抛给调用者。所以，为了适应该模式，我们必须同时提供EndReverseEcho并且编写一个实现了IAsyncResult的类。

我们的ReverseEcho类是IAsyncResult的一个优秀替代者，因为他已经封装了操作的状态。我们所需要添加的是在调用EndReverseEcho时重新抛出异常的代码，以及在完成时通知的等待句柄。

下面是一个真实的示例，具有异常处理与线程安全：

.. code:: csharp

    public byte[] ReverseEcho (TcpClient client);
        get { return _waitHandle.WaitOne (0, false); }
      }
      internal void Begin (TcpClient c, AsyncCallback callback, object state)
      {
        _client = c;
        _userState = state;
        get { return _waitHandle.WaitOne (0, false); }
      }
      internal void Begin (TcpClient c, AsyncCallback callback, object state)
      {
        _client = c;
        _userState = state;
          Read();       // More data to read!
          return;
        }
        Array.Reverse (_data);
        Task.Factory.FromAsync (_stream.BeginWrite, _stream.EndWrite,
                                _data, 0, _data.Length, null);
      }
    }

在CleanUp中，我们关闭了\_stream而不是\_client，因为调用者在执行反向回应之后也许希望继续使用\_client。

伪造异步方法
------------

通常，以Begin开头并且返回IAsyncResult的框架方法都遵循APM。然后，基于Stream类会有一些例外：

-  BufferedStream
-  CryptoStream
-  DeflateStream
-  MemoryStream

这些类型依赖基类Stream类中的回调异步实现，但是并提供非阻塞保证。相反，他们会使用异步委托来调用阻塞方法，例如Read或Write。尽管这种方法在MemoryStream的情况下是非常正确的，但是对于BufferedStream与CryptoStream则会出现问题－如果封装MemoryStream以外的流。换句话说，如果我们在封装NetworkStream的CryptoStream上调用BeginRead或BeginWrite，某些线程将会在某些时刻阻塞，违反异步方法模式的扩展性。这是一个遗憾，因为CryptoStream的装饰者模式是很高效的。

CryptoStream的工作区首先将底层异步读取到MemoryStream中，然后使得CryptoStream封装MemoryStream。这意味着将整个流读取到内存中，尽管是在一个高并发服务器上，也并不会获得很好的扩展性。如果我们确实需要异步加密，一个解决方案就是在比CryptoStream还要低的层次上进行处理，也就是ICryptoTransform。使用Red
Gate's
Reflector这样的反汇编工作，我们可以确切的了解CryptoStream是如何使用ICryptoTransform来进行处理的。

DeflateStream确实遵循异步模式－或者到至少是尝试遵循。问题在于他并不能正确的处理异常。例如，如果底层数据被破坏，BeginRead会在池化线程上抛出异常而不会将其汇集到EndRead。这将是破坏我们整个程序的不可捕获的异常。

FileStream类是另一个违反者－他伪造了异步方法（例如他依赖于Stream的默认实现）。然而，如果使用如下的方式进行构造，他确实会尝试真正的异步行为：

.. code:: csharp

    Stream s = new FileStream ("large.bin", FileMode.Create, FileAccess.Write,
                                FileShare.None, 0×1000, true);

最后的布尔参数指示FileStream不要使用异步委托－而是尝试真正的APM方法。问题在于异步文件I/O需要操作系统支持，也许并不会出现这样的支持。如果OS没有支持，BeginRead会将调用线程阻塞在WaitSleepJoin状态。

然而，异步文件I/O的缺乏几乎不是问题，假定我们要访问一个本地文件系统。小文件请求也许会由操作系统或是硬盘驱动缓存来提供。

异步方法的替代者
----------------

第21章描述了三个类似的技术－这三个技术都会在新线程上执行任务：

-  ThreadPool.RegisterWaitForSingleObject
-  生产者/消费者队列
-  线程与系统计时器

ThreadPool.RegisterWaitForSingleObject在实现异步方法模式时会很有用。自定义的生产者/消费者队列可以提供完全的替代－使用我们自己的工作者池－但是如果我们希望与.NET框架进行交互则没有太大的帮助。如果我们的工作是定时执行而不是响应请求，则线程与系统计时器会非常合适。

Chapter 24. Application Domains
===============================

Chapter 25. Native and COM Interoperability
===========================================

本章描述如何与原生DLL及COM组件进行集成。除非特别说明，本章所提到的类型位于System或是System.Runtime.InteropServices名字空间中。

Calling into Native DLLs
------------------------

P/Invoke，Platform Invocation
Services的简写，允许我们访问非托管DLL中的函数，结构以及回调。例如，考虑定义在Windows
DLL user32.dll中的MessageBox函数：

int MessageBox (HWND hWnd, LPCTSTR lpText, LPCTSTR lpCation, UINT
uType);

我们可以通过声明一个同名的静态方法，应用extern关键字并且添加DllImport属性来直接调用该函数：

.. code:: csharp

    using System;
    using System.Runtime.InteropServices;
    class MsgBoxTest
    {
      [DllImport("user32.dll")]
      static extern int MessageBox (IntPtr hWnd, string text, string caption,
                                    int type);
      public static void Main()
      {
        MessageBox (IntPtr.Zero,
                    "Please do not press this again.", "Attention", 0);
      }
    }

System.Windows与System.Windows.Forms名字空间扣MessageBox类本身调用类似的非托管方法。

CLR包括一个知道如何在.NET类型与非托管类型之间转换参数与返回值的marshaler。在这个示例中，int参数直接转换为函数所希望的4字节整数，而string参数被转换为null结束的2字节Unicode字符数组。IntPtr是一个设计为封装非托管句柄的结构，并且在32位平台上为32位宽度，在64位平台上为64位宽度。

Type Marshaling
---------------

Marshaling Common Types
-----------------------

在非托管的一侧，可以有多种方法来表示指定的数据类型。例如，一个字符串可以包含单字节的ANSI字符或是双字节的Unicode字符，而且可以是前缀长度，null结束或是固定长度的。使用MarshalAs属性，我们可以告诉CLR
marshaler所使用的变体，从而他可以提供正确的转换。如下面的示例所示：

.. code:: csharp

    [DllImport("...")]
    static extern int Foo ( [MarshalAs (UnmanagedType.LPStr)] string s );

UnmanagedType枚举包含marshaler所理解的所有Win32与COM类型。在这个示例中，marshaler被通知转换为LPStr，这是一个null结束的单字节ANSI字符串。（所有的UnmanagedType成员列在本章的结束处。）

在.NET一侧，对于使用哪种数据类型，我们也可以有多种选择。例如，非托管句柄可以映射为IntPtr，int，unit，long或是ulong。

注意，大多数的非托管句柄封装一个地址或是指针，为了与32位及64位操作系统兼容必须被映射为IntPtr。一个常见的示例就是HWND。

通常对于Win32函数，我们会遇到接受常量集合的整型参数，这些常量定义一个C++头文件中，例如WinUser.h。我们并不会将这些常量定义为简单的C#常量，相反，我们在一个枚举中进行定义。使用枚举可以使得代码更整洁，且增加静态类型安全。我们会在稍后的章节中提供一个示例。

接收由非托管代码块到.NET的字符串需要某些内存管理发生作用。如果我们使用StringBuilder而不是string来声明外部方法，marshaler就会自动执行相应的转换工作，如下所示：

.. code:: csharp

    using System;
    using System.Text;
    using System.Runtime.InteropServices;
    class Test
    {
      [DllImport("kernel32.dll")]
      static extern int GetWindowsDirectory (StringBuilder sb, int maxChars);
      static void Main()
      {
        StringBuilder s = new StringBuilder (256);
        GetWindowsDirectory (s, 256);
        Console.WriteLine (s);
      }
    }

Marshaling Classes and Structs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

有时我们需要向非托管方法传递一个结构。例如，Win32
API中的GetSystemTime方法定义如下：

void GetSystemTime (LPSYSTEMTIME lpSystemTime);

LPSYSTEMTIME指向如下的C结构：

.. code:: c

    typedef struct _SYSTEMTIME {
      WORD wYear;
      WORD wMonth;
      WORD wDayOfWeek;
      WORD wDay;
      WORD wHour;
      WORD wMinute;
      WORD wSecond;
      WORD wMilliseconds;
    } SYSTEMTIME, *PSYSTEMTIME;

为了调用GetSystemTime，我们必须定义与该C结构匹配的.NET类或结构：

.. code:: csharp

    using System;
    using System.Runtime.InteropServices;
    [StructLayout(LayoutKind.Sequential)]
    class SystemTime
    {
       public ushort Year;
       public ushort Month;
       public ushort DayOfWeek;
       public ushort Day;
       public ushort Hour;
       public ushort Minute;
       public ushort Second;
       public ushort Milliseconds;
    }

StructLayout属性指示marshaler如何将每一个域映射到非托管代码。LayoutKind.Sequential着我们希望域顺序排列，就如同C结构中一样。这里的域名是无关的；域的顺序才是重要的。

现在我们可以调用GetSystemTime：

.. code:: csharp

    [DllImport("kernel32.dll")]
    static extern void GetSystemTime (SystemTime t);
    static void Main()
    {
      SystemTime t = new SystemTime();
      GetSystemTime (t);
      Console.WriteLine (t.Year);
    }

在C与C#中，对象中的域都位于该对象起始地址的n字节处。区别在于在C#程序中，CLR通过域的名字来查找偏移量；C域的名字被直接编译为偏移量。例如，在C语言中，wDay仅是一个表示SystemTime实例地址偏移24字节处的标记。

对于访问速度，每个域都位于该域大小的整倍数的偏移量处。然而这个整倍数被限制为x字节的最大值，其中x是pack
size（对齐大小）。在当前的实现中，默认的对齐大小为8字节，由一个sbyte后跟一个long（8个字节）所构成的结构会占用16个字节，而sbyte之后的7个字节就会被浪费。我们可以通过StructLayout属性的Pack属性指定对齐大小来减少这种浪费：这会使得域在指定对齐大小的整倍数的偏移量处对齐。所以对于对齐大小为1，前面所描述的结构就会占用9个字节。我们可以将对齐大小指定为1，2，4，8或是16字节。

StructLayout属性同时允许我们指定显示的域偏移量。

In and Out Marshaling
~~~~~~~~~~~~~~~~~~~~~

在前面的示例中，我们将会SystemTime实现为一个类。我们本可以选择结构－只要GetSystemTime使用ref或out参数进行声明：

.. code:: csharp

    [DllImport("kernel32.dll")]
    static extern void GetSystemTime (out SystemTime t);

在大多数情况下，C#的方向参数语义同样适用于外部方法。按值传递参数向内拷贝，C#
ref参数向内/向外拷贝，而C#
out参数向外拷贝。然而，对于特殊转换的类型则有一些例外。例如，数组类与StringBuilder类在用于函数时需要拷贝，所以他们是向内/向外。有时使用In与Out属性覆盖这种行为将会非常有用。例如，如果一个数组应是只坊的，in修饰符表明只允许向函数内拷贝数组，而不能向外拷贝：

.. code:: csharp

    static extern void Foo ( [In] int[] array);

Callback from Unmanaged Code
----------------------------

P/Invoker层会尽量在边界两边表示一个自然编程模式，可能时在相关的结构之间进行映射。因为C#不仅可以调用C函数，而且可以在C函数内进行调用（通过函数指针），P/Invokder层需要将非托管的函数指针映射到托管世界的某些自然编程模式上。函数指针的托管对应是代理，所以P/Invokder层会自动在代理（C#中）与函数指针（C中）之间进行映射。

作为一个示例，我们可以使用User32.dll中的方法来遍历所有的顶级窗口句柄：

BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);

WNDENUMPROC是每一个窗口句柄依次触发的回调函数（或是直到回调函数返回false）。下面是其定义：

BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);

为了使用该方法，我们声明一个具有匹配签名的代理，然后向外部方法传递一个代理实例：

.. code:: csharp

    using System;
    using System.Runtime.InteropServices;
    class CallbackFun
    {
      delegate bool EnumWindowsCallback (IntPtr hWnd, IntPtr lParam);
      [DllImport("user32.dll")]
      static extern int EnumWindows (EnumWindowsCallback hWnd, IntPtr lParam);
      static bool PrintWindow (IntPtr hWnd, IntPtr lParam)
      {
        Console.WriteLine (hWnd.ToInt64());
        return true;
      }
      static void Main()
      {
        EnumWindows (PrintWindow, IntPtr.Zero);
      }
    }

Simulating a C Union
--------------------

struct中的每一个域被会被提供足够的空间来存储其数据。考虑一个包含一个int与一个char的struct。int可能由偏移量0开始，并且到少是四个字节。所以char到少由偏移量4开始。如果由于某些原因，char由偏移量2开始，如果我们为char赋值则会修改int的值。听起来很混乱，不是吗？更奇怪的是，C语言所支持的一种被称为联合的结构的变体就是这样的。我们可以在C#中使用LayoutKind.Explicit与FieldOffset属性来进行模拟。

也许很难想像这种情况会很有用。然而，假定我们要在外部合成器上尝试某些音符。Windows
Multimedia API通过MIDI协议提供了一个函数来完成该操作：

.. code:: csharp

    [DllImport ("winmm.dll")]
    public static extern uint midiOutShortMsg (IntPtr handle, uint message);

第二个参数，message，描述播放哪些音符。构造这个无符号32位整数的问题在于：他在内部被分割为字节，表示MIDI通道，音符以及打击速率。一个解决方案是通过移位并通过位操作<<，>>，&与\|操作符进行掩码来由32位打包消息进行转换。然而更为简单的方法是使用显式布局定义一个结构：

.. code:: csharp

    [StructLayout (LayoutKind.Explicit)]
    public struct NoteMessage
    {
      [FieldOffset(0)] public uint PackedMsg;    // 4 bytes long
      [FieldOffset(0)] public byte Channel;      // FieldOffset also at 0
      [FieldOffset(1)] public byte Note;
      [FieldOffset(2)] public byte Velocity;
    }

Channel，Note与Velocity域故意在32位打包消息上进行重叠。这允许我们进行任意的读取与写入。并不需要为了保持其他域的同步而进行的计算：

.. code:: csharp

    NoteMessage n = new NoteMessage();
    Console.WriteLine (n.PackedMsg);    // 0
    n.Channel = 10;
    n.Note = 100;
    n.Velocity = 50;
    Console.WriteLine (n.PackedMsg);    // 3302410
    n.PackedMsg = 3328010;
    Console.WriteLine (n.Note);         // 200

Shared Memory
-------------

内存映射文件，或共享内存，是Windows中允许相同计算机上多个进程共享数据而无需Remoting或WCF负担的一个特性。共享内存速度非常快，并且与管道不同，对共享数据提供了随机访问。我们在第14章中了解了如何使用框架4.0中新的MemoryMapped类来访问内存映射文件；除了这种方法，直接调用Win32方法是演示P/Invokder的一个好方式。

Win32的CreateFileMapping函数分配共享内存。我们告诉该函数我们所需要的字节以及我们希望标识该共享内存的名字。然后其他的程序可以通过相同的名字调用OpenFileMapping来订阅该内存。两个方法都会返回一个句柄，我们可以通过调用MapViewOfFile将其转换为指针。

下面是封装对共享内存访问的类：

.. code:: csharp

    using System;
    using System.Runtime.InteropServices;
    public sealed class SharedMem : IDisposable
    {
      // Here we're using enums because they're safer than constants
      enum FileProtection : uint      // constants from winnt.h
      {
        ReadOnly = 2,
        ReadWrite = 4
      }
      enum FileRights : uint          // constants from WinBASE.h
      {
        Read = 4,
        Write = 2,
        ReadWrite = Read + Write
      }
      static readonly IntPtr NoFileHandle = new IntPtr (-1);
      [DllImport ("kernel32.dll", SetLastError = true)]
      static extern IntPtr CreateFileMapping (IntPtr hFile,
                                              int lpAttributes,
                                              FileProtection flProtec
                                              uint dwMaximumSizeHigh,
                                              uint dwMaximumSizeLow,
                                              string lpName);
                                          FileRights dwDesiredAccess,
                                          uint dwFileOffsetHigh,
                                          uint dwFileOffsetLow,
                                          uint dwNumberOfBytesToMap);
      [DllImport ("Kernel32.dll", SetLastError = true)]
      static extern bool UnmapViewOfFile (IntPtr map);
      [DllImport ("kernel32.dll", SetLastError = true)]
      static extern int CloseHandle (IntPtr hObject);
      IntPtr fileHandle, fileMap;
      public IntPtr Root { get { return fileMap; } }
      public SharedMem (string name, bool existing, uint sizeInBytes)
      {
        if (existing)
          fileHandle = OpenFileMapping (FileRights.ReadWrite, false, name);
        else
          fileHandle = CreateFileMapping (NoFileHandle, 0,
                                          FileProtection.ReadWrite,
                                          0, sizeInBytes, name);
        if (fileHandle == IntPtr.Zero)
          throw new Win32Exception();
        // Obtain a read/write map for the entire file
        fileMap = MapViewOfFile (fileHandle, FileRights.ReadWrite, 0, 0, 0);
        if (fileMap == IntPtr.Zero)
          throw new Win32Exception();
      }
      public void Dispose()
      {
        if (fileMap != IntPtr.Zero) UnmapViewOfFile (fileMap);
        if (fileHandle != IntPtr.Zero) CloseHandle (fileHandle);
        fileMap = fileHandle = IntPtr.Zero;
      }
    }

在这个示例中，我们在DllImport方法上设置SetLastError=true使用SetLastError协议用于发送错误代码。这可以保证当异常被抛出时，Win32Exception封装有详细的错误信息。（他也可以允许我们通过调用Marhal.GetLastWin32Error来显式查询错误。）

为了演示这个类，我们需要运行两个程序。第一个创建共享内存，如下所示：

.. code:: csharp

    using (SharedMem sm = new SharedMem ("MyShare", false, 1000))
    {
      IntPtr root = sm.Root;
      // I have shared memory!
      Console.ReadLine();         // Here's where we start a second app...
    }

第二个程序通过使用existing参数为true构造相同名字的SahredMem对象来订阅该共享内存：

.. code:: csharp

    using (SharedMem sm = new SharedMem ("MyShare", true, 1000))
    {
      IntPtr root = sm.Root;
      // I have the same shared memory!
      // ...
    }

结果就是每一个程序都有一个IntPtr-指向（相同）非托管内存的指针。现在这个两个程序需要通过这个共同的指针来读取与写入内存。一个方法是写封装所有共享数据的可序列化类，然后使用UnmanagedMemoryStream将数据序列化（与反序列化）到非托管内存。然而，如果有大量的数据，这种方法效率很低。想像一个如果共享内存类具有兆级数据，而仅有一个整数需要更新。更好的方法是将共享数据定义为结构，然后将其直接映射到共享内存。我们会在下面的内容中进行讨论。

Mapping a Struct to Unmanaged Memory
------------------------------------

具有Sequential或Explicit的StructLayout的结构可以被直接映射到托管内存。考虑下面的结构：

.. code:: csharp

    [StructLayout (LayoutKind.Sequential)]
    unsafe struct MySharedData
    {
      public int Value;
      public char Letter;
      public fixed float Numbers [50];
    }

fixed指令允许我们定义固定长度的值类型数组，而且也是将我们带入unsafe领域的关键。在这个结构内部会为50个浮点数分配空间。与标准的C#数组不同，NumberArray并不是指向数组的引用-他就是数组。如果我们运行下面的程序：

.. code:: csharp

    static unsafe void Main()
    {
      Console.WriteLine (sizeof (MySharedData));
    }

结果是208：50个4字节的浮点数，加上Value整数的4个字节，加上Letter字符的2个字节。由于floats是4字节对齐的，所有206被近似为208。

最简单的，我们可以使用栈分配内存在unsafe环境内演示MySharedData：

.. code:: csharp

    MySharedData d;
    MySharedData* data = &d;       // Get the address of d
    data->Value = 123;
    data->Letter = 'X';
    data->Numbers[10] = 1.45f;

或者：

.. code:: csharp

    // Allocate the array on the stack:
    MySharedData* data = stackalloc MySharedData[1];
    data->Value = 123;
    data->Letter = 'X';
    data->Numbers[10] = 1.45f;

当然，我们并不是在演示在托管环境中不可以实现的内容。然而，假定我们希望在CLR垃圾回收领域之外的非托管堆上存储MyShareData实例。这正是指针真正派上用场的地方：

.. code:: csharp

    MySharedData* data = (MySharedData*)
      Marshal.AllocHGlobal (sizeof (MySharedData)).ToPointer();
    data->Value = 123;
    data->Letter = 'X';
    data->Numbers[10] = 1.45f;

Marshal.AllocHGlobal在非托管堆上分配内存。下面是在稍后如何释放内存的代码：

Marshal.FreeHGlobal (new IntPtr (data));

忘记释放内存的结果就是古老的内存泄露问题。

为了与其名字保持一致，现在我们将配合我们在前面所编写的SharedMem类来使用MySharedData。下面的程序将会分配一块共享内存，然后将MySharedData结构映射到该内存块：

.. code:: csharp

    static unsafe void Main()
    {
      using (SharedMem sm = new SharedMem ("MyShare", false, 1000))
      {
        void* root = sm.Root.ToPointer();
        MySharedData* data = (MySharedData*) root;
        data->Value = 123;
        data->Letter = 'X';
        data->Numbers[10] = 1.45f;
        Console.WriteLine ("Written to shared memory");
        Console.ReadLine();
        Console.WriteLine ("Value is " + data->Value);
        Console.WriteLine ("Letter is " + data->Letter);
        Console.WriteLine ("11th Number is " + data->Numbers[10]);
        Console.ReadLine();
      }
    }

不要为指针所阻止：C++程序员在整个程序中使用指针并且能够使得一切运行正常。至少大多数时候如此！比较起来这种用法非常简单。

事实上，我们示例是不安全的，除了表面上的不安全，还有另一个原因。我们并没有考虑两个程序同时访问相同的内存时会导致的线程安全问题。为了在产品应用中使用这个示例，我们需要为MySharedData结构中的Value与Letter域添加volatile关键字来避免这些域在CPU注册器中进行缓存。而且，随着我们与这些域的交互变得复杂时，很可能我们需要通过跨进程的Mutex来保护访问，正如我们在多线程程序中使用lock语句来保护对域的访问一样。我们在第21章讨论了线程安全问题。

**fixed与fixed{}**

将结构直接映射到内存的不足之处在于结构只能包含非托管类型。例如，如果我们需要共享字符串数据，我们必须使用固定的字符数组进行替代。这就意味着与string类型的手工转换。下面的代码显示了如何实现：

.. code:: csharp

    [StructLayout (LayoutKind.Sequential)]
    unsafe struct MySharedData
    {
      ...
      // Allocate space for 200 chars (i.e., 400 bytes).
      const int MessageSize = 200;
      fixed char message [MessageSize];
      // One would most likely put this code into a helper class:
      public string Message
      {
        get { fixed (char* cp = message) return new string (cp); }
        set
        {
          fixed (char* cp = message)
          {
            int i = 0;
            for (; i < value.Length && i < MessageSize - 1; i++)
              cp [i] = value [i];
            // Add the null terminator
            cp [i] = '\0';
          }
        }
      }
    }

通过fixed关键字的第一次使用，我们为结构中的200个字符分配空间。当在稍后的属性定义中使用时，相同的关键字则具有不同的意义。他通知CLR在fixed块内部可以执行垃圾回收，但是不要在内存堆上移动底层结构，因为其内容是通过直接内存指针进行指向的。查看我们的程序，我们也许会想知道如果MySharedData没有位于堆上，他是如何在内存中移动的，但是在非托管的世界中，垃圾回收并没有这些权限。然而编译器并不知道这些，并且认为我们也许是在托管环境中使用MyShardData，所以要求我们必须添加fixed关键字，来为我们在托管环境中提供unsafe代码。下面是代码是编译器将MySharedData放置在堆上所需要做：

object obj = new MySharedData();

这会在堆上生成一个装箱的MySharedData，并且垃圾回收期间满足传输的条件。

这个示例演示了一个字符串如何在映射到非托管内存的结构中进行表示。对于更为复杂的类型，我们也具有使用已有序列化代码的选项。唯一的限制条件就是序列化的数据不要超出结构中所分配空间的长度。

COM Interoperability
--------------------

Chapter 26. Regular Expressions
===============================

正则表达式语言标识字符模式。.NET类型支持的正则表达式基于Perl5正则表达式，同时支持查找与查找/替换功能。

正则表达式可以用于类似如下的任务：

-  验证如密码与电话号码这样的文本输入（ASP.NET为此目的提供了RegularExpressionValidator控件）
-  将文本数据分析为更为结构化的格式（例如由存储在数据库中HTML页面获取数据）
-  替换文档中的文本格式（例如只替换整词）

本章分为介绍.NET正则表达式基础的概念部分以及描述正则表达式语言的参考部分。

所有的正则表达式类型定义于System.Text.RegularExpression名空空间中。

正则表达式基础
--------------

最常见的正则表达式之一是量词。?是一个匹配0个或是1个的量词。换句话说，?意味着可选的。一个正则或者是单个字符或者是位于方括号中的复杂字符结构。例如，正则表达式"colou?r"可以匹配color与colour，但是并不匹配colouur：

.. code:: csharp

    Console.WriteLine (Regex.Match ("color",   @"colou?r").Success);  // True
    Console.WriteLine (Regex.Match ("colour",  @"colou?r").Success);  // True
    Console.WriteLine (Regex.Match ("colouur", @"colou?r").Success);  // False

Regex.Math是一个较大的字符串内查找。其所返回的对象包含匹配的Index与Length属性以及实际匹配的Value：

.. code:: csharp

    Match m = Regex.Match ("any colour you like", @"colou?r");
    Console.WriteLine (m.Success);     // True
    Console.WriteLine (m.Index);       // 4
    Console.WriteLine (m.Length);      // 6
    Console.WriteLine (m.Value);       // colour
    Console.WriteLine (m.ToString());  // colour

我们可以将Regex.Match方法看作string的IndexOf方法的更强大版本。所不同的是正则表达式搜索模式而不是字符串字面量。

IsMatch方法是调用Match然调用测试Success属性的简写。

默认情况下正则表达式引擎由左到右计算，所以只会返回最左端的匹配。我们可以使用NextMatch方法来返回更多的匹配：

.. code:: csharp

    Match m1 = Regex.Match ("One color? There are two colours in my head!",
                            @"colou?rs?");
    Match m2 = m1.NextMatch();
    Console.WriteLine (m1);         // color
    Console.WriteLine (m2);         // colours

Matches方法会以数组形式返回所有的匹配。我们可以重写前面的示例：

.. code:: csharp

    foreach (Match m in Regex.Matches
              ("One color? There are two colours in my head!", @"colou?rs?"))
      Console.WriteLine (m);

另一个常用的正则表式操作符以竖线表示的或操作符。下面的正则表达式会匹配“Jen”，“Jenny”与“Jennifer”：

Console.WriteLine (Regex.IsMatch ("Jenny", "Jen(ny\|nifer)?")); // True

或操作符两端的括号将其与表达式的其余部分离开。

编译的正则表达式
~~~~~~~~~~~~~~~~

在前面的某些示例中，我们使用相同的模式重复调用静态的RegEx方法。另一种相对的方法则是使用模式实例化一个RegEx对象，然后调用实例方法：

.. code:: csharp

    Regex r = new Regex (@"sausages?");
    Console.WriteLine (r.Match ("sausage"));   // sausage
    Console.WriteLine (r.Match ("sausages"));  // sausages

这并不仅仅是语法约定：在其表象之下，RegEx实例使用轻量级的代码生成来动态构建与编译适应特定正则表达式的代码。结果则是以较小的初始编译代价获得更快速的匹配。

RegEx实例是不可修改的。

RegexOptions
~~~~~~~~~~~~

RegexOptions标志枚举让我们可以调整匹配行为。RegexOptions的一个通常应用是执行大小写不敏感的查找：

Console.WriteLine (Regex.Match ("a", "A", RegexOptions.IgnoreCase)); //
a

大多数的RegexOptions标记也可以在表达式本身内使用一个符号代码来激活：

Console.WriteLine (Regex.Match ("a", @"(?i)A")); // a

我们可以使用表达式来打开或是关闭正则选项：

Console.WriteLine (Regex.Match ("AAAa", @"(?i)a(?-i)a")); // Aa

另一个有用的选项是IgnorePatternWhitespace或
(?x)。这可以允许我们插入空格从而使得正则表达式更易读。

表格26-1列出了所有的RegExOoptions及其所对应在的单个字符：

+--------------------+----------------------------+----------------------------------------------------------------------+
| Enum value         | Regular expressions code   | Description                                                          |
+--------------------+----------------------------+----------------------------------------------------------------------+
| None               |
+--------------------+----------------------------+----------------------------------------------------------------------+
| IgnoreCase         | i                          | 忽略大小写（默认情况下，正则表达式是大小写敏感的）                   |
+--------------------+----------------------------+----------------------------------------------------------------------+
| Multiline          | m                          | 改变^与$，从而他们匹配一行的开始与结束而不是一个字符串的开始与结束   |
+--------------------+----------------------------+----------------------------------------------------------------------+
| ExpliciCapture     | n                          | 仅捕获显示命名或是显示编号的组                                       |
+--------------------+----------------------------+----------------------------------------------------------------------+
| Compiled           | c                          | 强制正则表达式编译为IL                                               |
+--------------------+----------------------------+----------------------------------------------------------------------+
| Singleline         | s                          | 使得.匹配所有字符（而不是匹配除\\n之外的所有字符）                   |
+--------------------+----------------------------+----------------------------------------------------------------------+
| | IgnorePattern    | x                          | 去掉模式中未转义的空格                                               |
| | Whitespace       |                            |                                                                      |
+--------------------+----------------------------+----------------------------------------------------------------------+
| RightToLeft        | r                          | 由右向左查找                                                         |
+--------------------+----------------------------+----------------------------------------------------------------------+
| ECMAScript         |                            | 强制ECMA兼容（默认实现并不是ECMA兼容的）                             |
+--------------------+----------------------------+----------------------------------------------------------------------+
| CultureInvariant   |                            | 关闭语言相同的行为                                                   |
+--------------------+----------------------------+----------------------------------------------------------------------+

Table: Table 26-1. Regular expression options

字符转义
~~~~~~~~

正则表达式包含有下列的元字符，这些字符具有特殊的含义，而不是字面含义：

\\ \* + ? \| { [ () ^ $ . #

要引用元字符的字面值，我们必须在这些字符前使用反斜线作为前缀。在下面的示例中，我们转义？字符来匹配“what？”：

.. code:: csharp

    Console.WriteLine (Regex.Match ("what?", @"what\?")); // what? (correct)
    Console.WriteLine (Regex.Match ("what?", @"what?"));  // what  (incorrect)

Category:MS

.. |csharp\_table\_2\_3\_1.png| image:: csharp_table_2_3_1.png
.. |csharp\_table\_2\_3\_2.png| image:: csharp_table_2_3_2.png
.. |csharp\_table\_2\_3\_3.png| image:: csharp_table_2_3_3.png
.. |csharp\_table\_2\_3\_4.png| image:: csharp_table_2_3_4.png
.. |csharp\_table\_6\_1.png| image:: csharp_table_6_1.png
.. |csharp\_table\_6\_1\_2.png| image:: csharp_table_6_1_2.png
.. |csharp\_table\_18\_1\_1.png| image:: csharp_table_18_1_1.png
.. |csharp\_table\_18\_1\_2.png| image:: csharp_table_18_1_2.png
